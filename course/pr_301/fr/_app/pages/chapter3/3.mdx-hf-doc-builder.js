import{S as ai,i as ni,s as ri,e as n,k as d,w as _,t as o,M as li,c as r,d as s,m as c,x as E,a as l,h as a,b as m,G as t,g as u,y as q,q as $,o as b,B as g,v as ii}from"../../chunks/vendor-hf-doc-builder.js";import{T as oi}from"../../chunks/Tip-hf-doc-builder.js";import{Y as ui}from"../../chunks/Youtube-hf-doc-builder.js";import{I as zr}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as V}from"../../chunks/CodeBlock-hf-doc-builder.js";import{C as di}from"../../chunks/CourseFloatingBanner-hf-doc-builder.js";import{F as ci}from"../../chunks/FrameworkSwitchCourse-hf-doc-builder.js";function pi(ge){let p,S,v,M,T,C,G,A,L,j,W,R,Ce,ue;return{c(){p=n("p"),S=o("\u{1F4A1} Si vous voulez t\xE9l\xE9charger automatiquement votre mod\xE8le sur le "),v=n("em"),M=o("Hub"),T=o(" pendant l\u2019entra\xEEnement, passez "),C=n("code"),G=o("push_to_hub=True"),A=o(" dans le "),L=n("code"),j=o("TrainingArguments"),W=o(". Nous en apprendrons plus \xE0 ce sujet au "),R=n("a"),Ce=o("chapitre 4"),ue=o("."),this.h()},l(B){p=r(B,"P",{});var P=l(p);S=a(P,"\u{1F4A1} Si vous voulez t\xE9l\xE9charger automatiquement votre mod\xE8le sur le "),v=r(P,"EM",{});var te=l(v);M=a(te,"Hub"),te.forEach(s),T=a(P," pendant l\u2019entra\xEEnement, passez "),C=r(P,"CODE",{});var ke=l(C);G=a(ke,"push_to_hub=True"),ke.forEach(s),A=a(P," dans le "),L=r(P,"CODE",{});var h=l(L);j=a(h,"TrainingArguments"),h.forEach(s),W=a(P,". Nous en apprendrons plus \xE0 ce sujet au "),R=r(P,"A",{href:!0});var Be=l(R);Ce=a(Be,"chapitre 4"),Be.forEach(s),ue=a(P,"."),P.forEach(s),this.h()},h(){m(R,"href","/course/fr/chapter4/3")},m(B,P){u(B,p,P),t(p,S),t(p,v),t(v,M),t(p,T),t(p,C),t(C,G),t(p,A),t(p,L),t(L,j),t(p,W),t(p,R),t(R,Ce),t(p,ue)},d(B){B&&s(p)}}}function mi(ge){let p,S,v,M,T,C,G,A;return{c(){p=n("p"),S=o("\u270F\uFE0F "),v=n("strong"),M=o("Essayez !"),T=d(),C=n("em"),G=o("Finetunez"),A=o(" un mod\xE8le sur le jeu de donn\xE9es GLUE SST-2, en utilisant le traitement des donn\xE9es que vous avez fait dans la section 2.")},l(L){p=r(L,"P",{});var j=l(p);S=a(j,"\u270F\uFE0F "),v=r(j,"STRONG",{});var W=l(v);M=a(W,"Essayez !"),W.forEach(s),T=c(j),C=r(j,"EM",{});var R=l(C);G=a(R,"Finetunez"),R.forEach(s),A=a(j," un mod\xE8le sur le jeu de donn\xE9es GLUE SST-2, en utilisant le traitement des donn\xE9es que vous avez fait dans la section 2."),j.forEach(s)},m(L,j){u(L,p,j),t(p,S),t(p,v),t(v,M),t(p,T),t(p,C),t(C,G),t(p,A)},d(L){L&&s(p)}}}function fi(ge){let p,S,v,M,T,C,G,A,L,j,W,R,Ce,ue,B,P,te,ke,h,Be,tt,po,mo,st,fo,vo,ot,ho,_o,at,Eo,qo,nt,$o,bo,je,go,Co,bs,Ve,ko,gs,ze,Cs,re,de,rt,Te,jo,lt,zo,ks,x,To,it,Po,wo,ut,xo,Do,dt,Oo,yo,ct,Ao,Lo,pt,So,Mo,js,Pe,zs,ce,Ts,se,Uo,We,No,Fo,mt,Io,Go,Ps,we,ws,pe,Ro,He,Bo,Vo,xs,D,Wo,ft,Ho,Yo,vt,Jo,Xo,ht,Ko,Qo,_t,Zo,ea,Et,ta,sa,Ds,xe,Os,O,oa,qt,aa,na,$t,ra,la,bt,ia,ua,gt,da,ca,Ct,pa,ma,ys,H,fa,kt,va,ha,jt,_a,Ea,zt,qa,$a,As,De,Ls,me,ba,Tt,ga,Ca,Ss,fe,w,ka,Pt,ja,za,wt,Ta,Pa,xt,wa,xa,Dt,Da,Oa,Ot,ya,Aa,yt,La,Sa,Ma,le,Ua,At,Na,Fa,Lt,Ia,Ga,Ms,ie,ve,St,Oe,Ra,Mt,Ba,Us,z,Va,Ut,Wa,Ha,Nt,Ya,Ja,Ft,Xa,Ka,It,Qa,Za,Gt,en,tn,Rt,sn,on,Ns,ye,Fs,Ae,Is,f,an,Bt,nn,rn,Vt,ln,un,Wt,dn,cn,Ht,pn,mn,Yt,fn,vn,Jt,hn,_n,Xt,En,qn,Kt,$n,bn,Qt,gn,Cn,Gs,U,kn,Zt,jn,zn,es,Tn,Pn,Ye,wn,xn,ts,Dn,On,Rs,Le,Bs,y,yn,ss,An,Ln,os,Sn,Mn,Se,as,Un,Nn,ns,Fn,In,rs,Gn,Rn,Vs,Me,Ws,Ue,Hs,Y,Bn,Ne,Vn,Wn,ls,Hn,Yn,is,Jn,Xn,Ys,he,Kn,us,Qn,Zn,Js,Fe,Xs,oe,er,ds,tr,sr,cs,or,ar,Ks,Ie,Qs,J,nr,ps,rr,lr,ms,ir,ur,fs,dr,cr,Zs,Ge,eo,Je,pr,to,ae,mr,vs,fr,vr,hs,hr,_r,so,X,Er,_s,qr,$r,Es,br,gr,Xe,Cr,kr,oo,_e,ao;return v=new ci({props:{fw:ge[0]}}),A=new zr({}),B=new di({props:{chapter:3,classNames:"absolute z-10 right-0 top-0",notebooks:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter3/section3.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter3/section3.ipynb"}]}}),te=new ui({props:{id:"nvBXf7s7vTI"}}),ze=new V({props:{code:`from datasets import load_dataset
from transformers import AutoTokenizer, DataCollatorWithPadding

raw_datasets = load_dataset("glue", "mrpc")
checkpoint = "bert-base-uncased"
tokenizer = AutoTokenizer.from_pretrained(checkpoint)


def tokenize_function(example):
    return tokenizer(example["sentence1"], example["sentence2"], truncation=True)


tokenized_datasets = raw_datasets.map(tokenize_function, batched=True)
data_collator = DataCollatorWithPadding(tokenizer=tokenizer)`,highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, DataCollatorWithPadding

raw_datasets = load_dataset(<span class="hljs-string">&quot;glue&quot;</span>, <span class="hljs-string">&quot;mrpc&quot;</span>)
checkpoint = <span class="hljs-string">&quot;bert-base-uncased&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(checkpoint)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize_function</span>(<span class="hljs-params">example</span>):
    <span class="hljs-keyword">return</span> tokenizer(example[<span class="hljs-string">&quot;sentence1&quot;</span>], example[<span class="hljs-string">&quot;sentence2&quot;</span>], truncation=<span class="hljs-literal">True</span>)


tokenized_datasets = raw_datasets.<span class="hljs-built_in">map</span>(tokenize_function, batched=<span class="hljs-literal">True</span>)
data_collator = DataCollatorWithPadding(tokenizer=tokenizer)`}}),Te=new zr({}),Pe=new V({props:{code:`from transformers import TrainingArguments

training_args = TrainingArguments("test-trainer")`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

training_args = TrainingArguments(<span class="hljs-string">&quot;test-trainer&quot;</span>)`}}),ce=new oi({props:{$$slots:{default:[pi]},$$scope:{ctx:ge}}}),we=new V({props:{code:`from transformers import AutoModelForSequenceClassification

model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSequenceClassification

model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=<span class="hljs-number">2</span>)`}}),xe=new V({props:{code:`from transformers import Trainer

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets["train"],
    eval_dataset=tokenized_datasets["validation"],
    data_collator=data_collator,
    tokenizer=tokenizer,
)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Trainer

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>],
    eval_dataset=tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>],
    data_collator=data_collator,
    tokenizer=tokenizer,
)`}}),De=new V({props:{code:"trainer.train()",highlighted:"trainer.train()"}}),Oe=new zr({}),ye=new V({props:{code:`predictions = trainer.predict(tokenized_datasets["validation"])
print(predictions.predictions.shape, predictions.label_ids.shape)`,highlighted:`predictions = trainer.predict(tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>])
<span class="hljs-built_in">print</span>(predictions.predictions.shape, predictions.label_ids.shape)`}}),Ae=new V({props:{code:"(408, 2) (408,)",highlighted:'(<span class="hljs-number">408</span>, <span class="hljs-number">2</span>) (<span class="hljs-number">408</span>,)'}}),Le=new V({props:{code:`import numpy as np

preds = np.argmax(predictions.predictions, axis=-1)`,highlighted:`<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

preds = np.argmax(predictions.predictions, axis=-<span class="hljs-number">1</span>)`}}),Me=new V({props:{code:`import evaluate

metric = evaluate.load("glue", "mrpc")
metric.compute(predictions=preds, references=predictions.label_ids)`,highlighted:`<span class="hljs-keyword">import</span> evaluate

metric = evaluate.load(<span class="hljs-string">&quot;glue&quot;</span>, <span class="hljs-string">&quot;mrpc&quot;</span>)
metric.compute(predictions=preds, references=predictions.label_ids)`}}),Ue=new V({props:{code:"{'accuracy': 0.8578431372549019, 'f1': 0.8996539792387542}",highlighted:'{<span class="hljs-string">&#x27;accuracy&#x27;</span>: <span class="hljs-number">0.8578431372549019</span>, <span class="hljs-string">&#x27;f1&#x27;</span>: <span class="hljs-number">0.8996539792387542</span>}'}}),Fe=new V({props:{code:`def compute_metrics(eval_preds):
    metric = evaluate.load("glue", "mrpc")
    logits, labels = eval_preds
    predictions = np.argmax(logits, axis=-1)
    return metric.compute(predictions=predictions, references=labels)`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_metrics</span>(<span class="hljs-params">eval_preds</span>):
    metric = evaluate.load(<span class="hljs-string">&quot;glue&quot;</span>, <span class="hljs-string">&quot;mrpc&quot;</span>)
    logits, labels = eval_preds
    predictions = np.argmax(logits, axis=-<span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> metric.compute(predictions=predictions, references=labels)`}}),Ie=new V({props:{code:`training_args = TrainingArguments("test-trainer", evaluation_strategy="epoch")
model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets["train"],
    eval_dataset=tokenized_datasets["validation"],
    data_collator=data_collator,
    tokenizer=tokenizer,
    compute_metrics=compute_metrics,
)`,highlighted:`training_args = TrainingArguments(<span class="hljs-string">&quot;test-trainer&quot;</span>, evaluation_strategy=<span class="hljs-string">&quot;epoch&quot;</span>)
model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=<span class="hljs-number">2</span>)

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>],
    eval_dataset=tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>],
    data_collator=data_collator,
    tokenizer=tokenizer,
    compute_metrics=compute_metrics,
)`}}),Ge=new V({props:{code:"trainer.train()",highlighted:'trainer.trai<span class="hljs-meta">n</span>()'}}),_e=new oi({props:{$$slots:{default:[mi]},$$scope:{ctx:ge}}}),{c(){p=n("meta"),S=d(),_(v.$$.fragment),M=d(),T=n("h1"),C=n("a"),G=n("span"),_(A.$$.fragment),L=d(),j=n("span"),W=n("i"),R=o("Finetuner"),Ce=o(" un mod\xE8le avec l'API Trainer"),ue=d(),_(B.$$.fragment),P=d(),_(te.$$.fragment),ke=d(),h=n("p"),Be=o("La biblioth\xE8que \u{1F917} "),tt=n("em"),po=o("Transformers"),mo=o(" fournit une classe "),st=n("code"),fo=o("Trainer"),vo=o(" pour vous aider \xE0 "),ot=n("em"),ho=o("finetuner"),_o=o(" n\u2019importe lequel des mod\xE8les pr\xE9-entra\xEEn\xE9s qu\u2019elle met \xE0 disposition sur votre jeu de donn\xE9es. Une fois que vous avez fait tout le travail de pr\xE9traitement des donn\xE9es dans la derni\xE8re section, il ne vous reste que quelques \xE9tapes pour d\xE9finir le "),at=n("code"),Eo=o("Trainer"),qo=o(". La partie la plus difficile sera probablement de pr\xE9parer l\u2019environnement pour ex\xE9cuter "),nt=n("code"),$o=o("Trainer.train()"),bo=o(", car elle fonctionnera tr\xE8s lentement sur un CPU. Si vous n\u2019avez pas de GPU, vous pouvez avoir acc\xE8s \xE0 des GPUs ou TPUs gratuits sur "),je=n("a"),go=o("Google Colab"),Co=o("."),bs=d(),Ve=n("p"),ko=o("Les exemples de code ci-dessous supposent que vous avez d\xE9j\xE0 ex\xE9cut\xE9 les exemples de la section pr\xE9c\xE9dente. Voici un bref r\xE9sum\xE9 de ce dont vous avez besoin :"),gs=d(),_(ze.$$.fragment),Cs=d(),re=n("h3"),de=n("a"),rt=n("span"),_(Te.$$.fragment),jo=d(),lt=n("span"),zo=o("Entra\xEEnement"),ks=d(),x=n("p"),To=o("La premi\xE8re \xE9tape avant de pouvoir d\xE9finir notre "),it=n("code"),Po=o("Trainer"),wo=o(" est de d\xE9finir une classe "),ut=n("code"),xo=o("TrainingArguments"),Do=o(" qui contiendra tous les hyperparam\xE8tres que le "),dt=n("code"),Oo=o("Trainer"),yo=o(" utilisera pour l\u2019entra\xEEnement et l\u2019\xE9valuation. Le seul argument que vous devez fournir est un r\xE9pertoire o\xF9 le mod\xE8le entra\xEEn\xE9 sera sauvegard\xE9, ainsi que les "),ct=n("em"),Ao=o("checkpoints"),Lo=o(". Pour tout le reste, vous pouvez laisser les valeurs par d\xE9faut, qui devraient fonctionner assez bien pour un "),pt=n("em"),So=o("finetuning"),Mo=o(" de base."),js=d(),_(Pe.$$.fragment),zs=d(),_(ce.$$.fragment),Ts=d(),se=n("p"),Uo=o("La deuxi\xE8me \xE9tape consiste \xE0 d\xE9finir notre mod\xE8le. Comme dans le "),We=n("a"),No=o("chapitre pr\xE9c\xE9dent"),Fo=o(", nous utiliserons la classe "),mt=n("code"),Io=o("AutoModelForSequenceClassification"),Go=o(", avec deux labels :"),Ps=d(),_(we.$$.fragment),ws=d(),pe=n("p"),Ro=o("Vous remarquerez que contrairement au "),He=n("a"),Bo=o("chapitre 2"),Vo=o(", vous obtenez un message d\u2019avertissement apr\xE8s l\u2019instanciation de ce mod\xE8le pr\xE9-entra\xEEn\xE9. C\u2019est parce que BERT n\u2019a pas \xE9t\xE9 pr\xE9-entra\xEEn\xE9 \xE0 la classification de paires de phrases, donc la t\xEAte du mod\xE8le pr\xE9-entra\xEEn\xE9 a \xE9t\xE9 supprim\xE9e et une nouvelle t\xEAte adapt\xE9e \xE0 la classification de s\xE9quences a \xE9t\xE9 ajout\xE9e \xE0 la place. Les messages d\u2019avertissement indiquent que certains poids n\u2019ont pas \xE9t\xE9 utilis\xE9s (ceux correspondant \xE0 la t\xEAte de pr\xE9-entra\xEEnement abandonn\xE9e) et que d\u2019autres ont \xE9t\xE9 initialis\xE9s de mani\xE8re al\xE9atoire (ceux pour la nouvelle t\xEAte). Il conclut en vous encourageant \xE0 entra\xEEner le mod\xE8le, ce qui est exactement ce que nous allons faire maintenant."),xs=d(),D=n("p"),Wo=o("Une fois que nous avons notre mod\xE8le, nous pouvons d\xE9finir un "),ft=n("code"),Ho=o("Trainer"),Yo=o(" en lui passant tous les objets construits jusqu\u2019\xE0 pr\xE9sent : le "),vt=n("code"),Jo=o("model"),Xo=o(", le "),ht=n("code"),Ko=o("training_args"),Qo=o(", les jeux de donn\xE9es d\u2019entra\xEEnement et de validation, notre "),_t=n("code"),Zo=o("data_collator"),ea=o(", et notre "),Et=n("code"),ta=o("tokenizer"),sa=o(" :"),Ds=d(),_(xe.$$.fragment),Os=d(),O=n("p"),oa=o("Notez que lorsque vous passez le "),qt=n("code"),aa=o("tokenizer"),na=o(" comme nous l\u2019avons fait ici, le "),$t=n("code"),ra=o("data_collator"),la=o(" par d\xE9faut utilis\xE9 par le "),bt=n("code"),ia=o("Trainer"),ua=o(" sera un "),gt=n("code"),da=o("DataCollatorWithPadding"),ca=o(" comme d\xE9fini pr\xE9c\xE9demment. Ainsi, vous pouvez sauter la ligne "),Ct=n("code"),pa=o("data_collator=data_collator"),ma=o(" dans cet appel. Il \xE9tait quand m\xEAme important de vous montrer cette partie du traitement dans la section 2 !"),ys=d(),H=n("p"),fa=o("Pour "),kt=n("em"),va=o("finetuner"),ha=o(" le mod\xE8le sur notre jeu de donn\xE9es, il suffit d\u2019appeler la m\xE9thode "),jt=n("code"),_a=o("train()"),Ea=o(" de notre "),zt=n("code"),qa=o("Trainer"),$a=o(" :"),As=d(),_(De.$$.fragment),Ls=d(),me=n("p"),ba=o("Cela lancera le "),Tt=n("em"),ga=o("finetuning"),Ca=o(" (qui devrait prendre quelques minutes sur un GPU) et indiquera la perte d\u2019entra\xEEnement tous les 500 pas. Cependant, elle ne vous dira pas si votre mod\xE8le fonctionne bien (ou mal). Ceci est d\xFB au fait que :"),Ss=d(),fe=n("ol"),w=n("li"),ka=o("nous n\u2019avons pas dit au "),Pt=n("code"),ja=o("Trainer"),za=o(" d\u2019\xE9valuer pendant l\u2019entra\xEEnement en r\xE9glant "),wt=n("code"),Ta=o("evaluation_strategy"),Pa=o(" \xE0 soit "),xt=n("code"),wa=o('"steps"'),xa=o(" (\xE9valuer chaque "),Dt=n("code"),Da=o("eval_steps"),Oa=o(") ou "),Ot=n("code"),ya=o('"epoch"'),Aa=o(" (\xE9valuer \xE0 la fin de chaque "),yt=n("em"),La=o("epoch"),Sa=o(")."),Ma=d(),le=n("li"),Ua=o("nous n\u2019avons pas fourni au "),At=n("code"),Na=o("Trainer"),Fa=o(" une fonction "),Lt=n("code"),Ia=o("compute_metrics()"),Ga=o(" pour calculer une m\xE9trique pendant ladite \xE9valuation (sinon l\u2019\xE9valuation aurait juste affich\xE9 la perte, qui n\u2019est pas un nombre tr\xE8s intuitif)."),Ms=d(),ie=n("h3"),ve=n("a"),St=n("span"),_(Oe.$$.fragment),Ra=d(),Mt=n("span"),Ba=o("Evaluation"),Us=d(),z=n("p"),Va=o("Voyons comment nous pouvons construire une fonction "),Ut=n("code"),Wa=o("compute_metrics()"),Ha=o(" utile et l\u2019utiliser la prochaine fois que nous entra\xEEnons. La fonction doit prendre un objet "),Nt=n("code"),Ya=o("EvalPrediction"),Ja=o(" (qui est un "),Ft=n("em"),Xa=o("tuple"),Ka=o(" nomm\xE9 avec un champ "),It=n("code"),Qa=o("predictions"),Za=o(" et un champ "),Gt=n("code"),en=o("label_ids"),tn=o(") et retournera un dictionnaire de cha\xEEnes de caract\xE8res vers des flottants (les cha\xEEnes de caract\xE8res \xE9tant les noms des m\xE9triques retourn\xE9es, et les flottants leurs valeurs). Pour obtenir des pr\xE9dictions de notre mod\xE8le, nous pouvons utiliser la commande "),Rt=n("code"),sn=o("Trainer.predict()"),on=o(" :"),Ns=d(),_(ye.$$.fragment),Fs=d(),_(Ae.$$.fragment),Is=d(),f=n("p"),an=o("La sortie de la m\xE9thode "),Bt=n("code"),nn=o("predict()"),rn=o(" est un autre "),Vt=n("em"),ln=o("tuple"),un=o(" nomm\xE9 avec trois champs : "),Wt=n("code"),dn=o("predictions"),cn=o(", "),Ht=n("code"),pn=o("label_ids"),mn=o(", et "),Yt=n("code"),fn=o("metrics"),vn=o(". Le champ "),Jt=n("code"),hn=o("metrics"),_n=o(" contiendra juste la perte sur le jeu de donn\xE9es pass\xE9, ainsi que quelques mesures de temps (combien de temps il a fallu pour pr\xE9dire, au total et en moyenne). Une fois que nous aurons compl\xE9t\xE9 notre fonction "),Xt=n("code"),En=o("compute_metrics()"),qn=o(" et que nous l\u2019aurons pass\xE9 au "),Kt=n("code"),$n=o("Trainer"),bn=o(", ce champ contiendra \xE9galement les m\xE9triques retourn\xE9es par "),Qt=n("code"),gn=o("compute_metrics()"),Cn=o("."),Gs=d(),U=n("p"),kn=o("Comme vous pouvez le voir, "),Zt=n("code"),jn=o("predictions"),zn=o(" est un tableau bidimensionnel de forme 408 x 2 (408 \xE9tant le nombre d\u2019\xE9l\xE9ments dans le jeu de donn\xE9es que nous avons utilis\xE9). Ce sont les logits pour chaque \xE9l\xE9ment du jeu de donn\xE9es que nous avons pass\xE9 \xE0 "),es=n("code"),Tn=o("predict()"),Pn=o(" (comme vous l\u2019avez vu dans le "),Ye=n("a"),wn=o("chapitre pr\xE9c\xE9dent"),xn=o(", tous les "),ts=n("em"),Dn=o("transformers"),On=o(" retournent des logits). Pour les transformer en pr\xE9dictions que nous pouvons comparer \xE0 nos \xE9tiquettes, nous devons prendre l\u2019indice avec la valeur maximale sur le second axe :"),Rs=d(),_(Le.$$.fragment),Bs=d(),y=n("p"),yn=o("Nous pouvons maintenant comparer ces "),ss=n("code"),An=o("preds"),Ln=o(" aux \xE9tiquettes. Pour construire notre fonction "),os=n("code"),Sn=o("compute_metric()"),Mn=o(", nous allons nous appuyer sur les m\xE9triques de la biblioth\xE8que \u{1F917} "),Se=n("a"),as=n("em"),Un=o("Evaluate"),Nn=o(". Nous pouvons charger les m\xE9triques associ\xE9es au jeu de donn\xE9es MRPC aussi facilement que nous avons charg\xE9 le jeu de donn\xE9es, cette fois avec la fonction "),ns=n("code"),Fn=o("evaluate.load()"),In=o(". L\u2019objet retourn\xE9 poss\xE8de une m\xE9thode "),rs=n("code"),Gn=o("compute()"),Rn=o(" que nous pouvons utiliser pour effectuer le calcul de la m\xE9trique :"),Vs=d(),_(Me.$$.fragment),Ws=d(),_(Ue.$$.fragment),Hs=d(),Y=n("p"),Bn=o("Les r\xE9sultats exacts que vous obtiendrez peuvent varier, car l\u2019initialisation al\xE9atoire de la t\xEAte du mod\xE8le peut modifier les m\xE9triques obtenues. Ici, nous pouvons voir que notre mod\xE8le a une pr\xE9cision de 85,78% sur l\u2019ensemble de validation et un score F1 de 89,97. Ce sont les deux m\xE9triques utilis\xE9es pour \xE9valuer les r\xE9sultats sur le jeu de donn\xE9es MRPC pour le benchmark GLUE. Le tableau du papier de "),Ne=n("a"),Vn=o("BERT"),Wn=o(" indique un score F1 de 88,9 pour le mod\xE8le de base. Il s\u2019agissait du mod\xE8le "),ls=n("code"),Hn=o("uncased"),Yn=o(" alors que nous utilisons actuellement le mod\xE8le "),is=n("code"),Jn=o("cased"),Xn=o(", ce qui explique le meilleur r\xE9sultat."),Ys=d(),he=n("p"),Kn=o("En regroupant le tout, nous obtenons notre fonction "),us=n("code"),Qn=o("compute_metrics()"),Zn=o(" :"),Js=d(),_(Fe.$$.fragment),Xs=d(),oe=n("p"),er=o("Et pour le voir utilis\xE9 en action pour rapporter les m\xE9triques \xE0 la fin de chaque \xE9poque, voici comment nous d\xE9finissons un nouveau "),ds=n("code"),tr=o("Trainer"),sr=o(" avec cette fonction "),cs=n("code"),or=o("compute_metrics()"),ar=o(" :"),Ks=d(),_(Ie.$$.fragment),Qs=d(),J=n("p"),nr=o("Notez que nous cr\xE9ons un nouveau "),ps=n("code"),rr=o("TrainingArguments"),lr=o(" avec sa "),ms=n("code"),ir=o("evaluation_strategy"),ur=o(" d\xE9finie sur "),fs=n("code"),dr=o('"epoch"'),cr=o(" et un nouveau mod\xE8le. Sinon, nous ne ferions que continuer l\u2019entra\xEEnement du mod\xE8le que nous avons d\xE9j\xE0 entra\xEEn\xE9. Pour lancer un nouveau cycle d\u2019entra\xEEnement, nous ex\xE9cutons :"),Zs=d(),_(Ge.$$.fragment),eo=d(),Je=n("p"),pr=o("Cette fois, il indiquera la perte et les mesures de validation \xE0 la fin de chaque \xE9poque, en plus de la perte d\u2019entra\xEEnement. Encore une fois, le score exact de pr\xE9cision/F1 que vous atteignez peut \xEAtre un peu diff\xE9rent de ce que nous avons trouv\xE9, en raison de l\u2019initialisation al\xE9atoire de la t\xEAte du mod\xE8le, mais il devrait \xEAtre dans la m\xEAme fourchette."),to=d(),ae=n("p"),mr=o("Le "),vs=n("code"),fr=o("Trainer"),vr=o(" fonctionnera sur plusieurs GPUs ou TPUs et fournit beaucoup d\u2019options, comme l\u2019entra\xEEnement en pr\xE9cision mixte (utilisez "),hs=n("code"),hr=o("fp16 = True"),_r=o(" dans vos arguments d\u2019entra\xEEnement). Nous passerons en revue tout ce qu\u2019il supporte dans le chapitre 10."),so=d(),X=n("p"),Er=o("Ceci conclut l\u2019introduction au "),_s=n("em"),qr=o("fine-tuning"),$r=o(" en utilisant l\u2019API "),Es=n("code"),br=o("Trainer"),gr=o(". Un exemple d\u2019utilisation pour les t\xE2ches de NLP les plus communes es donn\xE9 dans le "),Xe=n("a"),Cr=o("chapitre 7"),kr=o(", mais pour l\u2019instant regardons comment faire la m\xEAme chose en PyTorch pur."),oo=d(),_(_e.$$.fragment),this.h()},l(e){const i=li('[data-svelte="svelte-1phssyn"]',document.head);p=r(i,"META",{name:!0,content:!0}),i.forEach(s),S=c(e),E(v.$$.fragment,e),M=c(e),T=r(e,"H1",{class:!0});var Re=l(T);C=r(Re,"A",{id:!0,class:!0,href:!0});var qs=l(C);G=r(qs,"SPAN",{});var $s=l(G);E(A.$$.fragment,$s),$s.forEach(s),qs.forEach(s),L=c(Re),j=r(Re,"SPAN",{});var jr=l(j);W=r(jr,"I",{});var Tr=l(W);R=a(Tr,"Finetuner"),Tr.forEach(s),Ce=a(jr," un mod\xE8le avec l'API Trainer"),jr.forEach(s),Re.forEach(s),ue=c(e),E(B.$$.fragment,e),P=c(e),E(te.$$.fragment,e),ke=c(e),h=r(e,"P",{});var N=l(h);Be=a(N,"La biblioth\xE8que \u{1F917} "),tt=r(N,"EM",{});var Pr=l(tt);po=a(Pr,"Transformers"),Pr.forEach(s),mo=a(N," fournit une classe "),st=r(N,"CODE",{});var wr=l(st);fo=a(wr,"Trainer"),wr.forEach(s),vo=a(N," pour vous aider \xE0 "),ot=r(N,"EM",{});var xr=l(ot);ho=a(xr,"finetuner"),xr.forEach(s),_o=a(N," n\u2019importe lequel des mod\xE8les pr\xE9-entra\xEEn\xE9s qu\u2019elle met \xE0 disposition sur votre jeu de donn\xE9es. Une fois que vous avez fait tout le travail de pr\xE9traitement des donn\xE9es dans la derni\xE8re section, il ne vous reste que quelques \xE9tapes pour d\xE9finir le "),at=r(N,"CODE",{});var Dr=l(at);Eo=a(Dr,"Trainer"),Dr.forEach(s),qo=a(N,". La partie la plus difficile sera probablement de pr\xE9parer l\u2019environnement pour ex\xE9cuter "),nt=r(N,"CODE",{});var Or=l(nt);$o=a(Or,"Trainer.train()"),Or.forEach(s),bo=a(N,", car elle fonctionnera tr\xE8s lentement sur un CPU. Si vous n\u2019avez pas de GPU, vous pouvez avoir acc\xE8s \xE0 des GPUs ou TPUs gratuits sur "),je=r(N,"A",{href:!0,rel:!0});var yr=l(je);go=a(yr,"Google Colab"),yr.forEach(s),Co=a(N,"."),N.forEach(s),bs=c(e),Ve=r(e,"P",{});var Ar=l(Ve);ko=a(Ar,"Les exemples de code ci-dessous supposent que vous avez d\xE9j\xE0 ex\xE9cut\xE9 les exemples de la section pr\xE9c\xE9dente. Voici un bref r\xE9sum\xE9 de ce dont vous avez besoin :"),Ar.forEach(s),gs=c(e),E(ze.$$.fragment,e),Cs=c(e),re=r(e,"H3",{class:!0});var no=l(re);de=r(no,"A",{id:!0,class:!0,href:!0});var Lr=l(de);rt=r(Lr,"SPAN",{});var Sr=l(rt);E(Te.$$.fragment,Sr),Sr.forEach(s),Lr.forEach(s),jo=c(no),lt=r(no,"SPAN",{});var Mr=l(lt);zo=a(Mr,"Entra\xEEnement"),Mr.forEach(s),no.forEach(s),ks=c(e),x=r(e,"P",{});var K=l(x);To=a(K,"La premi\xE8re \xE9tape avant de pouvoir d\xE9finir notre "),it=r(K,"CODE",{});var Ur=l(it);Po=a(Ur,"Trainer"),Ur.forEach(s),wo=a(K," est de d\xE9finir une classe "),ut=r(K,"CODE",{});var Nr=l(ut);xo=a(Nr,"TrainingArguments"),Nr.forEach(s),Do=a(K," qui contiendra tous les hyperparam\xE8tres que le "),dt=r(K,"CODE",{});var Fr=l(dt);Oo=a(Fr,"Trainer"),Fr.forEach(s),yo=a(K," utilisera pour l\u2019entra\xEEnement et l\u2019\xE9valuation. Le seul argument que vous devez fournir est un r\xE9pertoire o\xF9 le mod\xE8le entra\xEEn\xE9 sera sauvegard\xE9, ainsi que les "),ct=r(K,"EM",{});var Ir=l(ct);Ao=a(Ir,"checkpoints"),Ir.forEach(s),Lo=a(K,". Pour tout le reste, vous pouvez laisser les valeurs par d\xE9faut, qui devraient fonctionner assez bien pour un "),pt=r(K,"EM",{});var Gr=l(pt);So=a(Gr,"finetuning"),Gr.forEach(s),Mo=a(K," de base."),K.forEach(s),js=c(e),E(Pe.$$.fragment,e),zs=c(e),E(ce.$$.fragment,e),Ts=c(e),se=r(e,"P",{});var Ke=l(se);Uo=a(Ke,"La deuxi\xE8me \xE9tape consiste \xE0 d\xE9finir notre mod\xE8le. Comme dans le "),We=r(Ke,"A",{href:!0});var Rr=l(We);No=a(Rr,"chapitre pr\xE9c\xE9dent"),Rr.forEach(s),Fo=a(Ke,", nous utiliserons la classe "),mt=r(Ke,"CODE",{});var Br=l(mt);Io=a(Br,"AutoModelForSequenceClassification"),Br.forEach(s),Go=a(Ke,", avec deux labels :"),Ke.forEach(s),Ps=c(e),E(we.$$.fragment,e),ws=c(e),pe=r(e,"P",{});var ro=l(pe);Ro=a(ro,"Vous remarquerez que contrairement au "),He=r(ro,"A",{href:!0});var Vr=l(He);Bo=a(Vr,"chapitre 2"),Vr.forEach(s),Vo=a(ro,", vous obtenez un message d\u2019avertissement apr\xE8s l\u2019instanciation de ce mod\xE8le pr\xE9-entra\xEEn\xE9. C\u2019est parce que BERT n\u2019a pas \xE9t\xE9 pr\xE9-entra\xEEn\xE9 \xE0 la classification de paires de phrases, donc la t\xEAte du mod\xE8le pr\xE9-entra\xEEn\xE9 a \xE9t\xE9 supprim\xE9e et une nouvelle t\xEAte adapt\xE9e \xE0 la classification de s\xE9quences a \xE9t\xE9 ajout\xE9e \xE0 la place. Les messages d\u2019avertissement indiquent que certains poids n\u2019ont pas \xE9t\xE9 utilis\xE9s (ceux correspondant \xE0 la t\xEAte de pr\xE9-entra\xEEnement abandonn\xE9e) et que d\u2019autres ont \xE9t\xE9 initialis\xE9s de mani\xE8re al\xE9atoire (ceux pour la nouvelle t\xEAte). Il conclut en vous encourageant \xE0 entra\xEEner le mod\xE8le, ce qui est exactement ce que nous allons faire maintenant."),ro.forEach(s),xs=c(e),D=r(e,"P",{});var Q=l(D);Wo=a(Q,"Une fois que nous avons notre mod\xE8le, nous pouvons d\xE9finir un "),ft=r(Q,"CODE",{});var Wr=l(ft);Ho=a(Wr,"Trainer"),Wr.forEach(s),Yo=a(Q," en lui passant tous les objets construits jusqu\u2019\xE0 pr\xE9sent : le "),vt=r(Q,"CODE",{});var Hr=l(vt);Jo=a(Hr,"model"),Hr.forEach(s),Xo=a(Q,", le "),ht=r(Q,"CODE",{});var Yr=l(ht);Ko=a(Yr,"training_args"),Yr.forEach(s),Qo=a(Q,", les jeux de donn\xE9es d\u2019entra\xEEnement et de validation, notre "),_t=r(Q,"CODE",{});var Jr=l(_t);Zo=a(Jr,"data_collator"),Jr.forEach(s),ea=a(Q,", et notre "),Et=r(Q,"CODE",{});var Xr=l(Et);ta=a(Xr,"tokenizer"),Xr.forEach(s),sa=a(Q," :"),Q.forEach(s),Ds=c(e),E(xe.$$.fragment,e),Os=c(e),O=r(e,"P",{});var Z=l(O);oa=a(Z,"Notez que lorsque vous passez le "),qt=r(Z,"CODE",{});var Kr=l(qt);aa=a(Kr,"tokenizer"),Kr.forEach(s),na=a(Z," comme nous l\u2019avons fait ici, le "),$t=r(Z,"CODE",{});var Qr=l($t);ra=a(Qr,"data_collator"),Qr.forEach(s),la=a(Z," par d\xE9faut utilis\xE9 par le "),bt=r(Z,"CODE",{});var Zr=l(bt);ia=a(Zr,"Trainer"),Zr.forEach(s),ua=a(Z," sera un "),gt=r(Z,"CODE",{});var el=l(gt);da=a(el,"DataCollatorWithPadding"),el.forEach(s),ca=a(Z," comme d\xE9fini pr\xE9c\xE9demment. Ainsi, vous pouvez sauter la ligne "),Ct=r(Z,"CODE",{});var tl=l(Ct);pa=a(tl,"data_collator=data_collator"),tl.forEach(s),ma=a(Z," dans cet appel. Il \xE9tait quand m\xEAme important de vous montrer cette partie du traitement dans la section 2 !"),Z.forEach(s),ys=c(e),H=r(e,"P",{});var Ee=l(H);fa=a(Ee,"Pour "),kt=r(Ee,"EM",{});var sl=l(kt);va=a(sl,"finetuner"),sl.forEach(s),ha=a(Ee," le mod\xE8le sur notre jeu de donn\xE9es, il suffit d\u2019appeler la m\xE9thode "),jt=r(Ee,"CODE",{});var ol=l(jt);_a=a(ol,"train()"),ol.forEach(s),Ea=a(Ee," de notre "),zt=r(Ee,"CODE",{});var al=l(zt);qa=a(al,"Trainer"),al.forEach(s),$a=a(Ee," :"),Ee.forEach(s),As=c(e),E(De.$$.fragment,e),Ls=c(e),me=r(e,"P",{});var lo=l(me);ba=a(lo,"Cela lancera le "),Tt=r(lo,"EM",{});var nl=l(Tt);ga=a(nl,"finetuning"),nl.forEach(s),Ca=a(lo," (qui devrait prendre quelques minutes sur un GPU) et indiquera la perte d\u2019entra\xEEnement tous les 500 pas. Cependant, elle ne vous dira pas si votre mod\xE8le fonctionne bien (ou mal). Ceci est d\xFB au fait que :"),lo.forEach(s),Ss=c(e),fe=r(e,"OL",{});var io=l(fe);w=r(io,"LI",{});var F=l(w);ka=a(F,"nous n\u2019avons pas dit au "),Pt=r(F,"CODE",{});var rl=l(Pt);ja=a(rl,"Trainer"),rl.forEach(s),za=a(F," d\u2019\xE9valuer pendant l\u2019entra\xEEnement en r\xE9glant "),wt=r(F,"CODE",{});var ll=l(wt);Ta=a(ll,"evaluation_strategy"),ll.forEach(s),Pa=a(F," \xE0 soit "),xt=r(F,"CODE",{});var il=l(xt);wa=a(il,'"steps"'),il.forEach(s),xa=a(F," (\xE9valuer chaque "),Dt=r(F,"CODE",{});var ul=l(Dt);Da=a(ul,"eval_steps"),ul.forEach(s),Oa=a(F,") ou "),Ot=r(F,"CODE",{});var dl=l(Ot);ya=a(dl,'"epoch"'),dl.forEach(s),Aa=a(F," (\xE9valuer \xE0 la fin de chaque "),yt=r(F,"EM",{});var cl=l(yt);La=a(cl,"epoch"),cl.forEach(s),Sa=a(F,")."),F.forEach(s),Ma=c(io),le=r(io,"LI",{});var Qe=l(le);Ua=a(Qe,"nous n\u2019avons pas fourni au "),At=r(Qe,"CODE",{});var pl=l(At);Na=a(pl,"Trainer"),pl.forEach(s),Fa=a(Qe," une fonction "),Lt=r(Qe,"CODE",{});var ml=l(Lt);Ia=a(ml,"compute_metrics()"),ml.forEach(s),Ga=a(Qe," pour calculer une m\xE9trique pendant ladite \xE9valuation (sinon l\u2019\xE9valuation aurait juste affich\xE9 la perte, qui n\u2019est pas un nombre tr\xE8s intuitif)."),Qe.forEach(s),io.forEach(s),Ms=c(e),ie=r(e,"H3",{class:!0});var uo=l(ie);ve=r(uo,"A",{id:!0,class:!0,href:!0});var fl=l(ve);St=r(fl,"SPAN",{});var vl=l(St);E(Oe.$$.fragment,vl),vl.forEach(s),fl.forEach(s),Ra=c(uo),Mt=r(uo,"SPAN",{});var hl=l(Mt);Ba=a(hl,"Evaluation"),hl.forEach(s),uo.forEach(s),Us=c(e),z=r(e,"P",{});var I=l(z);Va=a(I,"Voyons comment nous pouvons construire une fonction "),Ut=r(I,"CODE",{});var _l=l(Ut);Wa=a(_l,"compute_metrics()"),_l.forEach(s),Ha=a(I," utile et l\u2019utiliser la prochaine fois que nous entra\xEEnons. La fonction doit prendre un objet "),Nt=r(I,"CODE",{});var El=l(Nt);Ya=a(El,"EvalPrediction"),El.forEach(s),Ja=a(I," (qui est un "),Ft=r(I,"EM",{});var ql=l(Ft);Xa=a(ql,"tuple"),ql.forEach(s),Ka=a(I," nomm\xE9 avec un champ "),It=r(I,"CODE",{});var $l=l(It);Qa=a($l,"predictions"),$l.forEach(s),Za=a(I," et un champ "),Gt=r(I,"CODE",{});var bl=l(Gt);en=a(bl,"label_ids"),bl.forEach(s),tn=a(I,") et retournera un dictionnaire de cha\xEEnes de caract\xE8res vers des flottants (les cha\xEEnes de caract\xE8res \xE9tant les noms des m\xE9triques retourn\xE9es, et les flottants leurs valeurs). Pour obtenir des pr\xE9dictions de notre mod\xE8le, nous pouvons utiliser la commande "),Rt=r(I,"CODE",{});var gl=l(Rt);sn=a(gl,"Trainer.predict()"),gl.forEach(s),on=a(I," :"),I.forEach(s),Ns=c(e),E(ye.$$.fragment,e),Fs=c(e),E(Ae.$$.fragment,e),Is=c(e),f=r(e,"P",{});var k=l(f);an=a(k,"La sortie de la m\xE9thode "),Bt=r(k,"CODE",{});var Cl=l(Bt);nn=a(Cl,"predict()"),Cl.forEach(s),rn=a(k," est un autre "),Vt=r(k,"EM",{});var kl=l(Vt);ln=a(kl,"tuple"),kl.forEach(s),un=a(k," nomm\xE9 avec trois champs : "),Wt=r(k,"CODE",{});var jl=l(Wt);dn=a(jl,"predictions"),jl.forEach(s),cn=a(k,", "),Ht=r(k,"CODE",{});var zl=l(Ht);pn=a(zl,"label_ids"),zl.forEach(s),mn=a(k,", et "),Yt=r(k,"CODE",{});var Tl=l(Yt);fn=a(Tl,"metrics"),Tl.forEach(s),vn=a(k,". Le champ "),Jt=r(k,"CODE",{});var Pl=l(Jt);hn=a(Pl,"metrics"),Pl.forEach(s),_n=a(k," contiendra juste la perte sur le jeu de donn\xE9es pass\xE9, ainsi que quelques mesures de temps (combien de temps il a fallu pour pr\xE9dire, au total et en moyenne). Une fois que nous aurons compl\xE9t\xE9 notre fonction "),Xt=r(k,"CODE",{});var wl=l(Xt);En=a(wl,"compute_metrics()"),wl.forEach(s),qn=a(k," et que nous l\u2019aurons pass\xE9 au "),Kt=r(k,"CODE",{});var xl=l(Kt);$n=a(xl,"Trainer"),xl.forEach(s),bn=a(k,", ce champ contiendra \xE9galement les m\xE9triques retourn\xE9es par "),Qt=r(k,"CODE",{});var Dl=l(Qt);gn=a(Dl,"compute_metrics()"),Dl.forEach(s),Cn=a(k,"."),k.forEach(s),Gs=c(e),U=r(e,"P",{});var ne=l(U);kn=a(ne,"Comme vous pouvez le voir, "),Zt=r(ne,"CODE",{});var Ol=l(Zt);jn=a(Ol,"predictions"),Ol.forEach(s),zn=a(ne," est un tableau bidimensionnel de forme 408 x 2 (408 \xE9tant le nombre d\u2019\xE9l\xE9ments dans le jeu de donn\xE9es que nous avons utilis\xE9). Ce sont les logits pour chaque \xE9l\xE9ment du jeu de donn\xE9es que nous avons pass\xE9 \xE0 "),es=r(ne,"CODE",{});var yl=l(es);Tn=a(yl,"predict()"),yl.forEach(s),Pn=a(ne," (comme vous l\u2019avez vu dans le "),Ye=r(ne,"A",{href:!0});var Al=l(Ye);wn=a(Al,"chapitre pr\xE9c\xE9dent"),Al.forEach(s),xn=a(ne,", tous les "),ts=r(ne,"EM",{});var Ll=l(ts);Dn=a(Ll,"transformers"),Ll.forEach(s),On=a(ne," retournent des logits). Pour les transformer en pr\xE9dictions que nous pouvons comparer \xE0 nos \xE9tiquettes, nous devons prendre l\u2019indice avec la valeur maximale sur le second axe :"),ne.forEach(s),Rs=c(e),E(Le.$$.fragment,e),Bs=c(e),y=r(e,"P",{});var ee=l(y);yn=a(ee,"Nous pouvons maintenant comparer ces "),ss=r(ee,"CODE",{});var Sl=l(ss);An=a(Sl,"preds"),Sl.forEach(s),Ln=a(ee," aux \xE9tiquettes. Pour construire notre fonction "),os=r(ee,"CODE",{});var Ml=l(os);Sn=a(Ml,"compute_metric()"),Ml.forEach(s),Mn=a(ee,", nous allons nous appuyer sur les m\xE9triques de la biblioth\xE8que \u{1F917} "),Se=r(ee,"A",{href:!0,rel:!0});var Ul=l(Se);as=r(Ul,"EM",{});var Nl=l(as);Un=a(Nl,"Evaluate"),Nl.forEach(s),Ul.forEach(s),Nn=a(ee,". Nous pouvons charger les m\xE9triques associ\xE9es au jeu de donn\xE9es MRPC aussi facilement que nous avons charg\xE9 le jeu de donn\xE9es, cette fois avec la fonction "),ns=r(ee,"CODE",{});var Fl=l(ns);Fn=a(Fl,"evaluate.load()"),Fl.forEach(s),In=a(ee,". L\u2019objet retourn\xE9 poss\xE8de une m\xE9thode "),rs=r(ee,"CODE",{});var Il=l(rs);Gn=a(Il,"compute()"),Il.forEach(s),Rn=a(ee," que nous pouvons utiliser pour effectuer le calcul de la m\xE9trique :"),ee.forEach(s),Vs=c(e),E(Me.$$.fragment,e),Ws=c(e),E(Ue.$$.fragment,e),Hs=c(e),Y=r(e,"P",{});var qe=l(Y);Bn=a(qe,"Les r\xE9sultats exacts que vous obtiendrez peuvent varier, car l\u2019initialisation al\xE9atoire de la t\xEAte du mod\xE8le peut modifier les m\xE9triques obtenues. Ici, nous pouvons voir que notre mod\xE8le a une pr\xE9cision de 85,78% sur l\u2019ensemble de validation et un score F1 de 89,97. Ce sont les deux m\xE9triques utilis\xE9es pour \xE9valuer les r\xE9sultats sur le jeu de donn\xE9es MRPC pour le benchmark GLUE. Le tableau du papier de "),Ne=r(qe,"A",{href:!0,rel:!0});var Gl=l(Ne);Vn=a(Gl,"BERT"),Gl.forEach(s),Wn=a(qe," indique un score F1 de 88,9 pour le mod\xE8le de base. Il s\u2019agissait du mod\xE8le "),ls=r(qe,"CODE",{});var Rl=l(ls);Hn=a(Rl,"uncased"),Rl.forEach(s),Yn=a(qe," alors que nous utilisons actuellement le mod\xE8le "),is=r(qe,"CODE",{});var Bl=l(is);Jn=a(Bl,"cased"),Bl.forEach(s),Xn=a(qe,", ce qui explique le meilleur r\xE9sultat."),qe.forEach(s),Ys=c(e),he=r(e,"P",{});var co=l(he);Kn=a(co,"En regroupant le tout, nous obtenons notre fonction "),us=r(co,"CODE",{});var Vl=l(us);Qn=a(Vl,"compute_metrics()"),Vl.forEach(s),Zn=a(co," :"),co.forEach(s),Js=c(e),E(Fe.$$.fragment,e),Xs=c(e),oe=r(e,"P",{});var Ze=l(oe);er=a(Ze,"Et pour le voir utilis\xE9 en action pour rapporter les m\xE9triques \xE0 la fin de chaque \xE9poque, voici comment nous d\xE9finissons un nouveau "),ds=r(Ze,"CODE",{});var Wl=l(ds);tr=a(Wl,"Trainer"),Wl.forEach(s),sr=a(Ze," avec cette fonction "),cs=r(Ze,"CODE",{});var Hl=l(cs);or=a(Hl,"compute_metrics()"),Hl.forEach(s),ar=a(Ze," :"),Ze.forEach(s),Ks=c(e),E(Ie.$$.fragment,e),Qs=c(e),J=r(e,"P",{});var $e=l(J);nr=a($e,"Notez que nous cr\xE9ons un nouveau "),ps=r($e,"CODE",{});var Yl=l(ps);rr=a(Yl,"TrainingArguments"),Yl.forEach(s),lr=a($e," avec sa "),ms=r($e,"CODE",{});var Jl=l(ms);ir=a(Jl,"evaluation_strategy"),Jl.forEach(s),ur=a($e," d\xE9finie sur "),fs=r($e,"CODE",{});var Xl=l(fs);dr=a(Xl,'"epoch"'),Xl.forEach(s),cr=a($e," et un nouveau mod\xE8le. Sinon, nous ne ferions que continuer l\u2019entra\xEEnement du mod\xE8le que nous avons d\xE9j\xE0 entra\xEEn\xE9. Pour lancer un nouveau cycle d\u2019entra\xEEnement, nous ex\xE9cutons :"),$e.forEach(s),Zs=c(e),E(Ge.$$.fragment,e),eo=c(e),Je=r(e,"P",{});var Kl=l(Je);pr=a(Kl,"Cette fois, il indiquera la perte et les mesures de validation \xE0 la fin de chaque \xE9poque, en plus de la perte d\u2019entra\xEEnement. Encore une fois, le score exact de pr\xE9cision/F1 que vous atteignez peut \xEAtre un peu diff\xE9rent de ce que nous avons trouv\xE9, en raison de l\u2019initialisation al\xE9atoire de la t\xEAte du mod\xE8le, mais il devrait \xEAtre dans la m\xEAme fourchette."),Kl.forEach(s),to=c(e),ae=r(e,"P",{});var et=l(ae);mr=a(et,"Le "),vs=r(et,"CODE",{});var Ql=l(vs);fr=a(Ql,"Trainer"),Ql.forEach(s),vr=a(et," fonctionnera sur plusieurs GPUs ou TPUs et fournit beaucoup d\u2019options, comme l\u2019entra\xEEnement en pr\xE9cision mixte (utilisez "),hs=r(et,"CODE",{});var Zl=l(hs);hr=a(Zl,"fp16 = True"),Zl.forEach(s),_r=a(et," dans vos arguments d\u2019entra\xEEnement). Nous passerons en revue tout ce qu\u2019il supporte dans le chapitre 10."),et.forEach(s),so=c(e),X=r(e,"P",{});var be=l(X);Er=a(be,"Ceci conclut l\u2019introduction au "),_s=r(be,"EM",{});var ei=l(_s);qr=a(ei,"fine-tuning"),ei.forEach(s),$r=a(be," en utilisant l\u2019API "),Es=r(be,"CODE",{});var ti=l(Es);br=a(ti,"Trainer"),ti.forEach(s),gr=a(be,". Un exemple d\u2019utilisation pour les t\xE2ches de NLP les plus communes es donn\xE9 dans le "),Xe=r(be,"A",{href:!0});var si=l(Xe);Cr=a(si,"chapitre 7"),si.forEach(s),kr=a(be,", mais pour l\u2019instant regardons comment faire la m\xEAme chose en PyTorch pur."),be.forEach(s),oo=c(e),E(_e.$$.fragment,e),this.h()},h(){m(p,"name","hf:doc:metadata"),m(p,"content",JSON.stringify(vi)),m(C,"id","ifinetuneri-un-modle-avec-lapi-trainer"),m(C,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(C,"href","#ifinetuneri-un-modle-avec-lapi-trainer"),m(T,"class","relative group"),m(je,"href","https://colab.research.google.com/"),m(je,"rel","nofollow"),m(de,"id","entranement"),m(de,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(de,"href","#entranement"),m(re,"class","relative group"),m(We,"href","/course/fr/chapter2"),m(He,"href","/course/fr/chapter2"),m(ve,"id","evaluation"),m(ve,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(ve,"href","#evaluation"),m(ie,"class","relative group"),m(Ye,"href","/course/fr/chapter2"),m(Se,"href","https://github.com/huggingface/evaluate/"),m(Se,"rel","nofollow"),m(Ne,"href","https://arxiv.org/pdf/1810.04805.pdf"),m(Ne,"rel","nofollow"),m(Xe,"href","/course/fr/chapter7")},m(e,i){t(document.head,p),u(e,S,i),q(v,e,i),u(e,M,i),u(e,T,i),t(T,C),t(C,G),q(A,G,null),t(T,L),t(T,j),t(j,W),t(W,R),t(j,Ce),u(e,ue,i),q(B,e,i),u(e,P,i),q(te,e,i),u(e,ke,i),u(e,h,i),t(h,Be),t(h,tt),t(tt,po),t(h,mo),t(h,st),t(st,fo),t(h,vo),t(h,ot),t(ot,ho),t(h,_o),t(h,at),t(at,Eo),t(h,qo),t(h,nt),t(nt,$o),t(h,bo),t(h,je),t(je,go),t(h,Co),u(e,bs,i),u(e,Ve,i),t(Ve,ko),u(e,gs,i),q(ze,e,i),u(e,Cs,i),u(e,re,i),t(re,de),t(de,rt),q(Te,rt,null),t(re,jo),t(re,lt),t(lt,zo),u(e,ks,i),u(e,x,i),t(x,To),t(x,it),t(it,Po),t(x,wo),t(x,ut),t(ut,xo),t(x,Do),t(x,dt),t(dt,Oo),t(x,yo),t(x,ct),t(ct,Ao),t(x,Lo),t(x,pt),t(pt,So),t(x,Mo),u(e,js,i),q(Pe,e,i),u(e,zs,i),q(ce,e,i),u(e,Ts,i),u(e,se,i),t(se,Uo),t(se,We),t(We,No),t(se,Fo),t(se,mt),t(mt,Io),t(se,Go),u(e,Ps,i),q(we,e,i),u(e,ws,i),u(e,pe,i),t(pe,Ro),t(pe,He),t(He,Bo),t(pe,Vo),u(e,xs,i),u(e,D,i),t(D,Wo),t(D,ft),t(ft,Ho),t(D,Yo),t(D,vt),t(vt,Jo),t(D,Xo),t(D,ht),t(ht,Ko),t(D,Qo),t(D,_t),t(_t,Zo),t(D,ea),t(D,Et),t(Et,ta),t(D,sa),u(e,Ds,i),q(xe,e,i),u(e,Os,i),u(e,O,i),t(O,oa),t(O,qt),t(qt,aa),t(O,na),t(O,$t),t($t,ra),t(O,la),t(O,bt),t(bt,ia),t(O,ua),t(O,gt),t(gt,da),t(O,ca),t(O,Ct),t(Ct,pa),t(O,ma),u(e,ys,i),u(e,H,i),t(H,fa),t(H,kt),t(kt,va),t(H,ha),t(H,jt),t(jt,_a),t(H,Ea),t(H,zt),t(zt,qa),t(H,$a),u(e,As,i),q(De,e,i),u(e,Ls,i),u(e,me,i),t(me,ba),t(me,Tt),t(Tt,ga),t(me,Ca),u(e,Ss,i),u(e,fe,i),t(fe,w),t(w,ka),t(w,Pt),t(Pt,ja),t(w,za),t(w,wt),t(wt,Ta),t(w,Pa),t(w,xt),t(xt,wa),t(w,xa),t(w,Dt),t(Dt,Da),t(w,Oa),t(w,Ot),t(Ot,ya),t(w,Aa),t(w,yt),t(yt,La),t(w,Sa),t(fe,Ma),t(fe,le),t(le,Ua),t(le,At),t(At,Na),t(le,Fa),t(le,Lt),t(Lt,Ia),t(le,Ga),u(e,Ms,i),u(e,ie,i),t(ie,ve),t(ve,St),q(Oe,St,null),t(ie,Ra),t(ie,Mt),t(Mt,Ba),u(e,Us,i),u(e,z,i),t(z,Va),t(z,Ut),t(Ut,Wa),t(z,Ha),t(z,Nt),t(Nt,Ya),t(z,Ja),t(z,Ft),t(Ft,Xa),t(z,Ka),t(z,It),t(It,Qa),t(z,Za),t(z,Gt),t(Gt,en),t(z,tn),t(z,Rt),t(Rt,sn),t(z,on),u(e,Ns,i),q(ye,e,i),u(e,Fs,i),q(Ae,e,i),u(e,Is,i),u(e,f,i),t(f,an),t(f,Bt),t(Bt,nn),t(f,rn),t(f,Vt),t(Vt,ln),t(f,un),t(f,Wt),t(Wt,dn),t(f,cn),t(f,Ht),t(Ht,pn),t(f,mn),t(f,Yt),t(Yt,fn),t(f,vn),t(f,Jt),t(Jt,hn),t(f,_n),t(f,Xt),t(Xt,En),t(f,qn),t(f,Kt),t(Kt,$n),t(f,bn),t(f,Qt),t(Qt,gn),t(f,Cn),u(e,Gs,i),u(e,U,i),t(U,kn),t(U,Zt),t(Zt,jn),t(U,zn),t(U,es),t(es,Tn),t(U,Pn),t(U,Ye),t(Ye,wn),t(U,xn),t(U,ts),t(ts,Dn),t(U,On),u(e,Rs,i),q(Le,e,i),u(e,Bs,i),u(e,y,i),t(y,yn),t(y,ss),t(ss,An),t(y,Ln),t(y,os),t(os,Sn),t(y,Mn),t(y,Se),t(Se,as),t(as,Un),t(y,Nn),t(y,ns),t(ns,Fn),t(y,In),t(y,rs),t(rs,Gn),t(y,Rn),u(e,Vs,i),q(Me,e,i),u(e,Ws,i),q(Ue,e,i),u(e,Hs,i),u(e,Y,i),t(Y,Bn),t(Y,Ne),t(Ne,Vn),t(Y,Wn),t(Y,ls),t(ls,Hn),t(Y,Yn),t(Y,is),t(is,Jn),t(Y,Xn),u(e,Ys,i),u(e,he,i),t(he,Kn),t(he,us),t(us,Qn),t(he,Zn),u(e,Js,i),q(Fe,e,i),u(e,Xs,i),u(e,oe,i),t(oe,er),t(oe,ds),t(ds,tr),t(oe,sr),t(oe,cs),t(cs,or),t(oe,ar),u(e,Ks,i),q(Ie,e,i),u(e,Qs,i),u(e,J,i),t(J,nr),t(J,ps),t(ps,rr),t(J,lr),t(J,ms),t(ms,ir),t(J,ur),t(J,fs),t(fs,dr),t(J,cr),u(e,Zs,i),q(Ge,e,i),u(e,eo,i),u(e,Je,i),t(Je,pr),u(e,to,i),u(e,ae,i),t(ae,mr),t(ae,vs),t(vs,fr),t(ae,vr),t(ae,hs),t(hs,hr),t(ae,_r),u(e,so,i),u(e,X,i),t(X,Er),t(X,_s),t(_s,qr),t(X,$r),t(X,Es),t(Es,br),t(X,gr),t(X,Xe),t(Xe,Cr),t(X,kr),u(e,oo,i),q(_e,e,i),ao=!0},p(e,[i]){const Re={};i&1&&(Re.fw=e[0]),v.$set(Re);const qs={};i&2&&(qs.$$scope={dirty:i,ctx:e}),ce.$set(qs);const $s={};i&2&&($s.$$scope={dirty:i,ctx:e}),_e.$set($s)},i(e){ao||($(v.$$.fragment,e),$(A.$$.fragment,e),$(B.$$.fragment,e),$(te.$$.fragment,e),$(ze.$$.fragment,e),$(Te.$$.fragment,e),$(Pe.$$.fragment,e),$(ce.$$.fragment,e),$(we.$$.fragment,e),$(xe.$$.fragment,e),$(De.$$.fragment,e),$(Oe.$$.fragment,e),$(ye.$$.fragment,e),$(Ae.$$.fragment,e),$(Le.$$.fragment,e),$(Me.$$.fragment,e),$(Ue.$$.fragment,e),$(Fe.$$.fragment,e),$(Ie.$$.fragment,e),$(Ge.$$.fragment,e),$(_e.$$.fragment,e),ao=!0)},o(e){b(v.$$.fragment,e),b(A.$$.fragment,e),b(B.$$.fragment,e),b(te.$$.fragment,e),b(ze.$$.fragment,e),b(Te.$$.fragment,e),b(Pe.$$.fragment,e),b(ce.$$.fragment,e),b(we.$$.fragment,e),b(xe.$$.fragment,e),b(De.$$.fragment,e),b(Oe.$$.fragment,e),b(ye.$$.fragment,e),b(Ae.$$.fragment,e),b(Le.$$.fragment,e),b(Me.$$.fragment,e),b(Ue.$$.fragment,e),b(Fe.$$.fragment,e),b(Ie.$$.fragment,e),b(Ge.$$.fragment,e),b(_e.$$.fragment,e),ao=!1},d(e){s(p),e&&s(S),g(v,e),e&&s(M),e&&s(T),g(A),e&&s(ue),g(B,e),e&&s(P),g(te,e),e&&s(ke),e&&s(h),e&&s(bs),e&&s(Ve),e&&s(gs),g(ze,e),e&&s(Cs),e&&s(re),g(Te),e&&s(ks),e&&s(x),e&&s(js),g(Pe,e),e&&s(zs),g(ce,e),e&&s(Ts),e&&s(se),e&&s(Ps),g(we,e),e&&s(ws),e&&s(pe),e&&s(xs),e&&s(D),e&&s(Ds),g(xe,e),e&&s(Os),e&&s(O),e&&s(ys),e&&s(H),e&&s(As),g(De,e),e&&s(Ls),e&&s(me),e&&s(Ss),e&&s(fe),e&&s(Ms),e&&s(ie),g(Oe),e&&s(Us),e&&s(z),e&&s(Ns),g(ye,e),e&&s(Fs),g(Ae,e),e&&s(Is),e&&s(f),e&&s(Gs),e&&s(U),e&&s(Rs),g(Le,e),e&&s(Bs),e&&s(y),e&&s(Vs),g(Me,e),e&&s(Ws),g(Ue,e),e&&s(Hs),e&&s(Y),e&&s(Ys),e&&s(he),e&&s(Js),g(Fe,e),e&&s(Xs),e&&s(oe),e&&s(Ks),g(Ie,e),e&&s(Qs),e&&s(J),e&&s(Zs),g(Ge,e),e&&s(eo),e&&s(Je),e&&s(to),e&&s(ae),e&&s(so),e&&s(X),e&&s(oo),g(_e,e)}}}const vi={local:"ifinetuneri-un-modle-avec-lapi-trainer",sections:[{local:"entranement",title:"Entra\xEEnement"},{local:"evaluation",title:"Evaluation"}],title:"<i>Finetuner</i> un mod\xE8le avec l'API Trainer"};function hi(ge,p,S){let v="pt";return ii(()=>{const M=new URLSearchParams(window.location.search);S(0,v=M.get("fw")||"pt")}),[v]}class ki extends ai{constructor(p){super();ni(this,p,hi,fi,ri,{})}}export{ki as default,vi as metadata};
