import{S as Mr,i as Pr,s as Cr,e as u,k as h,w as g,t as r,M as Fr,c as p,d as n,m as _,x as q,a as m,h as o,b as w,G as s,g as d,y as j,o as v,p as ze,q as $,B as E,v as Tr,n as Ae}from"../../chunks/vendor-hf-doc-builder.js";import{T as Ar}from"../../chunks/Tip-hf-doc-builder.js";import{Y as xr}from"../../chunks/Youtube-hf-doc-builder.js";import{I as bn}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as z}from"../../chunks/CodeBlock-hf-doc-builder.js";import{C as Ir}from"../../chunks/CourseFloatingBanner-hf-doc-builder.js";import{F as Sr}from"../../chunks/FrameworkSwitchCourse-hf-doc-builder.js";function Lr(k){let a,c;return a=new Ir({props:{chapter:2,classNames:"absolute z-10 right-0 top-0",notebooks:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter2/section5_tf.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter2/section5_tf.ipynb"}]}}),{c(){g(a.$$.fragment)},l(t){q(a.$$.fragment,t)},m(t,f){j(a,t,f),c=!0},i(t){c||($(a.$$.fragment,t),c=!0)},o(t){v(a.$$.fragment,t),c=!1},d(t){E(a,t)}}}function Nr(k){let a,c;return a=new Ir({props:{chapter:2,classNames:"absolute z-10 right-0 top-0",notebooks:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter2/section5_pt.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter2/section5_pt.ipynb"}]}}),{c(){g(a.$$.fragment)},l(t){q(a.$$.fragment,t)},m(t,f){j(a,t,f),c=!0},i(t){c||($(a.$$.fragment,t),c=!0)},o(t){v(a.$$.fragment,t),c=!1},d(t){E(a,t)}}}function Hr(k){let a,c;return a=new xr({props:{id:"ROxrFOEbsQE"}}),{c(){g(a.$$.fragment)},l(t){q(a.$$.fragment,t)},m(t,f){j(a,t,f),c=!0},i(t){c||($(a.$$.fragment,t),c=!0)},o(t){v(a.$$.fragment,t),c=!1},d(t){E(a,t)}}}function Dr(k){let a,c;return a=new xr({props:{id:"M6adb1j2jPI"}}),{c(){g(a.$$.fragment)},l(t){q(a.$$.fragment,t)},m(t,f){j(a,t,f),c=!0},i(t){c||($(a.$$.fragment,t),c=!0)},o(t){v(a.$$.fragment,t),c=!1},d(t){E(a,t)}}}function Br(k){let a,c,t,f;return a=new z({props:{code:`import tensorflow as tf
from transformers import AutoTokenizer, TFAutoModelForSequenceClassification

checkpoint = "distilbert-base-uncased-finetuned-sst-2-english"
tokenizer = AutoTokenizer.from_pretrained(checkpoint)
model = TFAutoModelForSequenceClassification.from_pretrained(checkpoint)

sequence = "I've been waiting for a HuggingFace course my whole life."
# J'ai attendu un cours d\u2019HuggingFace toute ma vie.

tokens = tokenizer.tokenize(sequence)
ids = tokenizer.convert_tokens_to_ids(tokens)
input_ids = tf.constant(ids)
# This line will fail.
model(input_ids)`,highlighted:`<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, TFAutoModelForSequenceClassification

checkpoint = <span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(checkpoint)
model = TFAutoModelForSequenceClassification.from_pretrained(checkpoint)

sequence = <span class="hljs-string">&quot;I&#x27;ve been waiting for a HuggingFace course my whole life.&quot;</span>
<span class="hljs-comment"># J&#x27;ai attendu un cours d\u2019HuggingFace toute ma vie.</span>

tokens = tokenizer.tokenize(sequence)
ids = tokenizer.convert_tokens_to_ids(tokens)
input_ids = tf.constant(ids)
<span class="hljs-comment"># This line will fail.</span>
model(input_ids)`}}),t=new z({props:{code:"InvalidArgumentError: Input to reshape is a tensor with 14 values, but the requested shape has 196 [Op:Reshape]",highlighted:'InvalidArgumentError: Input to reshape <span class="hljs-keyword">is</span> a tensor <span class="hljs-keyword">with</span> <span class="hljs-number">14</span> values, but the requested shape has <span class="hljs-number">196</span> [Op:Reshape]'}}),{c(){g(a.$$.fragment),c=h(),g(t.$$.fragment)},l(l){q(a.$$.fragment,l),c=_(l),q(t.$$.fragment,l)},m(l,b){j(a,l,b),d(l,c,b),j(t,l,b),f=!0},i(l){f||($(a.$$.fragment,l),$(t.$$.fragment,l),f=!0)},o(l){v(a.$$.fragment,l),v(t.$$.fragment,l),f=!1},d(l){E(a,l),l&&n(c),E(t,l)}}}function Or(k){let a,c,t,f;return a=new z({props:{code:`import torch
from transformers import AutoTokenizer, AutoModelForSequenceClassification

checkpoint = "distilbert-base-uncased-finetuned-sst-2-english"
tokenizer = AutoTokenizer.from_pretrained(checkpoint)
model = AutoModelForSequenceClassification.from_pretrained(checkpoint)

sequence = "I've been waiting for a HuggingFace course my whole life."
# J'ai attendu un cours d\u2019HuggingFace toute ma vie.

tokens = tokenizer.tokenize(sequence)
ids = tokenizer.convert_tokens_to_ids(tokens)
input_ids = torch.tensor(ids)
# Cette ligne va \xE9chouer.
model(input_ids)`,highlighted:`<span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForSequenceClassification

checkpoint = <span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(checkpoint)
model = AutoModelForSequenceClassification.from_pretrained(checkpoint)

sequence = <span class="hljs-string">&quot;I&#x27;ve been waiting for a HuggingFace course my whole life.&quot;</span>
<span class="hljs-comment"># J&#x27;ai attendu un cours d\u2019HuggingFace toute ma vie.</span>

tokens = tokenizer.tokenize(sequence)
ids = tokenizer.convert_tokens_to_ids(tokens)
input_ids = torch.tensor(ids)
<span class="hljs-comment"># Cette ligne va \xE9chouer.</span>
model(input_ids)`}}),t=new z({props:{code:"IndexError: Dimension out of range (expected to be in range of [-1, 0], but got 1)",highlighted:'IndexError: Dimension out of <span class="hljs-built_in">range</span> (expected to be <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> of [-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], but got <span class="hljs-number">1</span>)'}}),{c(){g(a.$$.fragment),c=h(),g(t.$$.fragment)},l(l){q(a.$$.fragment,l),c=_(l),q(t.$$.fragment,l)},m(l,b){j(a,l,b),d(l,c,b),j(t,l,b),f=!0},i(l){f||($(a.$$.fragment,l),$(t.$$.fragment,l),f=!0)},o(l){v(a.$$.fragment,l),v(t.$$.fragment,l),f=!1},d(l){E(a,l),l&&n(c),E(t,l)}}}function Ur(k){let a,c,t,f;return a=new z({props:{code:`tokenized_inputs = tokenizer(sequence, return_tensors="tf")
print(tokenized_inputs["input_ids"])`,highlighted:`tokenized_inputs = tokenizer(sequence, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-built_in">print</span>(tokenized_inputs[<span class="hljs-string">&quot;input_ids&quot;</span>])`}}),t=new z({props:{code:`<tf.Tensor: shape=(1, 16), dtype=int32, numpy=
array([[  101,  1045,  1005,  2310,  2042,  3403,  2005,  1037, 17662,
        12172,  2607,  2026,  2878,  2166,  1012,   102]], dtype=int32)>`,highlighted:`&lt;tf.Tensor: shape=(<span class="hljs-number">1</span>, <span class="hljs-number">16</span>), dtype=int32, numpy=
array([[  <span class="hljs-number">101</span>,  <span class="hljs-number">1045</span>,  <span class="hljs-number">1005</span>,  <span class="hljs-number">2310</span>,  <span class="hljs-number">2042</span>,  <span class="hljs-number">3403</span>,  <span class="hljs-number">2005</span>,  <span class="hljs-number">1037</span>, <span class="hljs-number">17662</span>,
        <span class="hljs-number">12172</span>,  <span class="hljs-number">2607</span>,  <span class="hljs-number">2026</span>,  <span class="hljs-number">2878</span>,  <span class="hljs-number">2166</span>,  <span class="hljs-number">1012</span>,   <span class="hljs-number">102</span>]], dtype=int32)&gt;`}}),{c(){g(a.$$.fragment),c=h(),g(t.$$.fragment)},l(l){q(a.$$.fragment,l),c=_(l),q(t.$$.fragment,l)},m(l,b){j(a,l,b),d(l,c,b),j(t,l,b),f=!0},i(l){f||($(a.$$.fragment,l),$(t.$$.fragment,l),f=!0)},o(l){v(a.$$.fragment,l),v(t.$$.fragment,l),f=!1},d(l){E(a,l),l&&n(c),E(t,l)}}}function Vr(k){let a,c,t,f;return a=new z({props:{code:`tokenized_inputs = tokenizer(sequence, return_tensors="pt")
print(tokenized_inputs["input_ids"])`,highlighted:`tokenized_inputs = tokenizer(sequence, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-built_in">print</span>(tokenized_inputs[<span class="hljs-string">&quot;input_ids&quot;</span>])`}}),t=new z({props:{code:`tensor([[  101,  1045,  1005,  2310,  2042,  3403,  2005,  1037, 17662, 12172,
          2607,  2026,  2878,  2166,  1012,   102]])`,highlighted:`tensor([[  <span class="hljs-number">101</span>,  <span class="hljs-number">1045</span>,  <span class="hljs-number">1005</span>,  <span class="hljs-number">2310</span>,  <span class="hljs-number">2042</span>,  <span class="hljs-number">3403</span>,  <span class="hljs-number">2005</span>,  <span class="hljs-number">1037</span>, <span class="hljs-number">17662</span>, <span class="hljs-number">12172</span>,
          <span class="hljs-number">2607</span>,  <span class="hljs-number">2026</span>,  <span class="hljs-number">2878</span>,  <span class="hljs-number">2166</span>,  <span class="hljs-number">1012</span>,   <span class="hljs-number">102</span>]])`}}),{c(){g(a.$$.fragment),c=h(),g(t.$$.fragment)},l(l){q(a.$$.fragment,l),c=_(l),q(t.$$.fragment,l)},m(l,b){j(a,l,b),d(l,c,b),j(t,l,b),f=!0},i(l){f||($(a.$$.fragment,l),$(t.$$.fragment,l),f=!0)},o(l){v(a.$$.fragment,l),v(t.$$.fragment,l),f=!1},d(l){E(a,l),l&&n(c),E(t,l)}}}function Jr(k){let a,c;return a=new z({props:{code:`import tensorflow as tf
from transformers import AutoTokenizer, TFAutoModelForSequenceClassification

checkpoint = "distilbert-base-uncased-finetuned-sst-2-english"
tokenizer = AutoTokenizer.from_pretrained(checkpoint)
model = TFAutoModelForSequenceClassification.from_pretrained(checkpoint)

sequence = "I've been waiting for a HuggingFace course my whole life."
# J'ai attendu un cours d\u2019HuggingFace toute ma vie.


tokens = tokenizer.tokenize(sequence)
ids = tokenizer.convert_tokens_to_ids(tokens)

input_ids = tf.constant([ids])
print("Input IDs:", input_ids)

output = model(input_ids)
print("Logits:", output.logits)`,highlighted:`<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, TFAutoModelForSequenceClassification

checkpoint = <span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(checkpoint)
model = TFAutoModelForSequenceClassification.from_pretrained(checkpoint)

sequence = <span class="hljs-string">&quot;I&#x27;ve been waiting for a HuggingFace course my whole life.&quot;</span>
<span class="hljs-comment"># J&#x27;ai attendu un cours d\u2019HuggingFace toute ma vie.</span>


tokens = tokenizer.tokenize(sequence)
ids = tokenizer.convert_tokens_to_ids(tokens)

input_ids = tf.constant([ids])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Input IDs:&quot;</span>, input_ids)

output = model(input_ids)
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Logits:&quot;</span>, output.logits)`}}),{c(){g(a.$$.fragment)},l(t){q(a.$$.fragment,t)},m(t,f){j(a,t,f),c=!0},i(t){c||($(a.$$.fragment,t),c=!0)},o(t){v(a.$$.fragment,t),c=!1},d(t){E(a,t)}}}function Rr(k){let a,c;return a=new z({props:{code:`import torch
from transformers import AutoTokenizer, AutoModelForSequenceClassification

checkpoint = "distilbert-base-uncased-finetuned-sst-2-english"
tokenizer = AutoTokenizer.from_pretrained(checkpoint)
model = AutoModelForSequenceClassification.from_pretrained(checkpoint)

sequence = "I've been waiting for a HuggingFace course my whole life."
# J'ai attendu un cours d\u2019HuggingFace toute ma vie.


tokens = tokenizer.tokenize(sequence)
ids = tokenizer.convert_tokens_to_ids(tokens)

input_ids = torch.tensor([ids])
print("Input IDs:", input_ids)

output = model(input_ids)
print("Logits:", output.logits)`,highlighted:`<span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForSequenceClassification

checkpoint = <span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(checkpoint)
model = AutoModelForSequenceClassification.from_pretrained(checkpoint)

sequence = <span class="hljs-string">&quot;I&#x27;ve been waiting for a HuggingFace course my whole life.&quot;</span>
<span class="hljs-comment"># J&#x27;ai attendu un cours d\u2019HuggingFace toute ma vie.</span>


tokens = tokenizer.tokenize(sequence)
ids = tokenizer.convert_tokens_to_ids(tokens)

input_ids = torch.tensor([ids])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Input IDs:&quot;</span>, input_ids)

output = model(input_ids)
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Logits:&quot;</span>, output.logits)`}}),{c(){g(a.$$.fragment)},l(t){q(a.$$.fragment,t)},m(t,f){j(a,t,f),c=!0},i(t){c||($(a.$$.fragment,t),c=!0)},o(t){v(a.$$.fragment,t),c=!1},d(t){E(a,t)}}}function Gr(k){let a,c;return a=new z({props:{code:`Input IDs: tf.Tensor(
[[ 1045  1005  2310  2042  3403  2005  1037 17662 12172  2607  2026  2878
   2166  1012]], shape=(1, 14), dtype=int32)
Logits: tf.Tensor([[-2.7276208  2.8789377]], shape=(1, 2), dtype=float32)`,highlighted:`Input IDs: tf.Tensor(
[[ <span class="hljs-number">1045</span>  <span class="hljs-number">1005</span>  <span class="hljs-number">2310</span>  <span class="hljs-number">2042</span>  <span class="hljs-number">3403</span>  <span class="hljs-number">2005</span>  <span class="hljs-number">1037</span> <span class="hljs-number">17662</span> <span class="hljs-number">12172</span>  <span class="hljs-number">2607</span>  <span class="hljs-number">2026</span>  <span class="hljs-number">2878</span>
   <span class="hljs-number">2166</span>  <span class="hljs-number">1012</span>]], shape=(<span class="hljs-number">1</span>, <span class="hljs-number">14</span>), dtype=int32)
Logits: tf.Tensor([[-<span class="hljs-number">2.7276208</span>  <span class="hljs-number">2.8789377</span>]], shape=(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), dtype=float32)`}}),{c(){g(a.$$.fragment)},l(t){q(a.$$.fragment,t)},m(t,f){j(a,t,f),c=!0},i(t){c||($(a.$$.fragment,t),c=!0)},o(t){v(a.$$.fragment,t),c=!1},d(t){E(a,t)}}}function Yr(k){let a,c;return a=new z({props:{code:`Input IDs: [[ 1045,  1005,  2310,  2042,  3403,  2005,  1037, 17662, 12172,  2607, 2026,  2878,  2166,  1012]]
Logits: [[-2.7276,  2.8789]]`,highlighted:`Input IDs: [[ <span class="hljs-number">1045</span>,  <span class="hljs-number">1005</span>,  <span class="hljs-number">2310</span>,  <span class="hljs-number">2042</span>,  <span class="hljs-number">3403</span>,  <span class="hljs-number">2005</span>,  <span class="hljs-number">1037</span>, <span class="hljs-number">17662</span>, <span class="hljs-number">12172</span>,  <span class="hljs-number">2607</span>, <span class="hljs-number">2026</span>,  <span class="hljs-number">2878</span>,  <span class="hljs-number">2166</span>,  <span class="hljs-number">1012</span>]]
Logits: [[-<span class="hljs-number">2.7276</span>,  <span class="hljs-number">2.8789</span>]]`}}),{c(){g(a.$$.fragment)},l(t){q(a.$$.fragment,t)},m(t,f){j(a,t,f),c=!0},i(t){c||($(a.$$.fragment,t),c=!0)},o(t){v(a.$$.fragment,t),c=!1},d(t){E(a,t)}}}function Qr(k){let a,c,t,f,l,b,N,M;return{c(){a=u("p"),c=r("\u270F\uFE0F "),t=u("strong"),f=r("Essayez !"),l=r(" Convertissez cette liste "),b=u("code"),N=r("batched_ids"),M=r(" en un tenseur et passez-la dans votre mod\xE8le. V\xE9rifiez que vous obtenez les m\xEAmes logits que pr\xE9c\xE9demment (mais deux fois) !")},l(P){a=p(P,"P",{});var x=m(a);c=o(x,"\u270F\uFE0F "),t=p(x,"STRONG",{});var ne=m(t);f=o(ne,"Essayez !"),ne.forEach(n),l=o(x," Convertissez cette liste "),b=p(x,"CODE",{});var H=m(b);N=o(H,"batched_ids"),H.forEach(n),M=o(x," en un tenseur et passez-la dans votre mod\xE8le. V\xE9rifiez que vous obtenez les m\xEAmes logits que pr\xE9c\xE9demment (mais deux fois) !"),x.forEach(n)},m(P,x){d(P,a,x),s(a,c),s(a,t),s(t,f),s(a,l),s(a,b),s(b,N),s(a,M)},d(P){P&&n(a)}}}function Kr(k){let a,c,t,f;return a=new z({props:{code:`model = TFAutoModelForSequenceClassification.from_pretrained(checkpoint)

sequence1_ids = [[200, 200, 200]]
sequence2_ids = [[200, 200]]
batched_ids = [
    [200, 200, 200],
    [200, 200, tokenizer.pad_token_id],
]

print(model(tf.constant(sequence1_ids)).logits)
print(model(tf.constant(sequence2_ids)).logits)
print(model(tf.constant(batched_ids)).logits)`,highlighted:`model = TFAutoModelForSequenceClassification.from_pretrained(checkpoint)

sequence1_ids = [[<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>]]
sequence2_ids = [[<span class="hljs-number">200</span>, <span class="hljs-number">200</span>]]
batched_ids = [
    [<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>],
    [<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, tokenizer.pad_token_id],
]

<span class="hljs-built_in">print</span>(model(tf.constant(sequence1_ids)).logits)
<span class="hljs-built_in">print</span>(model(tf.constant(sequence2_ids)).logits)
<span class="hljs-built_in">print</span>(model(tf.constant(batched_ids)).logits)`}}),t=new z({props:{code:`tf.Tensor([[ 1.5693678 -1.3894581]], shape=(1, 2), dtype=float32)
tf.Tensor([[ 0.5803005  -0.41252428]], shape=(1, 2), dtype=float32)
tf.Tensor(
[[ 1.5693681 -1.3894582]
 [ 1.3373486 -1.2163193]], shape=(2, 2), dtype=float32)`,highlighted:`tf.Tensor([[ <span class="hljs-number">1.5693678</span> -<span class="hljs-number">1.3894581</span>]], shape=(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), dtype=float32)
tf.Tensor([[ <span class="hljs-number">0.5803005</span>  -<span class="hljs-number">0.41252428</span>]], shape=(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), dtype=float32)
tf.Tensor(
[[ <span class="hljs-number">1.5693681</span> -<span class="hljs-number">1.3894582</span>]
 [ <span class="hljs-number">1.3373486</span> -<span class="hljs-number">1.2163193</span>]], shape=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), dtype=float32)`}}),{c(){g(a.$$.fragment),c=h(),g(t.$$.fragment)},l(l){q(a.$$.fragment,l),c=_(l),q(t.$$.fragment,l)},m(l,b){j(a,l,b),d(l,c,b),j(t,l,b),f=!0},i(l){f||($(a.$$.fragment,l),$(t.$$.fragment,l),f=!0)},o(l){v(a.$$.fragment,l),v(t.$$.fragment,l),f=!1},d(l){E(a,l),l&&n(c),E(t,l)}}}function Wr(k){let a,c,t,f;return a=new z({props:{code:`model = AutoModelForSequenceClassification.from_pretrained(checkpoint)

sequence1_ids = [[200, 200, 200]]
sequence2_ids = [[200, 200]]
batched_ids = [
    [200, 200, 200],
    [200, 200, tokenizer.pad_token_id],
]

print(model(torch.tensor(sequence1_ids)).logits)
print(model(torch.tensor(sequence2_ids)).logits)
print(model(torch.tensor(batched_ids)).logits)`,highlighted:`model = AutoModelForSequenceClassification.from_pretrained(checkpoint)

sequence1_ids = [[<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>]]
sequence2_ids = [[<span class="hljs-number">200</span>, <span class="hljs-number">200</span>]]
batched_ids = [
    [<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>],
    [<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, tokenizer.pad_token_id],
]

<span class="hljs-built_in">print</span>(model(torch.tensor(sequence1_ids)).logits)
<span class="hljs-built_in">print</span>(model(torch.tensor(sequence2_ids)).logits)
<span class="hljs-built_in">print</span>(model(torch.tensor(batched_ids)).logits)`}}),t=new z({props:{code:`tensor([[ 1.5694, -1.3895]], grad_fn=<AddmmBackward>)
tensor([[ 0.5803, -0.4125]], grad_fn=<AddmmBackward>)
tensor([[ 1.5694, -1.3895],
        [ 1.3373, -1.2163]], grad_fn=<AddmmBackward>)`,highlighted:`tensor([[ <span class="hljs-number">1.5694</span>, -<span class="hljs-number">1.3895</span>]], grad_fn=&lt;AddmmBackward&gt;)
tensor([[ <span class="hljs-number">0.5803</span>, -<span class="hljs-number">0.4125</span>]], grad_fn=&lt;AddmmBackward&gt;)
tensor([[ <span class="hljs-number">1.5694</span>, -<span class="hljs-number">1.3895</span>],
        [ <span class="hljs-number">1.3373</span>, -<span class="hljs-number">1.2163</span>]], grad_fn=&lt;AddmmBackward&gt;)`}}),{c(){g(a.$$.fragment),c=h(),g(t.$$.fragment)},l(l){q(a.$$.fragment,l),c=_(l),q(t.$$.fragment,l)},m(l,b){j(a,l,b),d(l,c,b),j(t,l,b),f=!0},i(l){f||($(a.$$.fragment,l),$(t.$$.fragment,l),f=!0)},o(l){v(a.$$.fragment,l),v(t.$$.fragment,l),f=!1},d(l){E(a,l),l&&n(c),E(t,l)}}}function Xr(k){let a,c,t,f;return a=new z({props:{code:`batched_ids = [
    [200, 200, 200],
    [200, 200, tokenizer.pad_token_id],
]

attention_mask = [
    [1, 1, 1],
    [1, 1, 0],
]

outputs = model(tf.constant(batched_ids), attention_mask=tf.constant(attention_mask))
print(outputs.logits)`,highlighted:`batched_ids = [
    [<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>],
    [<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, tokenizer.pad_token_id],
]

attention_mask = [
    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],
]

outputs = model(tf.constant(batched_ids), attention_mask=tf.constant(attention_mask))
<span class="hljs-built_in">print</span>(outputs.logits)`}}),t=new z({props:{code:`tf.Tensor(
[[ 1.5693681  -1.3894582 ]
 [ 0.5803021  -0.41252586]], shape=(2, 2), dtype=float32)`,highlighted:`tf.Tensor(
[[ <span class="hljs-number">1.5693681</span>  -<span class="hljs-number">1.3894582</span> ]
 [ <span class="hljs-number">0.5803021</span>  -<span class="hljs-number">0.41252586</span>]], shape=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), dtype=float32)`}}),{c(){g(a.$$.fragment),c=h(),g(t.$$.fragment)},l(l){q(a.$$.fragment,l),c=_(l),q(t.$$.fragment,l)},m(l,b){j(a,l,b),d(l,c,b),j(t,l,b),f=!0},i(l){f||($(a.$$.fragment,l),$(t.$$.fragment,l),f=!0)},o(l){v(a.$$.fragment,l),v(t.$$.fragment,l),f=!1},d(l){E(a,l),l&&n(c),E(t,l)}}}function Zr(k){let a,c,t,f;return a=new z({props:{code:`batched_ids = [
    [200, 200, 200],
    [200, 200, tokenizer.pad_token_id],
]

attention_mask = [
    [1, 1, 1],
    [1, 1, 0],
]

outputs = model(torch.tensor(batched_ids), attention_mask=torch.tensor(attention_mask))
print(outputs.logits)`,highlighted:`batched_ids = [
    [<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>],
    [<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, tokenizer.pad_token_id],
]

attention_mask = [
    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],
]

outputs = model(torch.tensor(batched_ids), attention_mask=torch.tensor(attention_mask))
<span class="hljs-built_in">print</span>(outputs.logits)`}}),t=new z({props:{code:`tensor([[ 1.5694, -1.3895],
        [ 0.5803, -0.4125]], grad_fn=<AddmmBackward>)`,highlighted:`tensor([[ <span class="hljs-number">1.5694</span>, -<span class="hljs-number">1.3895</span>],
        [ <span class="hljs-number">0.5803</span>, -<span class="hljs-number">0.4125</span>]], grad_fn=&lt;AddmmBackward&gt;)`}}),{c(){g(a.$$.fragment),c=h(),g(t.$$.fragment)},l(l){q(a.$$.fragment,l),c=_(l),q(t.$$.fragment,l)},m(l,b){j(a,l,b),d(l,c,b),j(t,l,b),f=!0},i(l){f||($(a.$$.fragment,l),$(t.$$.fragment,l),f=!0)},o(l){v(a.$$.fragment,l),v(t.$$.fragment,l),f=!1},d(l){E(a,l),l&&n(c),E(t,l)}}}function eo(k){let a,c,t,f,l,b,N,M,P,x,ne,H,C,F;return{c(){a=u("p"),c=r("\u270F\uFE0F "),t=u("strong"),f=r("Essayez !"),l=r(" Appliquez la tokenisation manuellement sur les deux phrases utilis\xE9es dans la section 2 (\xAB "),b=u("i"),N=r("I\u2019ve been waiting for a HuggingFace course my whole life."),M=r(" \xBB et \xAB "),P=u("i"),x=r("I hate this so much!"),ne=r(" \xBB). Passez-les dans le mod\xE8le et v\xE9rifiez que vous obtenez les m\xEAmes logits que dans la section 2. Ensuite regroupez-les en utilisant le jeton de "),H=u("em"),C=r("padding"),F=r(" et cr\xE9ez le masque d\u2019attention appropri\xE9. V\xE9rifiez que vous obtenez les m\xEAmes r\xE9sultats qu\u2019en passant par le mod\xE8le !")},l(D){a=p(D,"P",{});var y=m(a);c=o(y,"\u270F\uFE0F "),t=p(y,"STRONG",{});var T=m(t);f=o(T,"Essayez !"),T.forEach(n),l=o(y," Appliquez la tokenisation manuellement sur les deux phrases utilis\xE9es dans la section 2 (\xAB "),b=p(y,"I",{});var ie=m(b);N=o(ie,"I\u2019ve been waiting for a HuggingFace course my whole life."),ie.forEach(n),M=o(y," \xBB et \xAB "),P=p(y,"I",{});var ue=m(P);x=o(ue,"I hate this so much!"),ue.forEach(n),ne=o(y," \xBB). Passez-les dans le mod\xE8le et v\xE9rifiez que vous obtenez les m\xEAmes logits que dans la section 2. Ensuite regroupez-les en utilisant le jeton de "),H=p(y,"EM",{});var Xe=m(H);C=o(Xe,"padding"),Xe.forEach(n),F=o(y," et cr\xE9ez le masque d\u2019attention appropri\xE9. V\xE9rifiez que vous obtenez les m\xEAmes r\xE9sultats qu\u2019en passant par le mod\xE8le !"),y.forEach(n)},m(D,y){d(D,a,y),s(a,c),s(a,t),s(t,f),s(a,l),s(a,b),s(b,N),s(a,M),s(a,P),s(P,x),s(a,ne),s(a,H),s(H,C),s(a,F)},d(D){D&&n(a)}}}function so(k){let a,c,t,f,l,b,N,M,P,x,ne,H,C,F,D,y,T,ie,ue,Xe,vn,B,ys,ct,mt,xe,dt,zs,ft,ht,_t,As,bt,vt,xs,$t,$n,fe,kt,Is,gt,qt,kn,pe,he,Ms,Ie,jt,Ps,Et,gn,Ze,wt,qn,V,J,es,ss,yt,jn,O,zt,Cs,At,xt,Fs,It,Mt,Ts,Pt,Ct,En,R,G,ns,ts,Ft,wn,Y,Q,as,ls,Tt,yn,K,W,rs,_e,St,Ss,Lt,Nt,zn,Me,An,os,Ht,xn,be,In,S,Dt,Ls,Bt,Ot,Ns,Ut,Vt,Hs,Jt,Rt,Ds,Gt,Yt,Mn,ce,ve,Bs,Pe,Qt,is,Os,Kt,Wt,Pn,us,Xt,Cn,Ce,Fn,L,Zt,Us,ea,sa,Vs,na,ta,Js,aa,la,Rs,ra,oa,Tn,Fe,Sn,te,ia,Gs,ua,pa,Ys,ca,ma,Ln,X,Z,ps,cs,da,Nn,A,fa,Qs,ha,_a,Ks,ba,va,Ws,$a,ka,Xs,ga,qa,Zs,ja,Ea,en,wa,ya,sn,za,Aa,nn,xa,Ia,Hn,me,$e,tn,Te,Ma,an,Pa,Dn,ms,Ca,Bn,ke,Se,Fa,ln,Ta,Sa,La,Le,Na,rn,Ha,Da,On,ds,Ba,Un,ee,se,fs,hs,Oa,Vn,ge,Ua,on,Va,Ja,Jn,qe,Rn,de,je,un,Ne,Ra,pn,Ga,Gn,ae,Ya,cn,Qa,Ka,mn,Wa,Xa,Yn,Ee,dn,Za,el,fn,sl,Qn,le,nl,He,tl,al,De,ll,rl,Kn,we,ol,hn,il,ul,Wn,Be,Xn;t=new Sr({props:{fw:k[0]}}),M=new bn({});const cl=[Nr,Lr],Oe=[];function ml(e,i){return e[0]==="pt"?0:1}C=ml(k),F=Oe[C]=cl[C](k);const dl=[Dr,Hr],Ue=[];function fl(e,i){return e[0]==="pt"?0:1}y=fl(k),T=Ue[y]=dl[y](k),Ie=new bn({});const hl=[Or,Br],Ve=[];function _l(e,i){return e[0]==="pt"?0:1}V=_l(k),J=Ve[V]=hl[V](k);const bl=[Vr,Ur],Je=[];function vl(e,i){return e[0]==="pt"?0:1}R=vl(k),G=Je[R]=bl[R](k);const $l=[Rr,Jr],Re=[];function kl(e,i){return e[0]==="pt"?0:1}Y=kl(k),Q=Re[Y]=$l[Y](k);const gl=[Yr,Gr],Ge=[];function ql(e,i){return e[0]==="pt"?0:1}K=ql(k),W=Ge[K]=gl[K](k),Me=new z({props:{code:"batched_ids = [ids, ids]",highlighted:'<span class="hljs-attr">batched_ids</span> = [ids, ids]'}}),be=new Ar({props:{$$slots:{default:[Qr]},$$scope:{ctx:k}}}),Pe=new bn({}),Ce=new z({props:{code:`batched_ids = [
    [200, 200, 200],
    [200, 200]
]`,highlighted:`batched_ids = [
    [<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>],
    [<span class="hljs-number">200</span>, <span class="hljs-number">200</span>]
]`}}),Fe=new z({props:{code:`padding_id = 100

batched_ids = [
    [200, 200, 200],
    [200, 200, padding_id],
]`,highlighted:`padding_id = <span class="hljs-number">100</span>

batched_ids = [
    [<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>],
    [<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, padding_id],
]`}});const jl=[Wr,Kr],Ye=[];function El(e,i){return e[0]==="pt"?0:1}X=El(k),Z=Ye[X]=jl[X](k),Te=new bn({});const wl=[Zr,Xr],Qe=[];function yl(e,i){return e[0]==="pt"?0:1}return ee=yl(k),se=Qe[ee]=wl[ee](k),qe=new Ar({props:{$$slots:{default:[eo]},$$scope:{ctx:k}}}),Ne=new bn({}),Be=new z({props:{code:"sequence = sequence[:max_sequence_length]",highlighted:"sequence = sequence[:max_sequence_length]"}}),{c(){a=u("meta"),c=h(),g(t.$$.fragment),f=h(),l=u("h1"),b=u("a"),N=u("span"),g(M.$$.fragment),P=h(),x=u("span"),ne=r("Manipulation de plusieurs s\xE9quences"),H=h(),F.c(),D=h(),T.c(),ie=h(),ue=u("p"),Xe=r("Dans la section pr\xE9c\xE9dente, nous avons explor\xE9 le cas d\u2019utilisation le plus simple : faire une inf\xE9rence sur une seule s\xE9quence de petite longueur. Cependant, certaines questions \xE9mergent d\xE9j\xE0 :"),vn=h(),B=u("ul"),ys=u("li"),ct=r("comment g\xE9rer de plusieurs s\xE9quences ?"),mt=h(),xe=u("li"),dt=r("comment g\xE9rer de plusieurs s\xE9quences "),zs=u("em"),ft=r("de longueurs diff\xE9rentes"),ht=r(" ?"),_t=h(),As=u("li"),bt=r("les indices du vocabulaire sont-ils les seules entr\xE9es qui permettent \xE0 un mod\xE8le de bien fonctionner ?"),vt=h(),xs=u("li"),$t=r("existe-t-il une s\xE9quence trop longue ?"),$n=h(),fe=u("p"),kt=r("Voyons quels types de probl\xE8mes ces questions posent et comment nous pouvons les r\xE9soudre en utilisant l\u2019API \u{1F917} "),Is=u("em"),gt=r("Transformers"),qt=r("."),kn=h(),pe=u("h2"),he=u("a"),Ms=u("span"),g(Ie.$$.fragment),jt=h(),Ps=u("span"),Et=r("Les mod\xE8les attendent un batch d'entr\xE9es"),gn=h(),Ze=u("p"),wt=r(`Dans l\u2019exercice pr\xE9c\xE9dent, vous avez vu comment les s\xE9quences sont traduites en listes de nombres.
Convertissons cette liste de nombres en un tenseur et envoyons-le au mod\xE8le :`),qn=h(),J.c(),es=h(),ss=u("p"),yt=r("Pourquoi cela a \xE9chou\xE9 ? Nous avons suivi les \xE9tapes du pipeline de la section 2."),jn=h(),O=u("p"),zt=r("Le probl\xE8me est que nous avons envoy\xE9 une seule s\xE9quence au mod\xE8le, alors que les mod\xE8les de l\u2019API \u{1F917} "),Cs=u("em"),At=r("Transformers"),xt=r(" attendent plusieurs phrases par d\xE9faut. Ici, nous avons essay\xE9 de faire ce que le "),Fs=u("em"),It=r("tokenizer"),Mt=r(" fait en coulisses lorsque nous l\u2019avons appliqu\xE9 \xE0 une "),Ts=u("code"),Pt=r("s\xE9quence"),Ct=r(". Cependant si vous regardez de pr\xE8s, vous verrez qu\u2019il n\u2019a pas seulement converti la liste des identifiants d\u2019entr\xE9e en un tenseur mais aussi ajout\xE9 une dimension par-dessus :"),En=h(),G.c(),ns=h(),ts=u("p"),Ft=r("Essayons \xE0 nouveau en ajoutant une nouvelle dimension :"),wn=h(),Q.c(),as=h(),ls=u("p"),Tt=r("Nous affichons les identifiants d\u2019entr\xE9e ainsi que les logits r\xE9sultants. Voici la sortie :"),yn=h(),W.c(),rs=h(),_e=u("p"),St=r("Le \xAB "),Ss=u("em"),Lt=r("batching"),Nt=r(" \xBB est l\u2019acte d\u2019envoyer plusieurs phrases \xE0 travers le mod\xE8le, toutes en m\xEAme temps. Si vous n\u2019avez qu\u2019une seule phrase, vous pouvez simplement construire un batch avec une seule s\xE9quence :"),zn=h(),g(Me.$$.fragment),An=h(),os=u("p"),Ht=r("Il s\u2019agit d\u2019un batch de deux s\xE9quences identiques !"),xn=h(),g(be.$$.fragment),In=h(),S=u("p"),Dt=r("Utiliser des "),Ls=u("em"),Bt=r("batchs"),Ot=r(" permet au mod\xE8le de fonctionner lorsque vous lui donnez plusieurs s\xE9quences. Utiliser plusieurs s\xE9quences est aussi simple que de construire un batch avec une seule s\xE9quence. Il y a cependant un deuxi\xE8me probl\xE8me. Lorsque vous essayez de regrouper deux phrases (ou plus), elles peuvent \xEAtre de longueurs diff\xE9rentes. Si vous avez d\xE9j\xE0 travaill\xE9 avec des tenseurs, vous savez qu\u2019ils doivent \xEAtre de forme rectangulaire. Vous ne pourrez donc pas convertir directement la liste des identifiants d\u2019entr\xE9e en un tenseur. Pour contourner ce probl\xE8me, nous avons l\u2019habitude de "),Ns=u("em"),Ut=r("rembourrer"),Vt=r("/"),Hs=u("em"),Jt=r("remplir"),Rt=r(" (le "),Ds=u("em"),Gt=r("padding"),Yt=r(" en anglais) les entr\xE9es."),Mn=h(),ce=u("h2"),ve=u("a"),Bs=u("span"),g(Pe.$$.fragment),Qt=h(),is=u("span"),Os=u("i"),Kt=r("Padding"),Wt=r(" des entr\xE9es"),Pn=h(),us=u("p"),Xt=r("La liste de listes suivante ne peut pas \xEAtre convertie en un tenseur :"),Cn=h(),g(Ce.$$.fragment),Fn=h(),L=u("p"),Zt=r("Afin de contourner ce probl\xE8me, nous utilisons le "),Us=u("em"),ea=r("padding"),sa=r(" pour que nos tenseurs aient une forme rectangulaire. Le "),Vs=u("em"),na=r("padding"),ta=r(" permet de s\u2019assurer que toutes nos phrases ont la m\xEAme longueur en ajoutant un mot sp\xE9cial appel\xE9 "),Js=u("em"),aa=r("padding token"),la=r(" aux phrases ayant moins de valeurs. Par exemple, si vous avez 10 phrases de 10 mots et 1 phrase de 20 mots, le "),Rs=u("em"),ra=r("padding"),oa=r(" fait en sorte que toutes les phrases aient 20 mots. Dans notre exemple, le tenseur r\xE9sultant ressemble \xE0 ceci :"),Tn=h(),g(Fe.$$.fragment),Sn=h(),te=u("p"),ia=r("L\u2019identifiant du jeton de "),Gs=u("em"),ua=r("padding"),pa=r(" peut \xEAtre trouv\xE9 dans "),Ys=u("code"),ca=r("tokenizer.pad_token_id"),ma=r(". Utilisons-le et envoyons nos deux phrases \xE0 travers le mod\xE8le premi\xE8rement individuellement puis en \xE9tant mises dans un m\xEAme batch :"),Ln=h(),Z.c(),ps=h(),cs=u("p"),da=r("Il y a quelque chose qui ne va pas avec les logits de notre pr\xE9diction avec les s\xE9quences mises dans un m\xEAme batch. La deuxi\xE8me ligne devrait \xEAtre la m\xEAme que les logits pour la deuxi\xE8me phrase, mais nous avons des valeurs compl\xE8tement diff\xE9rentes !"),Nn=h(),A=u("p"),fa=r("C\u2019est parce que dans un "),Qs=u("em"),ha=r("transformer"),_a=r(" les couches d\u2019attention "),Ks=u("em"),ba=r("contextualisent"),va=r(" chaque "),Ws=u("em"),$a=r("token"),ka=r(". Celles-ci prennent en compte les "),Xs=u("em"),ga=r("tokens"),qa=r(" de "),Zs=u("em"),ja=r("padding"),Ea=r(" puisqu\u2019elles analysent tous les "),en=u("em"),wa=r("tokens"),ya=r(" d\u2019une s\xE9quence. Pour obtenir le m\xEAme r\xE9sultat lorsque l\u2019on passe dans notre mod\xE8le des phrases individuelles de diff\xE9rentes longueurs ou un batch compos\xE9 de m\xEAmes phrases avec "),sn=u("em"),za=r("padding"),Aa=r(", nous devons dire \xE0 ces couches d\u2019attention d\u2019ignorer les jetons de "),nn=u("em"),xa=r("padding"),Ia=r(". Ceci est fait en utilisant un masque d\u2019attention."),Hn=h(),me=u("h2"),$e=u("a"),tn=u("span"),g(Te.$$.fragment),Ma=h(),an=u("span"),Pa=r("Masques d'attention"),Dn=h(),ms=u("p"),Ca=r("Les masques d\u2019attention sont des tenseurs ayant exactement la m\xEAme forme que le tenseur d\u2019identifiants d\u2019entr\xE9e, remplis de 0 et de 1 :"),Bn=h(),ke=u("ul"),Se=u("li"),Fa=r("1 indique que les "),ln=u("em"),Ta=r("tokens"),Sa=r(" correspondants doivent \xEAtre analys\xE9s"),La=h(),Le=u("li"),Na=r("0 indique que les "),rn=u("em"),Ha=r("tokens"),Da=r(" correspondants ne doivent pas \xEAtre analys\xE9s (c\u2019est-\xE0-dire qu\u2019ils doivent \xEAtre ignor\xE9s par les couches d\u2019attention du mod\xE8le)."),On=h(),ds=u("p"),Ba=r("Compl\xE9tons l\u2019exemple pr\xE9c\xE9dent avec un masque d\u2019attention :"),Un=h(),se.c(),fs=h(),hs=u("p"),Oa=r("Nous obtenons maintenant les m\xEAmes logits pour la deuxi\xE8me phrase du batch."),Vn=h(),ge=u("p"),Ua=r("Remarquez comment la derni\xE8re valeur de la deuxi\xE8me s\xE9quence est un identifiant de "),on=u("em"),Va=r("padding"),Ja=r(" valant 0 dans le masque d\u2019attention."),Jn=h(),g(qe.$$.fragment),Rn=h(),de=u("h2"),je=u("a"),un=u("span"),g(Ne.$$.fragment),Ra=h(),pn=u("span"),Ga=r("S\xE9quences plus longues"),Gn=h(),ae=u("p"),Ya=r("Les "),cn=u("em"),Qa=r("transformers"),Ka=r(" acceptent en entr\xE9e que des s\xE9quences d\u2019une longueur limit\xE9e. La plupart des mod\xE8les traitent des s\xE9quences allant jusqu\u2019\xE0 512 ou 1024 "),mn=u("em"),Wa=r("tokens"),Xa=r(" et plantent lorsqu\u2019on leur demande de traiter des s\xE9quences plus longues. Il existe deux solutions \xE0 ce probl\xE8me :"),Yn=h(),Ee=u("ul"),dn=u("li"),Za=r("utiliser un mod\xE8le avec une longueur de s\xE9quence support\xE9e plus longue,"),el=h(),fn=u("li"),sl=r("tronquer les s\xE9quences."),Qn=h(),le=u("p"),nl=r("Certains mod\xE8les sont sp\xE9cialis\xE9s dans le traitement de tr\xE8s longues s\xE9quences comme par exemple le "),He=u("a"),tl=r("Longformer"),al=r(" ou le "),De=u("a"),ll=r("LED"),rl=r(". Si vous travaillez sur une t\xE2che qui n\xE9cessite de tr\xE8s longues s\xE9quences, nous vous recommandons de jeter un coup d\u2019\u0153il \xE0 ces mod\xE8les."),Kn=h(),we=u("p"),ol=r("Sinon, nous vous recommandons de tronquer vos s\xE9quences en sp\xE9cifiant le param\xE8tre "),hn=u("code"),il=r("max_sequence_length"),ul=r(" :"),Wn=h(),g(Be.$$.fragment),this.h()},l(e){const i=Fr('[data-svelte="svelte-1phssyn"]',document.head);a=p(i,"META",{name:!0,content:!0}),i.forEach(n),c=_(e),q(t.$$.fragment,e),f=_(e),l=p(e,"H1",{class:!0});var Ke=m(l);b=p(Ke,"A",{id:!0,class:!0,href:!0});var _s=m(b);N=p(_s,"SPAN",{});var bs=m(N);q(M.$$.fragment,bs),bs.forEach(n),_s.forEach(n),P=_(Ke),x=p(Ke,"SPAN",{});var vs=m(x);ne=o(vs,"Manipulation de plusieurs s\xE9quences"),vs.forEach(n),Ke.forEach(n),H=_(e),F.l(e),D=_(e),T.l(e),ie=_(e),ue=p(e,"P",{});var $s=m(ue);Xe=o($s,"Dans la section pr\xE9c\xE9dente, nous avons explor\xE9 le cas d\u2019utilisation le plus simple : faire une inf\xE9rence sur une seule s\xE9quence de petite longueur. Cependant, certaines questions \xE9mergent d\xE9j\xE0 :"),$s.forEach(n),vn=_(e),B=p(e,"UL",{});var U=m(B);ys=p(U,"LI",{});var ks=m(ys);ct=o(ks,"comment g\xE9rer de plusieurs s\xE9quences ?"),ks.forEach(n),mt=_(U),xe=p(U,"LI",{});var We=m(xe);dt=o(We,"comment g\xE9rer de plusieurs s\xE9quences "),zs=p(We,"EM",{});var gs=m(zs);ft=o(gs,"de longueurs diff\xE9rentes"),gs.forEach(n),ht=o(We," ?"),We.forEach(n),_t=_(U),As=p(U,"LI",{});var qs=m(As);bt=o(qs,"les indices du vocabulaire sont-ils les seules entr\xE9es qui permettent \xE0 un mod\xE8le de bien fonctionner ?"),qs.forEach(n),vt=_(U),xs=p(U,"LI",{});var _n=m(xs);$t=o(_n,"existe-t-il une s\xE9quence trop longue ?"),_n.forEach(n),U.forEach(n),$n=_(e),fe=p(e,"P",{});var Zn=m(fe);kt=o(Zn,"Voyons quels types de probl\xE8mes ces questions posent et comment nous pouvons les r\xE9soudre en utilisant l\u2019API \u{1F917} "),Is=p(Zn,"EM",{});var zl=m(Is);gt=o(zl,"Transformers"),zl.forEach(n),qt=o(Zn,"."),Zn.forEach(n),kn=_(e),pe=p(e,"H2",{class:!0});var et=m(pe);he=p(et,"A",{id:!0,class:!0,href:!0});var Al=m(he);Ms=p(Al,"SPAN",{});var xl=m(Ms);q(Ie.$$.fragment,xl),xl.forEach(n),Al.forEach(n),jt=_(et),Ps=p(et,"SPAN",{});var Il=m(Ps);Et=o(Il,"Les mod\xE8les attendent un batch d'entr\xE9es"),Il.forEach(n),et.forEach(n),gn=_(e),Ze=p(e,"P",{});var Ml=m(Ze);wt=o(Ml,`Dans l\u2019exercice pr\xE9c\xE9dent, vous avez vu comment les s\xE9quences sont traduites en listes de nombres.
Convertissons cette liste de nombres en un tenseur et envoyons-le au mod\xE8le :`),Ml.forEach(n),qn=_(e),J.l(e),es=_(e),ss=p(e,"P",{});var Pl=m(ss);yt=o(Pl,"Pourquoi cela a \xE9chou\xE9 ? Nous avons suivi les \xE9tapes du pipeline de la section 2."),Pl.forEach(n),jn=_(e),O=p(e,"P",{});var ye=m(O);zt=o(ye,"Le probl\xE8me est que nous avons envoy\xE9 une seule s\xE9quence au mod\xE8le, alors que les mod\xE8les de l\u2019API \u{1F917} "),Cs=p(ye,"EM",{});var Cl=m(Cs);At=o(Cl,"Transformers"),Cl.forEach(n),xt=o(ye," attendent plusieurs phrases par d\xE9faut. Ici, nous avons essay\xE9 de faire ce que le "),Fs=p(ye,"EM",{});var Fl=m(Fs);It=o(Fl,"tokenizer"),Fl.forEach(n),Mt=o(ye," fait en coulisses lorsque nous l\u2019avons appliqu\xE9 \xE0 une "),Ts=p(ye,"CODE",{});var Tl=m(Ts);Pt=o(Tl,"s\xE9quence"),Tl.forEach(n),Ct=o(ye,". Cependant si vous regardez de pr\xE8s, vous verrez qu\u2019il n\u2019a pas seulement converti la liste des identifiants d\u2019entr\xE9e en un tenseur mais aussi ajout\xE9 une dimension par-dessus :"),ye.forEach(n),En=_(e),G.l(e),ns=_(e),ts=p(e,"P",{});var Sl=m(ts);Ft=o(Sl,"Essayons \xE0 nouveau en ajoutant une nouvelle dimension :"),Sl.forEach(n),wn=_(e),Q.l(e),as=_(e),ls=p(e,"P",{});var Ll=m(ls);Tt=o(Ll,"Nous affichons les identifiants d\u2019entr\xE9e ainsi que les logits r\xE9sultants. Voici la sortie :"),Ll.forEach(n),yn=_(e),W.l(e),rs=_(e),_e=p(e,"P",{});var st=m(_e);St=o(st,"Le \xAB "),Ss=p(st,"EM",{});var Nl=m(Ss);Lt=o(Nl,"batching"),Nl.forEach(n),Nt=o(st," \xBB est l\u2019acte d\u2019envoyer plusieurs phrases \xE0 travers le mod\xE8le, toutes en m\xEAme temps. Si vous n\u2019avez qu\u2019une seule phrase, vous pouvez simplement construire un batch avec une seule s\xE9quence :"),st.forEach(n),zn=_(e),q(Me.$$.fragment,e),An=_(e),os=p(e,"P",{});var Hl=m(os);Ht=o(Hl,"Il s\u2019agit d\u2019un batch de deux s\xE9quences identiques !"),Hl.forEach(n),xn=_(e),q(be.$$.fragment,e),In=_(e),S=p(e,"P",{});var re=m(S);Dt=o(re,"Utiliser des "),Ls=p(re,"EM",{});var Dl=m(Ls);Bt=o(Dl,"batchs"),Dl.forEach(n),Ot=o(re," permet au mod\xE8le de fonctionner lorsque vous lui donnez plusieurs s\xE9quences. Utiliser plusieurs s\xE9quences est aussi simple que de construire un batch avec une seule s\xE9quence. Il y a cependant un deuxi\xE8me probl\xE8me. Lorsque vous essayez de regrouper deux phrases (ou plus), elles peuvent \xEAtre de longueurs diff\xE9rentes. Si vous avez d\xE9j\xE0 travaill\xE9 avec des tenseurs, vous savez qu\u2019ils doivent \xEAtre de forme rectangulaire. Vous ne pourrez donc pas convertir directement la liste des identifiants d\u2019entr\xE9e en un tenseur. Pour contourner ce probl\xE8me, nous avons l\u2019habitude de "),Ns=p(re,"EM",{});var Bl=m(Ns);Ut=o(Bl,"rembourrer"),Bl.forEach(n),Vt=o(re,"/"),Hs=p(re,"EM",{});var Ol=m(Hs);Jt=o(Ol,"remplir"),Ol.forEach(n),Rt=o(re," (le "),Ds=p(re,"EM",{});var Ul=m(Ds);Gt=o(Ul,"padding"),Ul.forEach(n),Yt=o(re," en anglais) les entr\xE9es."),re.forEach(n),Mn=_(e),ce=p(e,"H2",{class:!0});var nt=m(ce);ve=p(nt,"A",{id:!0,class:!0,href:!0});var Vl=m(ve);Bs=p(Vl,"SPAN",{});var Jl=m(Bs);q(Pe.$$.fragment,Jl),Jl.forEach(n),Vl.forEach(n),Qt=_(nt),is=p(nt,"SPAN",{});var pl=m(is);Os=p(pl,"I",{});var Rl=m(Os);Kt=o(Rl,"Padding"),Rl.forEach(n),Wt=o(pl," des entr\xE9es"),pl.forEach(n),nt.forEach(n),Pn=_(e),us=p(e,"P",{});var Gl=m(us);Xt=o(Gl,"La liste de listes suivante ne peut pas \xEAtre convertie en un tenseur :"),Gl.forEach(n),Cn=_(e),q(Ce.$$.fragment,e),Fn=_(e),L=p(e,"P",{});var oe=m(L);Zt=o(oe,"Afin de contourner ce probl\xE8me, nous utilisons le "),Us=p(oe,"EM",{});var Yl=m(Us);ea=o(Yl,"padding"),Yl.forEach(n),sa=o(oe," pour que nos tenseurs aient une forme rectangulaire. Le "),Vs=p(oe,"EM",{});var Ql=m(Vs);na=o(Ql,"padding"),Ql.forEach(n),ta=o(oe," permet de s\u2019assurer que toutes nos phrases ont la m\xEAme longueur en ajoutant un mot sp\xE9cial appel\xE9 "),Js=p(oe,"EM",{});var Kl=m(Js);aa=o(Kl,"padding token"),Kl.forEach(n),la=o(oe," aux phrases ayant moins de valeurs. Par exemple, si vous avez 10 phrases de 10 mots et 1 phrase de 20 mots, le "),Rs=p(oe,"EM",{});var Wl=m(Rs);ra=o(Wl,"padding"),Wl.forEach(n),oa=o(oe," fait en sorte que toutes les phrases aient 20 mots. Dans notre exemple, le tenseur r\xE9sultant ressemble \xE0 ceci :"),oe.forEach(n),Tn=_(e),q(Fe.$$.fragment,e),Sn=_(e),te=p(e,"P",{});var js=m(te);ia=o(js,"L\u2019identifiant du jeton de "),Gs=p(js,"EM",{});var Xl=m(Gs);ua=o(Xl,"padding"),Xl.forEach(n),pa=o(js," peut \xEAtre trouv\xE9 dans "),Ys=p(js,"CODE",{});var Zl=m(Ys);ca=o(Zl,"tokenizer.pad_token_id"),Zl.forEach(n),ma=o(js,". Utilisons-le et envoyons nos deux phrases \xE0 travers le mod\xE8le premi\xE8rement individuellement puis en \xE9tant mises dans un m\xEAme batch :"),js.forEach(n),Ln=_(e),Z.l(e),ps=_(e),cs=p(e,"P",{});var er=m(cs);da=o(er,"Il y a quelque chose qui ne va pas avec les logits de notre pr\xE9diction avec les s\xE9quences mises dans un m\xEAme batch. La deuxi\xE8me ligne devrait \xEAtre la m\xEAme que les logits pour la deuxi\xE8me phrase, mais nous avons des valeurs compl\xE8tement diff\xE9rentes !"),er.forEach(n),Nn=_(e),A=p(e,"P",{});var I=m(A);fa=o(I,"C\u2019est parce que dans un "),Qs=p(I,"EM",{});var sr=m(Qs);ha=o(sr,"transformer"),sr.forEach(n),_a=o(I," les couches d\u2019attention "),Ks=p(I,"EM",{});var nr=m(Ks);ba=o(nr,"contextualisent"),nr.forEach(n),va=o(I," chaque "),Ws=p(I,"EM",{});var tr=m(Ws);$a=o(tr,"token"),tr.forEach(n),ka=o(I,". Celles-ci prennent en compte les "),Xs=p(I,"EM",{});var ar=m(Xs);ga=o(ar,"tokens"),ar.forEach(n),qa=o(I," de "),Zs=p(I,"EM",{});var lr=m(Zs);ja=o(lr,"padding"),lr.forEach(n),Ea=o(I," puisqu\u2019elles analysent tous les "),en=p(I,"EM",{});var rr=m(en);wa=o(rr,"tokens"),rr.forEach(n),ya=o(I," d\u2019une s\xE9quence. Pour obtenir le m\xEAme r\xE9sultat lorsque l\u2019on passe dans notre mod\xE8le des phrases individuelles de diff\xE9rentes longueurs ou un batch compos\xE9 de m\xEAmes phrases avec "),sn=p(I,"EM",{});var or=m(sn);za=o(or,"padding"),or.forEach(n),Aa=o(I,", nous devons dire \xE0 ces couches d\u2019attention d\u2019ignorer les jetons de "),nn=p(I,"EM",{});var ir=m(nn);xa=o(ir,"padding"),ir.forEach(n),Ia=o(I,". Ceci est fait en utilisant un masque d\u2019attention."),I.forEach(n),Hn=_(e),me=p(e,"H2",{class:!0});var tt=m(me);$e=p(tt,"A",{id:!0,class:!0,href:!0});var ur=m($e);tn=p(ur,"SPAN",{});var pr=m(tn);q(Te.$$.fragment,pr),pr.forEach(n),ur.forEach(n),Ma=_(tt),an=p(tt,"SPAN",{});var cr=m(an);Pa=o(cr,"Masques d'attention"),cr.forEach(n),tt.forEach(n),Dn=_(e),ms=p(e,"P",{});var mr=m(ms);Ca=o(mr,"Les masques d\u2019attention sont des tenseurs ayant exactement la m\xEAme forme que le tenseur d\u2019identifiants d\u2019entr\xE9e, remplis de 0 et de 1 :"),mr.forEach(n),Bn=_(e),ke=p(e,"UL",{});var at=m(ke);Se=p(at,"LI",{});var lt=m(Se);Fa=o(lt,"1 indique que les "),ln=p(lt,"EM",{});var dr=m(ln);Ta=o(dr,"tokens"),dr.forEach(n),Sa=o(lt," correspondants doivent \xEAtre analys\xE9s"),lt.forEach(n),La=_(at),Le=p(at,"LI",{});var rt=m(Le);Na=o(rt,"0 indique que les "),rn=p(rt,"EM",{});var fr=m(rn);Ha=o(fr,"tokens"),fr.forEach(n),Da=o(rt," correspondants ne doivent pas \xEAtre analys\xE9s (c\u2019est-\xE0-dire qu\u2019ils doivent \xEAtre ignor\xE9s par les couches d\u2019attention du mod\xE8le)."),rt.forEach(n),at.forEach(n),On=_(e),ds=p(e,"P",{});var hr=m(ds);Ba=o(hr,"Compl\xE9tons l\u2019exemple pr\xE9c\xE9dent avec un masque d\u2019attention :"),hr.forEach(n),Un=_(e),se.l(e),fs=_(e),hs=p(e,"P",{});var _r=m(hs);Oa=o(_r,"Nous obtenons maintenant les m\xEAmes logits pour la deuxi\xE8me phrase du batch."),_r.forEach(n),Vn=_(e),ge=p(e,"P",{});var ot=m(ge);Ua=o(ot,"Remarquez comment la derni\xE8re valeur de la deuxi\xE8me s\xE9quence est un identifiant de "),on=p(ot,"EM",{});var br=m(on);Va=o(br,"padding"),br.forEach(n),Ja=o(ot," valant 0 dans le masque d\u2019attention."),ot.forEach(n),Jn=_(e),q(qe.$$.fragment,e),Rn=_(e),de=p(e,"H2",{class:!0});var it=m(de);je=p(it,"A",{id:!0,class:!0,href:!0});var vr=m(je);un=p(vr,"SPAN",{});var $r=m(un);q(Ne.$$.fragment,$r),$r.forEach(n),vr.forEach(n),Ra=_(it),pn=p(it,"SPAN",{});var kr=m(pn);Ga=o(kr,"S\xE9quences plus longues"),kr.forEach(n),it.forEach(n),Gn=_(e),ae=p(e,"P",{});var Es=m(ae);Ya=o(Es,"Les "),cn=p(Es,"EM",{});var gr=m(cn);Qa=o(gr,"transformers"),gr.forEach(n),Ka=o(Es," acceptent en entr\xE9e que des s\xE9quences d\u2019une longueur limit\xE9e. La plupart des mod\xE8les traitent des s\xE9quences allant jusqu\u2019\xE0 512 ou 1024 "),mn=p(Es,"EM",{});var qr=m(mn);Wa=o(qr,"tokens"),qr.forEach(n),Xa=o(Es," et plantent lorsqu\u2019on leur demande de traiter des s\xE9quences plus longues. Il existe deux solutions \xE0 ce probl\xE8me :"),Es.forEach(n),Yn=_(e),Ee=p(e,"UL",{});var ut=m(Ee);dn=p(ut,"LI",{});var jr=m(dn);Za=o(jr,"utiliser un mod\xE8le avec une longueur de s\xE9quence support\xE9e plus longue,"),jr.forEach(n),el=_(ut),fn=p(ut,"LI",{});var Er=m(fn);sl=o(Er,"tronquer les s\xE9quences."),Er.forEach(n),ut.forEach(n),Qn=_(e),le=p(e,"P",{});var ws=m(le);nl=o(ws,"Certains mod\xE8les sont sp\xE9cialis\xE9s dans le traitement de tr\xE8s longues s\xE9quences comme par exemple le "),He=p(ws,"A",{href:!0,rel:!0});var wr=m(He);tl=o(wr,"Longformer"),wr.forEach(n),al=o(ws," ou le "),De=p(ws,"A",{href:!0,rel:!0});var yr=m(De);ll=o(yr,"LED"),yr.forEach(n),rl=o(ws,". Si vous travaillez sur une t\xE2che qui n\xE9cessite de tr\xE8s longues s\xE9quences, nous vous recommandons de jeter un coup d\u2019\u0153il \xE0 ces mod\xE8les."),ws.forEach(n),Kn=_(e),we=p(e,"P",{});var pt=m(we);ol=o(pt,"Sinon, nous vous recommandons de tronquer vos s\xE9quences en sp\xE9cifiant le param\xE8tre "),hn=p(pt,"CODE",{});var zr=m(hn);il=o(zr,"max_sequence_length"),zr.forEach(n),ul=o(pt," :"),pt.forEach(n),Wn=_(e),q(Be.$$.fragment,e),this.h()},h(){w(a,"name","hf:doc:metadata"),w(a,"content",JSON.stringify(no)),w(b,"id","manipulation-de-plusieurs-squences"),w(b,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(b,"href","#manipulation-de-plusieurs-squences"),w(l,"class","relative group"),w(he,"id","les-modles-attendent-un-batch-dentres"),w(he,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(he,"href","#les-modles-attendent-un-batch-dentres"),w(pe,"class","relative group"),w(ve,"id","ipaddingi-des-entres"),w(ve,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(ve,"href","#ipaddingi-des-entres"),w(ce,"class","relative group"),w($e,"id","masques-dattention"),w($e,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w($e,"href","#masques-dattention"),w(me,"class","relative group"),w(je,"id","squences-plus-longues"),w(je,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(je,"href","#squences-plus-longues"),w(de,"class","relative group"),w(He,"href","https://huggingface.co/transformers/model_doc/longformer.html"),w(He,"rel","nofollow"),w(De,"href","https://huggingface.co/transformers/model_doc/led.html"),w(De,"rel","nofollow")},m(e,i){s(document.head,a),d(e,c,i),j(t,e,i),d(e,f,i),d(e,l,i),s(l,b),s(b,N),j(M,N,null),s(l,P),s(l,x),s(x,ne),d(e,H,i),Oe[C].m(e,i),d(e,D,i),Ue[y].m(e,i),d(e,ie,i),d(e,ue,i),s(ue,Xe),d(e,vn,i),d(e,B,i),s(B,ys),s(ys,ct),s(B,mt),s(B,xe),s(xe,dt),s(xe,zs),s(zs,ft),s(xe,ht),s(B,_t),s(B,As),s(As,bt),s(B,vt),s(B,xs),s(xs,$t),d(e,$n,i),d(e,fe,i),s(fe,kt),s(fe,Is),s(Is,gt),s(fe,qt),d(e,kn,i),d(e,pe,i),s(pe,he),s(he,Ms),j(Ie,Ms,null),s(pe,jt),s(pe,Ps),s(Ps,Et),d(e,gn,i),d(e,Ze,i),s(Ze,wt),d(e,qn,i),Ve[V].m(e,i),d(e,es,i),d(e,ss,i),s(ss,yt),d(e,jn,i),d(e,O,i),s(O,zt),s(O,Cs),s(Cs,At),s(O,xt),s(O,Fs),s(Fs,It),s(O,Mt),s(O,Ts),s(Ts,Pt),s(O,Ct),d(e,En,i),Je[R].m(e,i),d(e,ns,i),d(e,ts,i),s(ts,Ft),d(e,wn,i),Re[Y].m(e,i),d(e,as,i),d(e,ls,i),s(ls,Tt),d(e,yn,i),Ge[K].m(e,i),d(e,rs,i),d(e,_e,i),s(_e,St),s(_e,Ss),s(Ss,Lt),s(_e,Nt),d(e,zn,i),j(Me,e,i),d(e,An,i),d(e,os,i),s(os,Ht),d(e,xn,i),j(be,e,i),d(e,In,i),d(e,S,i),s(S,Dt),s(S,Ls),s(Ls,Bt),s(S,Ot),s(S,Ns),s(Ns,Ut),s(S,Vt),s(S,Hs),s(Hs,Jt),s(S,Rt),s(S,Ds),s(Ds,Gt),s(S,Yt),d(e,Mn,i),d(e,ce,i),s(ce,ve),s(ve,Bs),j(Pe,Bs,null),s(ce,Qt),s(ce,is),s(is,Os),s(Os,Kt),s(is,Wt),d(e,Pn,i),d(e,us,i),s(us,Xt),d(e,Cn,i),j(Ce,e,i),d(e,Fn,i),d(e,L,i),s(L,Zt),s(L,Us),s(Us,ea),s(L,sa),s(L,Vs),s(Vs,na),s(L,ta),s(L,Js),s(Js,aa),s(L,la),s(L,Rs),s(Rs,ra),s(L,oa),d(e,Tn,i),j(Fe,e,i),d(e,Sn,i),d(e,te,i),s(te,ia),s(te,Gs),s(Gs,ua),s(te,pa),s(te,Ys),s(Ys,ca),s(te,ma),d(e,Ln,i),Ye[X].m(e,i),d(e,ps,i),d(e,cs,i),s(cs,da),d(e,Nn,i),d(e,A,i),s(A,fa),s(A,Qs),s(Qs,ha),s(A,_a),s(A,Ks),s(Ks,ba),s(A,va),s(A,Ws),s(Ws,$a),s(A,ka),s(A,Xs),s(Xs,ga),s(A,qa),s(A,Zs),s(Zs,ja),s(A,Ea),s(A,en),s(en,wa),s(A,ya),s(A,sn),s(sn,za),s(A,Aa),s(A,nn),s(nn,xa),s(A,Ia),d(e,Hn,i),d(e,me,i),s(me,$e),s($e,tn),j(Te,tn,null),s(me,Ma),s(me,an),s(an,Pa),d(e,Dn,i),d(e,ms,i),s(ms,Ca),d(e,Bn,i),d(e,ke,i),s(ke,Se),s(Se,Fa),s(Se,ln),s(ln,Ta),s(Se,Sa),s(ke,La),s(ke,Le),s(Le,Na),s(Le,rn),s(rn,Ha),s(Le,Da),d(e,On,i),d(e,ds,i),s(ds,Ba),d(e,Un,i),Qe[ee].m(e,i),d(e,fs,i),d(e,hs,i),s(hs,Oa),d(e,Vn,i),d(e,ge,i),s(ge,Ua),s(ge,on),s(on,Va),s(ge,Ja),d(e,Jn,i),j(qe,e,i),d(e,Rn,i),d(e,de,i),s(de,je),s(je,un),j(Ne,un,null),s(de,Ra),s(de,pn),s(pn,Ga),d(e,Gn,i),d(e,ae,i),s(ae,Ya),s(ae,cn),s(cn,Qa),s(ae,Ka),s(ae,mn),s(mn,Wa),s(ae,Xa),d(e,Yn,i),d(e,Ee,i),s(Ee,dn),s(dn,Za),s(Ee,el),s(Ee,fn),s(fn,sl),d(e,Qn,i),d(e,le,i),s(le,nl),s(le,He),s(He,tl),s(le,al),s(le,De),s(De,ll),s(le,rl),d(e,Kn,i),d(e,we,i),s(we,ol),s(we,hn),s(hn,il),s(we,ul),d(e,Wn,i),j(Be,e,i),Xn=!0},p(e,[i]){const Ke={};i&1&&(Ke.fw=e[0]),t.$set(Ke);let _s=C;C=ml(e),C!==_s&&(Ae(),v(Oe[_s],1,1,()=>{Oe[_s]=null}),ze(),F=Oe[C],F||(F=Oe[C]=cl[C](e),F.c()),$(F,1),F.m(D.parentNode,D));let bs=y;y=fl(e),y!==bs&&(Ae(),v(Ue[bs],1,1,()=>{Ue[bs]=null}),ze(),T=Ue[y],T||(T=Ue[y]=dl[y](e),T.c()),$(T,1),T.m(ie.parentNode,ie));let vs=V;V=_l(e),V!==vs&&(Ae(),v(Ve[vs],1,1,()=>{Ve[vs]=null}),ze(),J=Ve[V],J||(J=Ve[V]=hl[V](e),J.c()),$(J,1),J.m(es.parentNode,es));let $s=R;R=vl(e),R!==$s&&(Ae(),v(Je[$s],1,1,()=>{Je[$s]=null}),ze(),G=Je[R],G||(G=Je[R]=bl[R](e),G.c()),$(G,1),G.m(ns.parentNode,ns));let U=Y;Y=kl(e),Y!==U&&(Ae(),v(Re[U],1,1,()=>{Re[U]=null}),ze(),Q=Re[Y],Q||(Q=Re[Y]=$l[Y](e),Q.c()),$(Q,1),Q.m(as.parentNode,as));let ks=K;K=ql(e),K!==ks&&(Ae(),v(Ge[ks],1,1,()=>{Ge[ks]=null}),ze(),W=Ge[K],W||(W=Ge[K]=gl[K](e),W.c()),$(W,1),W.m(rs.parentNode,rs));const We={};i&2&&(We.$$scope={dirty:i,ctx:e}),be.$set(We);let gs=X;X=El(e),X!==gs&&(Ae(),v(Ye[gs],1,1,()=>{Ye[gs]=null}),ze(),Z=Ye[X],Z||(Z=Ye[X]=jl[X](e),Z.c()),$(Z,1),Z.m(ps.parentNode,ps));let qs=ee;ee=yl(e),ee!==qs&&(Ae(),v(Qe[qs],1,1,()=>{Qe[qs]=null}),ze(),se=Qe[ee],se||(se=Qe[ee]=wl[ee](e),se.c()),$(se,1),se.m(fs.parentNode,fs));const _n={};i&2&&(_n.$$scope={dirty:i,ctx:e}),qe.$set(_n)},i(e){Xn||($(t.$$.fragment,e),$(M.$$.fragment,e),$(F),$(T),$(Ie.$$.fragment,e),$(J),$(G),$(Q),$(W),$(Me.$$.fragment,e),$(be.$$.fragment,e),$(Pe.$$.fragment,e),$(Ce.$$.fragment,e),$(Fe.$$.fragment,e),$(Z),$(Te.$$.fragment,e),$(se),$(qe.$$.fragment,e),$(Ne.$$.fragment,e),$(Be.$$.fragment,e),Xn=!0)},o(e){v(t.$$.fragment,e),v(M.$$.fragment,e),v(F),v(T),v(Ie.$$.fragment,e),v(J),v(G),v(Q),v(W),v(Me.$$.fragment,e),v(be.$$.fragment,e),v(Pe.$$.fragment,e),v(Ce.$$.fragment,e),v(Fe.$$.fragment,e),v(Z),v(Te.$$.fragment,e),v(se),v(qe.$$.fragment,e),v(Ne.$$.fragment,e),v(Be.$$.fragment,e),Xn=!1},d(e){n(a),e&&n(c),E(t,e),e&&n(f),e&&n(l),E(M),e&&n(H),Oe[C].d(e),e&&n(D),Ue[y].d(e),e&&n(ie),e&&n(ue),e&&n(vn),e&&n(B),e&&n($n),e&&n(fe),e&&n(kn),e&&n(pe),E(Ie),e&&n(gn),e&&n(Ze),e&&n(qn),Ve[V].d(e),e&&n(es),e&&n(ss),e&&n(jn),e&&n(O),e&&n(En),Je[R].d(e),e&&n(ns),e&&n(ts),e&&n(wn),Re[Y].d(e),e&&n(as),e&&n(ls),e&&n(yn),Ge[K].d(e),e&&n(rs),e&&n(_e),e&&n(zn),E(Me,e),e&&n(An),e&&n(os),e&&n(xn),E(be,e),e&&n(In),e&&n(S),e&&n(Mn),e&&n(ce),E(Pe),e&&n(Pn),e&&n(us),e&&n(Cn),E(Ce,e),e&&n(Fn),e&&n(L),e&&n(Tn),E(Fe,e),e&&n(Sn),e&&n(te),e&&n(Ln),Ye[X].d(e),e&&n(ps),e&&n(cs),e&&n(Nn),e&&n(A),e&&n(Hn),e&&n(me),E(Te),e&&n(Dn),e&&n(ms),e&&n(Bn),e&&n(ke),e&&n(On),e&&n(ds),e&&n(Un),Qe[ee].d(e),e&&n(fs),e&&n(hs),e&&n(Vn),e&&n(ge),e&&n(Jn),E(qe,e),e&&n(Rn),e&&n(de),E(Ne),e&&n(Gn),e&&n(ae),e&&n(Yn),e&&n(Ee),e&&n(Qn),e&&n(le),e&&n(Kn),e&&n(we),e&&n(Wn),E(Be,e)}}}const no={local:"manipulation-de-plusieurs-squences",sections:[{local:"les-modles-attendent-un-batch-dentres",title:"Les mod\xE8les attendent un batch d'entr\xE9es"},{local:"ipaddingi-des-entres",title:"<i>Padding</i> des entr\xE9es"},{local:"masques-dattention",title:"Masques d'attention"},{local:"squences-plus-longues",title:"S\xE9quences plus longues"}],title:"Manipulation de plusieurs s\xE9quences"};function to(k,a,c){let t="pt";return Tr(()=>{const f=new URLSearchParams(window.location.search);c(0,t=f.get("fw")||"pt")}),[t]}class co extends Mr{constructor(a){super();Pr(this,a,to,so,Cr,{})}}export{co as default,no as metadata};
