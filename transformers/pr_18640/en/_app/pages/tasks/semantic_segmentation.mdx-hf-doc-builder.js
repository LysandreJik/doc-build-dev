import{S as xl,i as Pl,s as Tl,e as o,k as c,w as _,t as l,M as Sl,c as i,d as s,m as f,a as m,x as v,h as n,b as h,N as kl,G as a,g as p,y as b,q as $,o as j,B as y,v as ql}from"../../chunks/vendor-hf-doc-builder.js";import{T as El}from"../../chunks/Tip-hf-doc-builder.js";import{Y as Al}from"../../chunks/Youtube-hf-doc-builder.js";import{I as ma}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as q}from"../../chunks/CodeBlock-hf-doc-builder.js";import{F as Cl,M as Fl}from"../../chunks/Markdown-hf-doc-builder.js";function Il(he){let u,P,d,k,T;return{c(){u=o("p"),P=l("See the image segmentation "),d=o("a"),k=l("task page"),T=l(" for more information about its associated models, datasets, and metrics."),this.h()},l(E){u=i(E,"P",{});var x=m(u);P=n(x,"See the image segmentation "),d=i(x,"A",{href:!0,rel:!0});var z=m(d);k=n(z,"task page"),z.forEach(s),T=n(x," for more information about its associated models, datasets, and metrics."),x.forEach(s),this.h()},h(){h(d,"href","https://huggingface.co/tasks/image-segmentation"),h(d,"rel","nofollow")},m(E,x){p(E,u,x),a(u,P),a(u,d),a(d,k),a(u,T)},d(E){E&&s(u)}}}function Dl(he){let u,P,d,k,T,E,x,z;return{c(){u=o("p"),P=l("If you aren\u2019t familiar with finetuning a model with the "),d=o("a"),k=l("Trainer"),T=l(", take a look at the basic tutorial "),E=o("a"),x=l("here"),z=l("!"),this.h()},l(A){u=i(A,"P",{});var C=m(u);P=n(C,"If you aren\u2019t familiar with finetuning a model with the "),d=i(C,"A",{href:!0});var w=m(d);k=n(w,"Trainer"),w.forEach(s),T=n(C,", take a look at the basic tutorial "),E=i(C,"A",{href:!0});var ne=m(E);x=n(ne,"here"),ne.forEach(s),z=n(C,"!"),C.forEach(s),this.h()},h(){h(d,"href","/docs/transformers/pr_18640/en/main_classes/trainer#transformers.Trainer"),h(E,"href","../training#finetune-with-trainer")},m(A,C){p(A,u,C),a(u,P),a(u,d),a(d,k),a(u,T),a(u,E),a(E,x),a(u,z)},d(A){A&&s(u)}}}function zl(he){let u,P,d,k,T,E,x,z,A,C,w,ne,Y,ss,ze,O,as,re,xe,ts,oe,Pe,ls,Oe,G,Le,ue,Ne,V,ie,de,W,Q,ge,N,Me,B,ns,X,_e,rs,Te,H,Ue,pe,me,Se,F,Ge,J,os,Be,M,He,S,Je,K,Re,Z,qe,ve,is,Ae,Ye,ce,be,ee,ps,se,ms,cs,Ce,I,Ve;return x=new q({props:{code:`from transformers import AutoModelForSemanticSegmentation

pretrained_model_name = "nvidia/mit-b0"
model = AutoModelForSemanticSegmentation.from_pretrained(
    pretrained_model_name, num_labels=num_labels, id2label=id2label, label2id=label2id
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSemanticSegmentation

<span class="hljs-meta">&gt;&gt;&gt; </span>pretrained_model_name = <span class="hljs-string">&quot;nvidia/mit-b0&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = AutoModelForSemanticSegmentation.from_pretrained(
<span class="hljs-meta">... </span>    pretrained_model_name, num_labels=num_labels, id2label=id2label, label2id=label2id
<span class="hljs-meta">... </span>)`}}),A=new El({props:{$$slots:{default:[Dl]},$$scope:{ctx:he}}}),N=new q({props:{code:`from transformers import TrainingArguments

training_args = TrainingArguments(
    output_dir="segformer-b0-scene-parse-150",
    learning_rate=6e-5,
    num_train_epochs=50,
    per_device_train_batch_size=2,
    per_device_eval_batch_size=2,
    save_total_limit=3,
    evaluation_strategy="steps",
    save_strategy="steps",
    save_steps=20,
    eval_steps=20,
    logging_steps=1,
    eval_accumulation_steps=5,
    remove_unused_columns=False,
    push_to_hub=True,
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

<span class="hljs-meta">&gt;&gt;&gt; </span>training_args = TrainingArguments(
<span class="hljs-meta">... </span>    output_dir=<span class="hljs-string">&quot;segformer-b0-scene-parse-150&quot;</span>,
<span class="hljs-meta">... </span>    learning_rate=<span class="hljs-number">6e-5</span>,
<span class="hljs-meta">... </span>    num_train_epochs=<span class="hljs-number">50</span>,
<span class="hljs-meta">... </span>    per_device_train_batch_size=<span class="hljs-number">2</span>,
<span class="hljs-meta">... </span>    per_device_eval_batch_size=<span class="hljs-number">2</span>,
<span class="hljs-meta">... </span>    save_total_limit=<span class="hljs-number">3</span>,
<span class="hljs-meta">... </span>    evaluation_strategy=<span class="hljs-string">&quot;steps&quot;</span>,
<span class="hljs-meta">... </span>    save_strategy=<span class="hljs-string">&quot;steps&quot;</span>,
<span class="hljs-meta">... </span>    save_steps=<span class="hljs-number">20</span>,
<span class="hljs-meta">... </span>    eval_steps=<span class="hljs-number">20</span>,
<span class="hljs-meta">... </span>    logging_steps=<span class="hljs-number">1</span>,
<span class="hljs-meta">... </span>    eval_accumulation_steps=<span class="hljs-number">5</span>,
<span class="hljs-meta">... </span>    remove_unused_columns=<span class="hljs-literal">False</span>,
<span class="hljs-meta">... </span>    push_to_hub=<span class="hljs-literal">True</span>,
<span class="hljs-meta">... </span>)`}}),me=new q({props:{code:`import evaluate

metric = evaluate.load("mean_iou")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> evaluate

<span class="hljs-meta">&gt;&gt;&gt; </span>metric = evaluate.load(<span class="hljs-string">&quot;mean_iou&quot;</span>)`}}),K=new q({props:{code:`def compute_metrics(eval_pred):
    with torch.no_grad():
        logits, labels = eval_pred
        logits_tensor = torch.from_numpy(logits)
        logits_tensor = nn.functional.interpolate(
            logits_tensor,
            size=labels.shape[-2:],
            mode="bilinear",
            align_corners=False,
        ).argmax(dim=1)

        pred_labels = logits_tensor.detach().cpu().numpy()
        metrics = metric.compute(
            predictions=pred_labels,
            references=labels,
            num_labels=num_labels,
            ignore_index=255,
            reduce_labels=False,
        )
        for key, value in metrics.items():
            if type(value) is np.ndarray:
                metrics[key] = value.tolist()
        return metrics`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_metrics</span>(<span class="hljs-params">eval_pred</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>        logits, labels = eval_pred
<span class="hljs-meta">... </span>        logits_tensor = torch.from_numpy(logits)
<span class="hljs-meta">... </span>        logits_tensor = nn.functional.interpolate(
<span class="hljs-meta">... </span>            logits_tensor,
<span class="hljs-meta">... </span>            size=labels.shape[-<span class="hljs-number">2</span>:],
<span class="hljs-meta">... </span>            mode=<span class="hljs-string">&quot;bilinear&quot;</span>,
<span class="hljs-meta">... </span>            align_corners=<span class="hljs-literal">False</span>,
<span class="hljs-meta">... </span>        ).argmax(dim=<span class="hljs-number">1</span>)

<span class="hljs-meta">... </span>        pred_labels = logits_tensor.detach().cpu().numpy()
<span class="hljs-meta">... </span>        metrics = metric.compute(
<span class="hljs-meta">... </span>            predictions=pred_labels,
<span class="hljs-meta">... </span>            references=labels,
<span class="hljs-meta">... </span>            num_labels=num_labels,
<span class="hljs-meta">... </span>            ignore_index=<span class="hljs-number">255</span>,
<span class="hljs-meta">... </span>            reduce_labels=<span class="hljs-literal">False</span>,
<span class="hljs-meta">... </span>        )
<span class="hljs-meta">... </span>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> metrics.items():
<span class="hljs-meta">... </span>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(value) <span class="hljs-keyword">is</span> np.ndarray:
<span class="hljs-meta">... </span>                metrics[key] = value.tolist()
<span class="hljs-meta">... </span>        <span class="hljs-keyword">return</span> metrics`}}),ce=new q({props:{code:`from transformers import Trainer

trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=train_ds,
    eval_dataset=test_ds,
    compute_metrics=compute_metrics,
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Trainer

<span class="hljs-meta">&gt;&gt;&gt; </span>trainer = Trainer(
<span class="hljs-meta">... </span>    model=model,
<span class="hljs-meta">... </span>    args=training_args,
<span class="hljs-meta">... </span>    train_dataset=train_ds,
<span class="hljs-meta">... </span>    eval_dataset=test_ds,
<span class="hljs-meta">... </span>    compute_metrics=compute_metrics,
<span class="hljs-meta">... </span>)`}}),I=new q({props:{code:"trainer.train()",highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>trainer.train()'}}),{c(){u=o("p"),P=l("Load SegFormer with "),d=o("a"),k=l("AutoModelForSemanticSegmentation"),T=l(", specify the number of labels, and pass the model the mapping between label ids and label classes:"),E=c(),_(x.$$.fragment),z=c(),_(A.$$.fragment),C=c(),w=o("p"),ne=l("Define your training hyperparameters in "),Y=o("a"),ss=l("TrainingArguments"),ze=l(". It is important not to remove unused columns because this will drop the "),O=o("code"),as=l("image"),re=l(" column. Without the "),xe=o("code"),ts=l("image"),oe=l(" column, you can\u2019t create "),Pe=o("code"),ls=l("pixel_values"),Oe=l(". Set "),G=o("code"),Le=l("remove_unused_columns=False"),ue=l(" to prevent this behavior!"),Ne=c(),V=o("p"),ie=l("To save and push a model under your namespace to the Hub, set "),de=o("code"),W=l("push_to_hub=True"),Q=l(":"),ge=c(),_(N.$$.fragment),Me=c(),B=o("p"),ns=l("To evaluate model performance during training, you\u2019ll need to create a function to compute and report metrics. For semantic segmentation, you\u2019ll typically compute the "),X=o("a"),_e=l("mean Intersection over Union"),rs=l(" (IoU). The mean IoU measures the overlapping area between the predicted and ground truth segmentation maps."),Te=c(),H=o("p"),Ue=l("Load the mean IoU from the \u{1F917} Evaluate library:"),pe=c(),_(me.$$.fragment),Se=c(),F=o("p"),Ge=l("Then create a function to "),J=o("a"),os=l("compute"),Be=l(" the metrics. Your predictions need to be converted to logits first, and then reshaped to match the size of the labels before you can call "),M=o("a"),He=l("compute"),S=l(":"),Je=c(),_(K.$$.fragment),Re=c(),Z=o("p"),qe=l("Pass your model, training arguments, datasets, and metrics function to the "),ve=o("a"),is=l("Trainer"),Ae=l(":"),Ye=c(),_(ce.$$.fragment),be=c(),ee=o("p"),ps=l("Lastly, call "),se=o("a"),ms=l("train()"),cs=l(" to finetune your model:"),Ce=c(),_(I.$$.fragment),this.h()},l(t){u=i(t,"P",{});var g=m(u);P=n(g,"Load SegFormer with "),d=i(g,"A",{href:!0});var Fe=m(d);k=n(Fe,"AutoModelForSemanticSegmentation"),Fe.forEach(s),T=n(g,", specify the number of labels, and pass the model the mapping between label ids and label classes:"),g.forEach(s),E=f(t),v(x.$$.fragment,t),z=f(t),v(A.$$.fragment,t),C=f(t),w=i(t,"P",{});var D=m(w);ne=n(D,"Define your training hyperparameters in "),Y=i(D,"A",{href:!0});var Fs=m(Y);ss=n(Fs,"TrainingArguments"),Fs.forEach(s),ze=n(D,". It is important not to remove unused columns because this will drop the "),O=i(D,"CODE",{});var Is=m(O);as=n(Is,"image"),Is.forEach(s),re=n(D," column. Without the "),xe=i(D,"CODE",{});var fs=m(xe);ts=n(fs,"image"),fs.forEach(s),oe=n(D," column, you can\u2019t create "),Pe=i(D,"CODE",{});var $e=m(Pe);ls=n($e,"pixel_values"),$e.forEach(s),Oe=n(D,". Set "),G=i(D,"CODE",{});var hs=m(G);Le=n(hs,"remove_unused_columns=False"),hs.forEach(s),ue=n(D," to prevent this behavior!"),D.forEach(s),Ne=f(t),V=i(t,"P",{});var R=m(V);ie=n(R,"To save and push a model under your namespace to the Hub, set "),de=i(R,"CODE",{});var fe=m(de);W=n(fe,"push_to_hub=True"),fe.forEach(s),Q=n(R,":"),R.forEach(s),ge=f(t),v(N.$$.fragment,t),Me=f(t),B=i(t,"P",{});var je=m(B);ns=n(je,"To evaluate model performance during training, you\u2019ll need to create a function to compute and report metrics. For semantic segmentation, you\u2019ll typically compute the "),X=i(je,"A",{href:!0,rel:!0});var ye=m(X);_e=n(ye,"mean Intersection over Union"),ye.forEach(s),rs=n(je," (IoU). The mean IoU measures the overlapping area between the predicted and ground truth segmentation maps."),je.forEach(s),Te=f(t),H=i(t,"P",{});var Ds=m(H);Ue=n(Ds,"Load the mean IoU from the \u{1F917} Evaluate library:"),Ds.forEach(s),pe=f(t),v(me.$$.fragment,t),Se=f(t),F=i(t,"P",{});var ae=m(F);Ge=n(ae,"Then create a function to "),J=i(ae,"A",{href:!0,rel:!0});var zs=m(J);os=n(zs,"compute"),zs.forEach(s),Be=n(ae," the metrics. Your predictions need to be converted to logits first, and then reshaped to match the size of the labels before you can call "),M=i(ae,"A",{href:!0,rel:!0});var us=m(M);He=n(us,"compute"),us.forEach(s),S=n(ae,":"),ae.forEach(s),Je=f(t),v(K.$$.fragment,t),Re=f(t),Z=i(t,"P",{});var U=m(Z);qe=n(U,"Pass your model, training arguments, datasets, and metrics function to the "),ve=i(U,"A",{href:!0});var Os=m(ve);is=n(Os,"Trainer"),Os.forEach(s),Ae=n(U,":"),U.forEach(s),Ye=f(t),v(ce.$$.fragment,t),be=f(t),ee=i(t,"P",{});var we=m(ee);ps=n(we,"Lastly, call "),se=i(we,"A",{href:!0});var Ls=m(se);ms=n(Ls,"train()"),Ls.forEach(s),cs=n(we," to finetune your model:"),we.forEach(s),Ce=f(t),v(I.$$.fragment,t),this.h()},h(){h(d,"href","/docs/transformers/pr_18640/en/model_doc/auto#transformers.AutoModelForSemanticSegmentation"),h(Y,"href","/docs/transformers/pr_18640/en/main_classes/trainer#transformers.TrainingArguments"),h(X,"href","https://huggingface.co/spaces/evaluate-metric/mean_iou"),h(X,"rel","nofollow"),h(J,"href","https://huggingface.co/docs/evaluate/main/en/package_reference/main_classes#evaluate.EvaluationModule.compute"),h(J,"rel","nofollow"),h(M,"href","https://huggingface.co/docs/evaluate/main/en/package_reference/main_classes#evaluate.EvaluationModule.compute"),h(M,"rel","nofollow"),h(ve,"href","/docs/transformers/pr_18640/en/main_classes/trainer#transformers.Trainer"),h(se,"href","/docs/transformers/pr_18640/en/main_classes/trainer#transformers.Trainer.train")},m(t,g){p(t,u,g),a(u,P),a(u,d),a(d,k),a(u,T),p(t,E,g),b(x,t,g),p(t,z,g),b(A,t,g),p(t,C,g),p(t,w,g),a(w,ne),a(w,Y),a(Y,ss),a(w,ze),a(w,O),a(O,as),a(w,re),a(w,xe),a(xe,ts),a(w,oe),a(w,Pe),a(Pe,ls),a(w,Oe),a(w,G),a(G,Le),a(w,ue),p(t,Ne,g),p(t,V,g),a(V,ie),a(V,de),a(de,W),a(V,Q),p(t,ge,g),b(N,t,g),p(t,Me,g),p(t,B,g),a(B,ns),a(B,X),a(X,_e),a(B,rs),p(t,Te,g),p(t,H,g),a(H,Ue),p(t,pe,g),b(me,t,g),p(t,Se,g),p(t,F,g),a(F,Ge),a(F,J),a(J,os),a(F,Be),a(F,M),a(M,He),a(F,S),p(t,Je,g),b(K,t,g),p(t,Re,g),p(t,Z,g),a(Z,qe),a(Z,ve),a(ve,is),a(Z,Ae),p(t,Ye,g),b(ce,t,g),p(t,be,g),p(t,ee,g),a(ee,ps),a(ee,se),a(se,ms),a(ee,cs),p(t,Ce,g),b(I,t,g),Ve=!0},p(t,g){const Fe={};g&2&&(Fe.$$scope={dirty:g,ctx:t}),A.$set(Fe)},i(t){Ve||($(x.$$.fragment,t),$(A.$$.fragment,t),$(N.$$.fragment,t),$(me.$$.fragment,t),$(K.$$.fragment,t),$(ce.$$.fragment,t),$(I.$$.fragment,t),Ve=!0)},o(t){j(x.$$.fragment,t),j(A.$$.fragment,t),j(N.$$.fragment,t),j(me.$$.fragment,t),j(K.$$.fragment,t),j(ce.$$.fragment,t),j(I.$$.fragment,t),Ve=!1},d(t){t&&s(u),t&&s(E),y(x,t),t&&s(z),y(A,t),t&&s(C),t&&s(w),t&&s(Ne),t&&s(V),t&&s(ge),y(N,t),t&&s(Me),t&&s(B),t&&s(Te),t&&s(H),t&&s(pe),y(me,t),t&&s(Se),t&&s(F),t&&s(Je),y(K,t),t&&s(Re),t&&s(Z),t&&s(Ye),y(ce,t),t&&s(be),t&&s(ee),t&&s(Ce),y(I,t)}}}function Ol(he){let u,P;return u=new Fl({props:{$$slots:{default:[zl]},$$scope:{ctx:he}}}),{c(){_(u.$$.fragment)},l(d){v(u.$$.fragment,d)},m(d,k){b(u,d,k),P=!0},p(d,k){const T={};k&2&&(T.$$scope={dirty:k,ctx:d}),u.$set(T)},i(d){P||($(u.$$.fragment,d),P=!0)},o(d){j(u.$$.fragment,d),P=!1},d(d){y(u,d)}}}function Ll(he){let u,P,d,k,T,E,x,z,A,C,w,ne,Y,ss,ze,O,as,re,xe,ts,oe,Pe,ls,Oe,G,Le,ue,Ne,V,ie,de,W,Q,ge,N,Me,B,ns,X,_e,rs,Te,H,Ue,pe,me,Se,F,Ge,J,os,Be,M,He,S,Je,K,Re,Z,qe,ve,is,Ae,Ye,ce,be,ee,ps,se,ms,cs,Ce,I,Ve,t,g,Fe,D,Fs,Is,fs,$e,hs,R,fe,je,ye,Ds,ae,zs,us,U,Os,we,Ls,Ga,Ws,Ba,Ha,ca,ds,fa,ke,Ja,gs,Ks,Ra,Ya,_s,Va,Wa,ha,vs,ua,L,Ka,Qs,Qa,Xa,Xs,Za,et,Zs,st,at,ea,tt,lt,sa,nt,rt,da,bs,ga,Ee,ot,aa,it,pt,$s,mt,ct,_a,js,va,Ie,We,ta,ys,ft,la,ht,ba,Ke,$a,De,Qe,na,ws,ut,ra,dt,ja,Ns,gt,ya,Ms,_t,wa,ks,ka,Es,Us,Tt,Ea,Xe,vt,oa,bt,$t,xa,xs,Pa,Ze,jt,ia,yt,wt,Ta,Ps,Sa,Gs,kt,qa,Ts,Aa,es,Et,Ss,xt,Pt,Ca,qs,Fa,As,Bs,St,Ia;return E=new ma({}),w=new Al({props:{id:"dKE8SIt9C-w"}}),G=new El({props:{$$slots:{default:[Il]},$$scope:{ctx:he}}}),ie=new q({props:{code:"pip install -q datasets transformers evaluate",highlighted:"pip install -q datasets transformers evaluate"}}),N=new ma({}),H=new q({props:{code:`from datasets import load_dataset

ds = load_dataset("scene_parse_150", split="train[:50]")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

<span class="hljs-meta">&gt;&gt;&gt; </span>ds = load_dataset(<span class="hljs-string">&quot;scene_parse_150&quot;</span>, split=<span class="hljs-string">&quot;train[:50]&quot;</span>)`}}),F=new q({props:{code:`ds = ds.train_test_split(test_size=0.2)
train_ds = ds["train"]
test_ds = ds["test"]`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>ds = ds.train_test_split(test_size=<span class="hljs-number">0.2</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>train_ds = ds[<span class="hljs-string">&quot;train&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>test_ds = ds[<span class="hljs-string">&quot;test&quot;</span>]`}}),M=new q({props:{code:"train_ds[0]",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>train_ds[<span class="hljs-number">0</span>]
{<span class="hljs-string">&#x27;image&#x27;</span>: &lt;PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=512x683 at <span class="hljs-number">0x7F9B0C201F90</span>&gt;,
 <span class="hljs-string">&#x27;annotation&#x27;</span>: &lt;PIL.PngImagePlugin.PngImageFile image mode=L size=512x683 at <span class="hljs-number">0x7F9B0C201DD0</span>&gt;,
 <span class="hljs-string">&#x27;scene_category&#x27;</span>: <span class="hljs-number">368</span>}`}}),$e=new q({props:{code:`import json
from huggingface_hub import cached_download, hf_hub_url

repo_id = "datasets/huggingface/label-files"
filename = "ade20k-hf-doc-builder.json"
id2label = json.load(open(cached_download(hf_hub_url(repo_id, filename)), "r"))
id2label = {int(k): v for k, v in id2label.items()}
label2id = {v: k for k, v in id2label.items()}`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> json
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> huggingface_hub <span class="hljs-keyword">import</span> cached_download, hf_hub_url

<span class="hljs-meta">&gt;&gt;&gt; </span>repo_id = <span class="hljs-string">&quot;datasets/huggingface/label-files&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>filename = <span class="hljs-string">&quot;ade20k-hf-doc-builder.json&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>id2label = json.load(<span class="hljs-built_in">open</span>(cached_download(hf_hub_url(repo_id, filename)), <span class="hljs-string">&quot;r&quot;</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>id2label = {<span class="hljs-built_in">int</span>(k): v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> id2label.items()}
<span class="hljs-meta">&gt;&gt;&gt; </span>label2id = {v: k <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> id2label.items()}`}}),ye=new ma({}),ds=new q({props:{code:`from transformers import AutoFeatureExtractor

feature_extractor = AutoFeatureExtractor.from_pretrained("nvidia/mit-b0", reduce_labels=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoFeatureExtractor

<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = AutoFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;nvidia/mit-b0&quot;</span>, reduce_labels=<span class="hljs-literal">True</span>)`}}),vs=new q({props:{code:`from torchvision.transforms import ColorJitter

jitter = ColorJitter(brightness=0.25, contrast=0.25, saturation=0.25, hue=0.1)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> torchvision.transforms <span class="hljs-keyword">import</span> ColorJitter

<span class="hljs-meta">&gt;&gt;&gt; </span>jitter = ColorJitter(brightness=<span class="hljs-number">0.25</span>, contrast=<span class="hljs-number">0.25</span>, saturation=<span class="hljs-number">0.25</span>, hue=<span class="hljs-number">0.1</span>)`}}),bs=new q({props:{code:`def train_transforms(example_batch):
    images = [jitter(x) for x in example_batch["image"]]
    labels = [x for x in example_batch["annotation"]]
    inputs = feature_extractor(images, labels)
    return inputs


def val_transforms(example_batch):
    images = [x for x in example_batch["image"]]
    labels = [x for x in example_batch["annotation"]]
    inputs = feature_extractor(images, labels)
    return inputs`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_transforms</span>(<span class="hljs-params">example_batch</span>):
<span class="hljs-meta">... </span>    images = [jitter(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> example_batch[<span class="hljs-string">&quot;image&quot;</span>]]
<span class="hljs-meta">... </span>    labels = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> example_batch[<span class="hljs-string">&quot;annotation&quot;</span>]]
<span class="hljs-meta">... </span>    inputs = feature_extractor(images, labels)
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> inputs


<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">val_transforms</span>(<span class="hljs-params">example_batch</span>):
<span class="hljs-meta">... </span>    images = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> example_batch[<span class="hljs-string">&quot;image&quot;</span>]]
<span class="hljs-meta">... </span>    labels = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> example_batch[<span class="hljs-string">&quot;annotation&quot;</span>]]
<span class="hljs-meta">... </span>    inputs = feature_extractor(images, labels)
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> inputs`}}),js=new q({props:{code:`train_ds.set_transform(train_transforms)
test_ds.set_transform(val_transforms)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>train_ds.set_transform(train_transforms)
<span class="hljs-meta">&gt;&gt;&gt; </span>test_ds.set_transform(val_transforms)`}}),ys=new ma({}),Ke=new Cl({props:{pytorch:!0,tensorflow:!1,jax:!1,$$slots:{pytorch:[Ol]},$$scope:{ctx:he}}}),ws=new ma({}),ks=new q({props:{code:`image = ds[0]["image"]
image`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>image = ds[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;image&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>image`}}),xs=new q({props:{code:`device = torch.device("cuda" if torch.cuda.is_available() else "cpu")  # use GPU if available, otherwise use a CPU
encoding = feature_extractor(image, return_tensors="pt")
pixel_values = encoding.pixel_values.to(device)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)  <span class="hljs-comment"># use GPU if available, otherwise use a CPU</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>encoding = feature_extractor(image, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>pixel_values = encoding.pixel_values.to(device)`}}),Ps=new q({props:{code:`outputs = model(pixel_values=pixel_values)
logits = outputs.logits.cpu()`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(pixel_values=pixel_values)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits.cpu()`}}),Ts=new q({props:{code:`upsampled_logits = nn.functional.interpolate(
    logits,
    size=image.size[::-1],
    mode="bilinear",
    align_corners=False,
)

pred_seg = upsampled_logits.argmax(dim=1)[0]`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>upsampled_logits = nn.functional.interpolate(
<span class="hljs-meta">... </span>    logits,
<span class="hljs-meta">... </span>    size=image.size[::-<span class="hljs-number">1</span>],
<span class="hljs-meta">... </span>    mode=<span class="hljs-string">&quot;bilinear&quot;</span>,
<span class="hljs-meta">... </span>    align_corners=<span class="hljs-literal">False</span>,
<span class="hljs-meta">... </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>pred_seg = upsampled_logits.argmax(dim=<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]`}}),qs=new q({props:{code:`import matplotlib.pyplot as plt

color_seg = np.zeros((pred_seg.shape[0], pred_seg.shape[1], 3), dtype=np.uint8)
palette = np.array(ade_palette())
for label, color in enumerate(palette):
    color_seg[pred_seg == label, :] = color
color_seg = color_seg[..., ::-1]  # convert to BGR

img = np.array(image) * 0.5 + color_seg * 0.5  # plot the image with the segmentation map
img = img.astype(np.uint8)

plt.figure(figsize=(15, 10))
plt.imshow(img)
plt.show()`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt

<span class="hljs-meta">&gt;&gt;&gt; </span>color_seg = np.zeros((pred_seg.shape[<span class="hljs-number">0</span>], pred_seg.shape[<span class="hljs-number">1</span>], <span class="hljs-number">3</span>), dtype=np.uint8)
<span class="hljs-meta">&gt;&gt;&gt; </span>palette = np.array(ade_palette())
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> label, color <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(palette):
<span class="hljs-meta">... </span>    color_seg[pred_seg == label, :] = color
<span class="hljs-meta">&gt;&gt;&gt; </span>color_seg = color_seg[..., ::-<span class="hljs-number">1</span>]  <span class="hljs-comment"># convert to BGR</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>img = np.array(image) * <span class="hljs-number">0.5</span> + color_seg * <span class="hljs-number">0.5</span>  <span class="hljs-comment"># plot the image with the segmentation map</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>img = img.astype(np.uint8)

<span class="hljs-meta">&gt;&gt;&gt; </span>plt.figure(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">10</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>plt.imshow(img)
<span class="hljs-meta">&gt;&gt;&gt; </span>plt.show()`}}),{c(){u=o("meta"),P=c(),d=o("h1"),k=o("a"),T=o("span"),_(E.$$.fragment),x=c(),z=o("span"),A=l("Semantic segmentation"),C=c(),_(w.$$.fragment),ne=c(),Y=o("p"),ss=l("Semantic segmentation assigns a label or class to each individual pixel of an image. There are several types of segmentation, and in the case of semantic segmentation, it doesn\u2019t differentiate between unique instances of the same object. Both objects are given the same label (for example, \u201Ccar\u201D instead of \u201Ccar-1\u201D and \u201Ccar-2\u201D). Common real-world applications of semantic segmentation include training self-driving cars to identify pedestrians and important traffic information, identifying cells and abnormalities in medical imagery, and monitoring environmental changes from satellite imagery."),ze=c(),O=o("p"),as=l("This guide will show you how to finetune "),re=o("a"),xe=l("SegFormer"),ts=l(" on the "),oe=o("a"),Pe=l("SceneParse150"),ls=l(" dataset."),Oe=c(),_(G.$$.fragment),Le=c(),ue=o("p"),Ne=l("Before you begin, make sure you have all the necessary libraries installed:"),V=c(),_(ie.$$.fragment),de=c(),W=o("h2"),Q=o("a"),ge=o("span"),_(N.$$.fragment),Me=c(),B=o("span"),ns=l("Load SceneParse150 dataset"),X=c(),_e=o("p"),rs=l("Load the first 50 examples of the SceneParse150 dataset from the \u{1F917} Datasets library so you can quickly train and test a model:"),Te=c(),_(H.$$.fragment),Ue=c(),pe=o("p"),me=l("Split this dataset into a train and test set:"),Se=c(),_(F.$$.fragment),Ge=c(),J=o("p"),os=l("Then take a look at an example:"),Be=c(),_(M.$$.fragment),He=c(),S=o("p"),Je=l("There is an "),K=o("code"),Re=l("image"),Z=l(", an "),qe=o("code"),ve=l("annotation"),is=l(" (this is the segmentation map or label), and a "),Ae=o("code"),Ye=l("scene_category"),ce=l(" field that describes the image scene, like \u201Ckitchen\u201D or \u201Coffice\u201D. In this guide, you\u2019ll only need "),be=o("code"),ee=l("image"),ps=l(" and "),se=o("code"),ms=l("annotation"),cs=l(", both of which are PIL images."),Ce=c(),I=o("p"),Ve=l("You\u2019ll also want to create a dictionary that maps a label id to a label class which will be useful when you set up the model later. Download the mappings from the Hub and create the "),t=o("code"),g=l("id2label"),Fe=l(" and "),D=o("code"),Fs=l("label2id"),Is=l(" dictionaries:"),fs=c(),_($e.$$.fragment),hs=c(),R=o("h2"),fe=o("a"),je=o("span"),_(ye.$$.fragment),Ds=c(),ae=o("span"),zs=l("Preprocess"),us=c(),U=o("p"),Os=l("Next, load a SegFormer feature extractor to prepare the images and annotations for the model. Some datasets, like this one, use the zero-index as the background class. However, the background class isn\u2019t included in the 150 classes, so you\u2019ll need to set "),we=o("code"),Ls=l("reduce_labels=True"),Ga=l(" to subtract one from all the labels. The zero-index is replaced by "),Ws=o("code"),Ba=l("255"),Ha=l(" so it\u2019s ignored by SegFormer\u2019s loss function:"),ca=c(),_(ds.$$.fragment),fa=c(),ke=o("p"),Ja=l("It is common to apply some data augmentations to an image dataset to make a model more robust against overfitting. In this guide, you\u2019ll use the "),gs=o("a"),Ks=o("code"),Ra=l("ColorJitter"),Ya=l(" function from "),_s=o("a"),Va=l("torchvision"),Wa=l(" to randomly change the color properties of an image:"),ha=c(),_(vs.$$.fragment),ua=c(),L=o("p"),Ka=l("Now create two preprocessing functions to prepare the images and annotations for the model. These functions convert the images into "),Qs=o("code"),Qa=l("pixel_values"),Xa=l(" and annotations to "),Xs=o("code"),Za=l("labels"),et=l(". For the training set, "),Zs=o("code"),st=l("jitter"),at=l(" is applied before providing the images to the feature extractor. For the test set, the feature extractor crops and normalizes the "),ea=o("code"),tt=l("images"),lt=l(", and only crops the "),sa=o("code"),nt=l("labels"),rt=l(" because no data augmentation is applied during testing."),da=c(),_(bs.$$.fragment),ga=c(),Ee=o("p"),ot=l("To apply the "),aa=o("code"),it=l("jitter"),pt=l(" over the entire dataset, use \u{1F917} Datasets "),$s=o("a"),mt=l("set_transform"),ct=l(" function. The transform is applied on the fly which is faster and consumes less disk space:"),_a=c(),_(js.$$.fragment),va=c(),Ie=o("h2"),We=o("a"),ta=o("span"),_(ys.$$.fragment),ft=c(),la=o("span"),ht=l("Train"),ba=c(),_(Ke.$$.fragment),$a=c(),De=o("h2"),Qe=o("a"),na=o("span"),_(ws.$$.fragment),ut=c(),ra=o("span"),dt=l("Inference"),ja=c(),Ns=o("p"),gt=l("Great, now that you\u2019ve finetuned a model, you can use it for inference!"),ya=c(),Ms=o("p"),_t=l("Load an image for inference:"),wa=c(),_(ks.$$.fragment),ka=c(),Es=o("div"),Us=o("img"),Ea=c(),Xe=o("p"),vt=l("Process the image with a feature extractor and place the "),oa=o("code"),bt=l("pixel_values"),$t=l(" on a GPU:"),xa=c(),_(xs.$$.fragment),Pa=c(),Ze=o("p"),jt=l("Pass your input to the model and return the "),ia=o("code"),yt=l("logits"),wt=l(":"),Ta=c(),_(Ps.$$.fragment),Sa=c(),Gs=o("p"),kt=l("Next, rescale the logits to the original image size:"),qa=c(),_(Ts.$$.fragment),Aa=c(),es=o("p"),Et=l("To visualize the results, load the "),Ss=o("a"),xt=l("dataset color palette"),Pt=l(" that maps each class to their RGB values. Then you can combine and plot your image and the predicted segmentation map:"),Ca=c(),_(qs.$$.fragment),Fa=c(),As=o("div"),Bs=o("img"),this.h()},l(e){const r=Sl('[data-svelte="svelte-1phssyn"]',document.head);u=i(r,"META",{name:!0,content:!0}),r.forEach(s),P=f(e),d=i(e,"H1",{class:!0});var Cs=m(d);k=i(Cs,"A",{id:!0,class:!0,href:!0});var pa=m(k);T=i(pa,"SPAN",{});var qt=m(T);v(E.$$.fragment,qt),qt.forEach(s),pa.forEach(s),x=f(Cs),z=i(Cs,"SPAN",{});var At=m(z);A=n(At,"Semantic segmentation"),At.forEach(s),Cs.forEach(s),C=f(e),v(w.$$.fragment,e),ne=f(e),Y=i(e,"P",{});var Ct=m(Y);ss=n(Ct,"Semantic segmentation assigns a label or class to each individual pixel of an image. There are several types of segmentation, and in the case of semantic segmentation, it doesn\u2019t differentiate between unique instances of the same object. Both objects are given the same label (for example, \u201Ccar\u201D instead of \u201Ccar-1\u201D and \u201Ccar-2\u201D). Common real-world applications of semantic segmentation include training self-driving cars to identify pedestrians and important traffic information, identifying cells and abnormalities in medical imagery, and monitoring environmental changes from satellite imagery."),Ct.forEach(s),ze=f(e),O=i(e,"P",{});var Hs=m(O);as=n(Hs,"This guide will show you how to finetune "),re=i(Hs,"A",{href:!0,rel:!0});var Ft=m(re);xe=n(Ft,"SegFormer"),Ft.forEach(s),ts=n(Hs," on the "),oe=i(Hs,"A",{href:!0,rel:!0});var It=m(oe);Pe=n(It,"SceneParse150"),It.forEach(s),ls=n(Hs," dataset."),Hs.forEach(s),Oe=f(e),v(G.$$.fragment,e),Le=f(e),ue=i(e,"P",{});var Dt=m(ue);Ne=n(Dt,"Before you begin, make sure you have all the necessary libraries installed:"),Dt.forEach(s),V=f(e),v(ie.$$.fragment,e),de=f(e),W=i(e,"H2",{class:!0});var Da=m(W);Q=i(Da,"A",{id:!0,class:!0,href:!0});var zt=m(Q);ge=i(zt,"SPAN",{});var Ot=m(ge);v(N.$$.fragment,Ot),Ot.forEach(s),zt.forEach(s),Me=f(Da),B=i(Da,"SPAN",{});var Lt=m(B);ns=n(Lt,"Load SceneParse150 dataset"),Lt.forEach(s),Da.forEach(s),X=f(e),_e=i(e,"P",{});var Nt=m(_e);rs=n(Nt,"Load the first 50 examples of the SceneParse150 dataset from the \u{1F917} Datasets library so you can quickly train and test a model:"),Nt.forEach(s),Te=f(e),v(H.$$.fragment,e),Ue=f(e),pe=i(e,"P",{});var Mt=m(pe);me=n(Mt,"Split this dataset into a train and test set:"),Mt.forEach(s),Se=f(e),v(F.$$.fragment,e),Ge=f(e),J=i(e,"P",{});var Ut=m(J);os=n(Ut,"Then take a look at an example:"),Ut.forEach(s),Be=f(e),v(M.$$.fragment,e),He=f(e),S=i(e,"P",{});var te=m(S);Je=n(te,"There is an "),K=i(te,"CODE",{});var Gt=m(K);Re=n(Gt,"image"),Gt.forEach(s),Z=n(te,", an "),qe=i(te,"CODE",{});var Bt=m(qe);ve=n(Bt,"annotation"),Bt.forEach(s),is=n(te," (this is the segmentation map or label), and a "),Ae=i(te,"CODE",{});var Ht=m(Ae);Ye=n(Ht,"scene_category"),Ht.forEach(s),ce=n(te," field that describes the image scene, like \u201Ckitchen\u201D or \u201Coffice\u201D. In this guide, you\u2019ll only need "),be=i(te,"CODE",{});var Jt=m(be);ee=n(Jt,"image"),Jt.forEach(s),ps=n(te," and "),se=i(te,"CODE",{});var Rt=m(se);ms=n(Rt,"annotation"),Rt.forEach(s),cs=n(te,", both of which are PIL images."),te.forEach(s),Ce=f(e),I=i(e,"P",{});var Js=m(I);Ve=n(Js,"You\u2019ll also want to create a dictionary that maps a label id to a label class which will be useful when you set up the model later. Download the mappings from the Hub and create the "),t=i(Js,"CODE",{});var Yt=m(t);g=n(Yt,"id2label"),Yt.forEach(s),Fe=n(Js," and "),D=i(Js,"CODE",{});var Vt=m(D);Fs=n(Vt,"label2id"),Vt.forEach(s),Is=n(Js," dictionaries:"),Js.forEach(s),fs=f(e),v($e.$$.fragment,e),hs=f(e),R=i(e,"H2",{class:!0});var za=m(R);fe=i(za,"A",{id:!0,class:!0,href:!0});var Wt=m(fe);je=i(Wt,"SPAN",{});var Kt=m(je);v(ye.$$.fragment,Kt),Kt.forEach(s),Wt.forEach(s),Ds=f(za),ae=i(za,"SPAN",{});var Qt=m(ae);zs=n(Qt,"Preprocess"),Qt.forEach(s),za.forEach(s),us=f(e),U=i(e,"P",{});var Rs=m(U);Os=n(Rs,"Next, load a SegFormer feature extractor to prepare the images and annotations for the model. Some datasets, like this one, use the zero-index as the background class. However, the background class isn\u2019t included in the 150 classes, so you\u2019ll need to set "),we=i(Rs,"CODE",{});var Xt=m(we);Ls=n(Xt,"reduce_labels=True"),Xt.forEach(s),Ga=n(Rs," to subtract one from all the labels. The zero-index is replaced by "),Ws=i(Rs,"CODE",{});var Zt=m(Ws);Ba=n(Zt,"255"),Zt.forEach(s),Ha=n(Rs," so it\u2019s ignored by SegFormer\u2019s loss function:"),Rs.forEach(s),ca=f(e),v(ds.$$.fragment,e),fa=f(e),ke=i(e,"P",{});var Ys=m(ke);Ja=n(Ys,"It is common to apply some data augmentations to an image dataset to make a model more robust against overfitting. In this guide, you\u2019ll use the "),gs=i(Ys,"A",{href:!0,rel:!0});var el=m(gs);Ks=i(el,"CODE",{});var sl=m(Ks);Ra=n(sl,"ColorJitter"),sl.forEach(s),el.forEach(s),Ya=n(Ys," function from "),_s=i(Ys,"A",{href:!0,rel:!0});var al=m(_s);Va=n(al,"torchvision"),al.forEach(s),Wa=n(Ys," to randomly change the color properties of an image:"),Ys.forEach(s),ha=f(e),v(vs.$$.fragment,e),ua=f(e),L=i(e,"P",{});var le=m(L);Ka=n(le,"Now create two preprocessing functions to prepare the images and annotations for the model. These functions convert the images into "),Qs=i(le,"CODE",{});var tl=m(Qs);Qa=n(tl,"pixel_values"),tl.forEach(s),Xa=n(le," and annotations to "),Xs=i(le,"CODE",{});var ll=m(Xs);Za=n(ll,"labels"),ll.forEach(s),et=n(le,". For the training set, "),Zs=i(le,"CODE",{});var nl=m(Zs);st=n(nl,"jitter"),nl.forEach(s),at=n(le," is applied before providing the images to the feature extractor. For the test set, the feature extractor crops and normalizes the "),ea=i(le,"CODE",{});var rl=m(ea);tt=n(rl,"images"),rl.forEach(s),lt=n(le,", and only crops the "),sa=i(le,"CODE",{});var ol=m(sa);nt=n(ol,"labels"),ol.forEach(s),rt=n(le," because no data augmentation is applied during testing."),le.forEach(s),da=f(e),v(bs.$$.fragment,e),ga=f(e),Ee=i(e,"P",{});var Vs=m(Ee);ot=n(Vs,"To apply the "),aa=i(Vs,"CODE",{});var il=m(aa);it=n(il,"jitter"),il.forEach(s),pt=n(Vs," over the entire dataset, use \u{1F917} Datasets "),$s=i(Vs,"A",{href:!0,rel:!0});var pl=m($s);mt=n(pl,"set_transform"),pl.forEach(s),ct=n(Vs," function. The transform is applied on the fly which is faster and consumes less disk space:"),Vs.forEach(s),_a=f(e),v(js.$$.fragment,e),va=f(e),Ie=i(e,"H2",{class:!0});var Oa=m(Ie);We=i(Oa,"A",{id:!0,class:!0,href:!0});var ml=m(We);ta=i(ml,"SPAN",{});var cl=m(ta);v(ys.$$.fragment,cl),cl.forEach(s),ml.forEach(s),ft=f(Oa),la=i(Oa,"SPAN",{});var fl=m(la);ht=n(fl,"Train"),fl.forEach(s),Oa.forEach(s),ba=f(e),v(Ke.$$.fragment,e),$a=f(e),De=i(e,"H2",{class:!0});var La=m(De);Qe=i(La,"A",{id:!0,class:!0,href:!0});var hl=m(Qe);na=i(hl,"SPAN",{});var ul=m(na);v(ws.$$.fragment,ul),ul.forEach(s),hl.forEach(s),ut=f(La),ra=i(La,"SPAN",{});var dl=m(ra);dt=n(dl,"Inference"),dl.forEach(s),La.forEach(s),ja=f(e),Ns=i(e,"P",{});var gl=m(Ns);gt=n(gl,"Great, now that you\u2019ve finetuned a model, you can use it for inference!"),gl.forEach(s),ya=f(e),Ms=i(e,"P",{});var _l=m(Ms);_t=n(_l,"Load an image for inference:"),_l.forEach(s),wa=f(e),v(ks.$$.fragment,e),ka=f(e),Es=i(e,"DIV",{class:!0});var vl=m(Es);Us=i(vl,"IMG",{src:!0,alt:!0}),vl.forEach(s),Ea=f(e),Xe=i(e,"P",{});var Na=m(Xe);vt=n(Na,"Process the image with a feature extractor and place the "),oa=i(Na,"CODE",{});var bl=m(oa);bt=n(bl,"pixel_values"),bl.forEach(s),$t=n(Na," on a GPU:"),Na.forEach(s),xa=f(e),v(xs.$$.fragment,e),Pa=f(e),Ze=i(e,"P",{});var Ma=m(Ze);jt=n(Ma,"Pass your input to the model and return the "),ia=i(Ma,"CODE",{});var $l=m(ia);yt=n($l,"logits"),$l.forEach(s),wt=n(Ma,":"),Ma.forEach(s),Ta=f(e),v(Ps.$$.fragment,e),Sa=f(e),Gs=i(e,"P",{});var jl=m(Gs);kt=n(jl,"Next, rescale the logits to the original image size:"),jl.forEach(s),qa=f(e),v(Ts.$$.fragment,e),Aa=f(e),es=i(e,"P",{});var Ua=m(es);Et=n(Ua,"To visualize the results, load the "),Ss=i(Ua,"A",{href:!0,rel:!0});var yl=m(Ss);xt=n(yl,"dataset color palette"),yl.forEach(s),Pt=n(Ua," that maps each class to their RGB values. Then you can combine and plot your image and the predicted segmentation map:"),Ua.forEach(s),Ca=f(e),v(qs.$$.fragment,e),Fa=f(e),As=i(e,"DIV",{class:!0});var wl=m(As);Bs=i(wl,"IMG",{src:!0,alt:!0}),wl.forEach(s),this.h()},h(){h(u,"name","hf:doc:metadata"),h(u,"content",JSON.stringify(Nl)),h(k,"id","semantic-segmentation"),h(k,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(k,"href","#semantic-segmentation"),h(d,"class","relative group"),h(re,"href","https://huggingface.co/docs/transformers/main/en/model_doc/segformer#segformer"),h(re,"rel","nofollow"),h(oe,"href","https://huggingface.co/datasets/scene_parse_150"),h(oe,"rel","nofollow"),h(Q,"id","load-sceneparse150-dataset"),h(Q,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(Q,"href","#load-sceneparse150-dataset"),h(W,"class","relative group"),h(fe,"id","preprocess"),h(fe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(fe,"href","#preprocess"),h(R,"class","relative group"),h(gs,"href","https://pytorch.org/vision/stable/generated/torchvision.transforms.ColorJitter.html"),h(gs,"rel","nofollow"),h(_s,"href","https://pytorch.org/vision/stable/index.html"),h(_s,"rel","nofollow"),h($s,"href","https://huggingface.co/docs/datasets/main/en/package_reference/main_classes#datasets.Dataset.set_transform"),h($s,"rel","nofollow"),h(We,"id","train"),h(We,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(We,"href","#train"),h(Ie,"class","relative group"),h(Qe,"id","inference"),h(Qe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(Qe,"href","#inference"),h(De,"class","relative group"),kl(Us.src,Tt="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/semantic-seg-image.png")||h(Us,"src",Tt),h(Us,"alt","Image of bedroom"),h(Es,"class","flex justify-center"),h(Ss,"href","https://github.com/tensorflow/models/blob/3f1ca33afe3c1631b733ea7e40c294273b9e406d/research/deeplab/utils/get_dataset_colormap.py#L51"),h(Ss,"rel","nofollow"),kl(Bs.src,St="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/semantic-seg-preds.png")||h(Bs,"src",St),h(Bs,"alt","Image of bedroom overlayed with segmentation map"),h(As,"class","flex justify-center")},m(e,r){a(document.head,u),p(e,P,r),p(e,d,r),a(d,k),a(k,T),b(E,T,null),a(d,x),a(d,z),a(z,A),p(e,C,r),b(w,e,r),p(e,ne,r),p(e,Y,r),a(Y,ss),p(e,ze,r),p(e,O,r),a(O,as),a(O,re),a(re,xe),a(O,ts),a(O,oe),a(oe,Pe),a(O,ls),p(e,Oe,r),b(G,e,r),p(e,Le,r),p(e,ue,r),a(ue,Ne),p(e,V,r),b(ie,e,r),p(e,de,r),p(e,W,r),a(W,Q),a(Q,ge),b(N,ge,null),a(W,Me),a(W,B),a(B,ns),p(e,X,r),p(e,_e,r),a(_e,rs),p(e,Te,r),b(H,e,r),p(e,Ue,r),p(e,pe,r),a(pe,me),p(e,Se,r),b(F,e,r),p(e,Ge,r),p(e,J,r),a(J,os),p(e,Be,r),b(M,e,r),p(e,He,r),p(e,S,r),a(S,Je),a(S,K),a(K,Re),a(S,Z),a(S,qe),a(qe,ve),a(S,is),a(S,Ae),a(Ae,Ye),a(S,ce),a(S,be),a(be,ee),a(S,ps),a(S,se),a(se,ms),a(S,cs),p(e,Ce,r),p(e,I,r),a(I,Ve),a(I,t),a(t,g),a(I,Fe),a(I,D),a(D,Fs),a(I,Is),p(e,fs,r),b($e,e,r),p(e,hs,r),p(e,R,r),a(R,fe),a(fe,je),b(ye,je,null),a(R,Ds),a(R,ae),a(ae,zs),p(e,us,r),p(e,U,r),a(U,Os),a(U,we),a(we,Ls),a(U,Ga),a(U,Ws),a(Ws,Ba),a(U,Ha),p(e,ca,r),b(ds,e,r),p(e,fa,r),p(e,ke,r),a(ke,Ja),a(ke,gs),a(gs,Ks),a(Ks,Ra),a(ke,Ya),a(ke,_s),a(_s,Va),a(ke,Wa),p(e,ha,r),b(vs,e,r),p(e,ua,r),p(e,L,r),a(L,Ka),a(L,Qs),a(Qs,Qa),a(L,Xa),a(L,Xs),a(Xs,Za),a(L,et),a(L,Zs),a(Zs,st),a(L,at),a(L,ea),a(ea,tt),a(L,lt),a(L,sa),a(sa,nt),a(L,rt),p(e,da,r),b(bs,e,r),p(e,ga,r),p(e,Ee,r),a(Ee,ot),a(Ee,aa),a(aa,it),a(Ee,pt),a(Ee,$s),a($s,mt),a(Ee,ct),p(e,_a,r),b(js,e,r),p(e,va,r),p(e,Ie,r),a(Ie,We),a(We,ta),b(ys,ta,null),a(Ie,ft),a(Ie,la),a(la,ht),p(e,ba,r),b(Ke,e,r),p(e,$a,r),p(e,De,r),a(De,Qe),a(Qe,na),b(ws,na,null),a(De,ut),a(De,ra),a(ra,dt),p(e,ja,r),p(e,Ns,r),a(Ns,gt),p(e,ya,r),p(e,Ms,r),a(Ms,_t),p(e,wa,r),b(ks,e,r),p(e,ka,r),p(e,Es,r),a(Es,Us),p(e,Ea,r),p(e,Xe,r),a(Xe,vt),a(Xe,oa),a(oa,bt),a(Xe,$t),p(e,xa,r),b(xs,e,r),p(e,Pa,r),p(e,Ze,r),a(Ze,jt),a(Ze,ia),a(ia,yt),a(Ze,wt),p(e,Ta,r),b(Ps,e,r),p(e,Sa,r),p(e,Gs,r),a(Gs,kt),p(e,qa,r),b(Ts,e,r),p(e,Aa,r),p(e,es,r),a(es,Et),a(es,Ss),a(Ss,xt),a(es,Pt),p(e,Ca,r),b(qs,e,r),p(e,Fa,r),p(e,As,r),a(As,Bs),Ia=!0},p(e,[r]){const Cs={};r&2&&(Cs.$$scope={dirty:r,ctx:e}),G.$set(Cs);const pa={};r&2&&(pa.$$scope={dirty:r,ctx:e}),Ke.$set(pa)},i(e){Ia||($(E.$$.fragment,e),$(w.$$.fragment,e),$(G.$$.fragment,e),$(ie.$$.fragment,e),$(N.$$.fragment,e),$(H.$$.fragment,e),$(F.$$.fragment,e),$(M.$$.fragment,e),$($e.$$.fragment,e),$(ye.$$.fragment,e),$(ds.$$.fragment,e),$(vs.$$.fragment,e),$(bs.$$.fragment,e),$(js.$$.fragment,e),$(ys.$$.fragment,e),$(Ke.$$.fragment,e),$(ws.$$.fragment,e),$(ks.$$.fragment,e),$(xs.$$.fragment,e),$(Ps.$$.fragment,e),$(Ts.$$.fragment,e),$(qs.$$.fragment,e),Ia=!0)},o(e){j(E.$$.fragment,e),j(w.$$.fragment,e),j(G.$$.fragment,e),j(ie.$$.fragment,e),j(N.$$.fragment,e),j(H.$$.fragment,e),j(F.$$.fragment,e),j(M.$$.fragment,e),j($e.$$.fragment,e),j(ye.$$.fragment,e),j(ds.$$.fragment,e),j(vs.$$.fragment,e),j(bs.$$.fragment,e),j(js.$$.fragment,e),j(ys.$$.fragment,e),j(Ke.$$.fragment,e),j(ws.$$.fragment,e),j(ks.$$.fragment,e),j(xs.$$.fragment,e),j(Ps.$$.fragment,e),j(Ts.$$.fragment,e),j(qs.$$.fragment,e),Ia=!1},d(e){s(u),e&&s(P),e&&s(d),y(E),e&&s(C),y(w,e),e&&s(ne),e&&s(Y),e&&s(ze),e&&s(O),e&&s(Oe),y(G,e),e&&s(Le),e&&s(ue),e&&s(V),y(ie,e),e&&s(de),e&&s(W),y(N),e&&s(X),e&&s(_e),e&&s(Te),y(H,e),e&&s(Ue),e&&s(pe),e&&s(Se),y(F,e),e&&s(Ge),e&&s(J),e&&s(Be),y(M,e),e&&s(He),e&&s(S),e&&s(Ce),e&&s(I),e&&s(fs),y($e,e),e&&s(hs),e&&s(R),y(ye),e&&s(us),e&&s(U),e&&s(ca),y(ds,e),e&&s(fa),e&&s(ke),e&&s(ha),y(vs,e),e&&s(ua),e&&s(L),e&&s(da),y(bs,e),e&&s(ga),e&&s(Ee),e&&s(_a),y(js,e),e&&s(va),e&&s(Ie),y(ys),e&&s(ba),y(Ke,e),e&&s($a),e&&s(De),y(ws),e&&s(ja),e&&s(Ns),e&&s(ya),e&&s(Ms),e&&s(wa),y(ks,e),e&&s(ka),e&&s(Es),e&&s(Ea),e&&s(Xe),e&&s(xa),y(xs,e),e&&s(Pa),e&&s(Ze),e&&s(Ta),y(Ps,e),e&&s(Sa),e&&s(Gs),e&&s(qa),y(Ts,e),e&&s(Aa),e&&s(es),e&&s(Ca),y(qs,e),e&&s(Fa),e&&s(As)}}}const Nl={local:"semantic-segmentation",sections:[{local:"load-sceneparse150-dataset",title:"Load SceneParse150 dataset"},{local:"preprocess",title:"Preprocess"},{local:"train",title:"Train"},{local:"inference",title:"Inference"}],title:"Semantic segmentation"};function Ml(he){return ql(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Yl extends xl{constructor(u){super();Pl(this,u,Ml,Ll,Tl,{})}}export{Yl as default,Nl as metadata};
