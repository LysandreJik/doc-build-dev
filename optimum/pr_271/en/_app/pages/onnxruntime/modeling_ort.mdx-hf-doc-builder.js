import{S as Cp,i as Ap,s as Sp,e as r,k as h,w as v,t as m,M as Pp,c as a,d as o,m as f,a as i,x as T,h as p,b as y,G as e,g as k,y as b,q as M,o as O,B as q,v as Np,L as C}from"../../chunks/vendor-hf-doc-builder.js";import{T as yt}from"../../chunks/Tip-hf-doc-builder.js";import{D as F}from"../../chunks/Docstring-hf-doc-builder.js";import{C as R}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as Z}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{E as z}from"../../chunks/ExampleCodeBlock-hf-doc-builder.js";function Ip(j){let n,$,c,u,_;return{c(){n=r("p"),$=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),c=r("code"),u=m("Module"),_=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(s){n=a(s,"P",{});var l=i(n);$=p(l,"Although the recipe for forward pass needs to be defined within this function, one should call the "),c=a(l,"CODE",{});var x=i(c);u=p(x,"Module"),x.forEach(o),_=p(l,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),l.forEach(o)},m(s,l){k(s,n,l),e(n,$),e(n,c),e(c,u),e(n,_)},d(s){s&&o(n)}}}function Lp(j){let n,$,c,u,_;return u=new R({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForFeatureExtraction
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/all-MiniLM-L6-v2")
model = ORTModelForFeatureExtraction.from_pretrained("optimum/all-MiniLM-L6-v2")

inputs = tokenizer("My name is Philipp and I live in Germany.", return_tensors="pt")

outputs = model(**inputs)
logits = outputs.logits
list(logits.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForFeatureExtraction
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForFeatureExtraction.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(logits.shape)`}}),{c(){n=r("p"),$=m("Example of feature extraction:"),c=h(),v(u.$$.fragment)},l(s){n=a(s,"P",{});var l=i(n);$=p(l,"Example of feature extraction:"),l.forEach(o),c=f(s),T(u.$$.fragment,s)},m(s,l){k(s,n,l),e(n,$),k(s,c,l),b(u,s,l),_=!0},p:C,i(s){_||(M(u.$$.fragment,s),_=!0)},o(s){O(u.$$.fragment,s),_=!1},d(s){s&&o(n),s&&o(c),q(u,s)}}}function Dp(j){let n,$,c,u,_,s,l,x;return l=new R({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForFeatureExtraction

tokenizer = AutoTokenizer.from_pretrained("optimum/all-MiniLM-L6-v2")
model = ORTModelForFeatureExtraction.from_pretrained("optimum/all-MiniLM-L6-v2")
onnx_extractor = pipeline("feature-extraction", model=model, tokenizer=tokenizer)

text = "My name is Philipp and I live in Germany."
pred = onnx_extractor(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForFeatureExtraction

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForFeatureExtraction.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_extractor = pipeline(<span class="hljs-string">&quot;feature-extraction&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_extractor(text)`}}),{c(){n=r("p"),$=m("Example using "),c=r("code"),u=m("transformers.pipeline"),_=m(":"),s=h(),v(l.$$.fragment)},l(d){n=a(d,"P",{});var w=i(n);$=p(w,"Example using "),c=a(w,"CODE",{});var E=i(c);u=p(E,"transformers.pipeline"),E.forEach(o),_=p(w,":"),w.forEach(o),s=f(d),T(l.$$.fragment,d)},m(d,w){k(d,n,w),e(n,$),e(n,c),e(c,u),e(n,_),k(d,s,w),b(l,d,w),x=!0},p:C,i(d){x||(M(l.$$.fragment,d),x=!0)},o(d){O(l.$$.fragment,d),x=!1},d(d){d&&o(n),d&&o(s),q(l,d)}}}function Hp(j){let n,$,c,u,_;return{c(){n=r("p"),$=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),c=r("code"),u=m("Module"),_=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(s){n=a(s,"P",{});var l=i(n);$=p(l,"Although the recipe for forward pass needs to be defined within this function, one should call the "),c=a(l,"CODE",{});var x=i(c);u=p(x,"Module"),x.forEach(o),_=p(l,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),l.forEach(o)},m(s,l){k(s,n,l),e(n,$),e(n,c),e(c,u),e(n,_)},d(s){s&&o(n)}}}function Xp(j){let n,$,c,u,_;return u=new R({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForQuestionAnswering
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/roberta-base-squad2")
model = ORTModelForQuestionAnswering.from_pretrained("optimum/roberta-base-squad2")

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"
inputs = tokenizer(question, text, return_tensors="pt")
start_positions = torch.tensor([1])
end_positions = torch.tensor([3])

outputs = model(**inputs, start_positions=start_positions, end_positions=end_positions)
start_scores = outputs.start_logits
end_scores = outputs.end_logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForQuestionAnswering
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(question, text, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>start_positions = torch.tensor([<span class="hljs-number">1</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>end_positions = torch.tensor([<span class="hljs-number">3</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, start_positions=start_positions, end_positions=end_positions)
<span class="hljs-meta">&gt;&gt;&gt; </span>start_scores = outputs.start_logits
<span class="hljs-meta">&gt;&gt;&gt; </span>end_scores = outputs.end_logits`}}),{c(){n=r("p"),$=m("Example of question answering:"),c=h(),v(u.$$.fragment)},l(s){n=a(s,"P",{});var l=i(n);$=p(l,"Example of question answering:"),l.forEach(o),c=f(s),T(u.$$.fragment,s)},m(s,l){k(s,n,l),e(n,$),k(s,c,l),b(u,s,l),_=!0},p:C,i(s){_||(M(u.$$.fragment,s),_=!0)},o(s){O(u.$$.fragment,s),_=!1},d(s){s&&o(n),s&&o(c),q(u,s)}}}function Qp(j){let n,$,c,u,_,s,l,x;return l=new R({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForQuestionAnswering

tokenizer = AutoTokenizer.from_pretrained("optimum/roberta-base-squad2")
model = ORTModelForQuestionAnswering.from_pretrained("optimum/roberta-base-squad2")
onnx_qa = pipeline("question-answering", model=model, tokenizer=tokenizer)

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"
pred = onnx_qa(question, text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForQuestionAnswering

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_qa = pipeline(<span class="hljs-string">&quot;question-answering&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_qa(question, text)`}}),{c(){n=r("p"),$=m("Example using "),c=r("code"),u=m("transformers.pipeline"),_=m(":"),s=h(),v(l.$$.fragment)},l(d){n=a(d,"P",{});var w=i(n);$=p(w,"Example using "),c=a(w,"CODE",{});var E=i(c);u=p(E,"transformers.pipeline"),E.forEach(o),_=p(w,":"),w.forEach(o),s=f(d),T(l.$$.fragment,d)},m(d,w){k(d,n,w),e(n,$),e(n,c),e(c,u),e(n,_),k(d,s,w),b(l,d,w),x=!0},p:C,i(d){x||(M(l.$$.fragment,d),x=!0)},o(d){O(l.$$.fragment,d),x=!1},d(d){d&&o(n),d&&o(s),q(l,d)}}}function Wp(j){let n,$,c,u,_;return{c(){n=r("p"),$=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),c=r("code"),u=m("Module"),_=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(s){n=a(s,"P",{});var l=i(n);$=p(l,"Although the recipe for forward pass needs to be defined within this function, one should call the "),c=a(l,"CODE",{});var x=i(c);u=p(x,"Module"),x.forEach(o),_=p(l,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),l.forEach(o)},m(s,l){k(s,n,l),e(n,$),e(n,c),e(c,u),e(n,_)},d(s){s&&o(n)}}}function Bp(j){let n,$,c,u,_;return u=new R({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForSequenceClassification
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")
model = ORTModelForSequenceClassification.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")

outputs = model(**inputs)
logits = outputs.logits
list(logits.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSequenceClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(logits.shape)`}}),{c(){n=r("p"),$=m("Example of single-label classification:"),c=h(),v(u.$$.fragment)},l(s){n=a(s,"P",{});var l=i(n);$=p(l,"Example of single-label classification:"),l.forEach(o),c=f(s),T(u.$$.fragment,s)},m(s,l){k(s,n,l),e(n,$),k(s,c,l),b(u,s,l),_=!0},p:C,i(s){_||(M(u.$$.fragment,s),_=!0)},o(s){O(u.$$.fragment,s),_=!1},d(s){s&&o(n),s&&o(c),q(u,s)}}}function Vp(j){let n,$,c,u,_,s,l,x;return l=new R({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForSequenceClassification

tokenizer = AutoTokenizer.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")
model = ORTModelForSequenceClassification.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")
onnx_classifier = pipeline("text-classification", model=model, tokenizer=tokenizer)

text = "Hello, my dog is cute"
pred = onnx_classifier(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_classifier = pipeline(<span class="hljs-string">&quot;text-classification&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_classifier(text)`}}),{c(){n=r("p"),$=m("Example using "),c=r("code"),u=m("transformers.pipelines"),_=m(":"),s=h(),v(l.$$.fragment)},l(d){n=a(d,"P",{});var w=i(n);$=p(w,"Example using "),c=a(w,"CODE",{});var E=i(c);u=p(E,"transformers.pipelines"),E.forEach(o),_=p(w,":"),w.forEach(o),s=f(d),T(l.$$.fragment,d)},m(d,w){k(d,n,w),e(n,$),e(n,c),e(c,u),e(n,_),k(d,s,w),b(l,d,w),x=!0},p:C,i(d){x||(M(l.$$.fragment,d),x=!0)},o(d){O(l.$$.fragment,d),x=!1},d(d){d&&o(n),d&&o(s),q(l,d)}}}function Up(j){let n,$,c,u,_,s,l,x;return l=new R({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForSequenceClassification

tokenizer = AutoTokenizer.from_pretrained("optimum/distilbert-base-uncased-mnli")
model = ORTModelForSequenceClassification.from_pretrained("optimum/distilbert-base-uncased-mnli")
onnx_z0 = pipeline("zero-shot-classification", model=model, tokenizer=tokenizer)

sequence_to_classify = "Who are you voting for in 2020?"
candidate_labels = ["Europe", "public health", "politics", "elections"]
pred = onnx_z0(sequence_to_classify, candidate_labels, multi_class=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-mnli&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-mnli&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_z0 = pipeline(<span class="hljs-string">&quot;zero-shot-classification&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>sequence_to_classify = <span class="hljs-string">&quot;Who are you voting for in 2020?&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>candidate_labels = [<span class="hljs-string">&quot;Europe&quot;</span>, <span class="hljs-string">&quot;public health&quot;</span>, <span class="hljs-string">&quot;politics&quot;</span>, <span class="hljs-string">&quot;elections&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_z0(sequence_to_classify, candidate_labels, multi_class=<span class="hljs-literal">True</span>)`}}),{c(){n=r("p"),$=m("Example using zero-shot-classification "),c=r("code"),u=m("transformers.pipelines"),_=m(":"),s=h(),v(l.$$.fragment)},l(d){n=a(d,"P",{});var w=i(n);$=p(w,"Example using zero-shot-classification "),c=a(w,"CODE",{});var E=i(c);u=p(E,"transformers.pipelines"),E.forEach(o),_=p(w,":"),w.forEach(o),s=f(d),T(l.$$.fragment,d)},m(d,w){k(d,n,w),e(n,$),e(n,c),e(c,u),e(n,_),k(d,s,w),b(l,d,w),x=!0},p:C,i(d){x||(M(l.$$.fragment,d),x=!0)},o(d){O(l.$$.fragment,d),x=!1},d(d){d&&o(n),d&&o(s),q(l,d)}}}function Gp(j){let n,$,c,u,_;return{c(){n=r("p"),$=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),c=r("code"),u=m("Module"),_=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(s){n=a(s,"P",{});var l=i(n);$=p(l,"Although the recipe for forward pass needs to be defined within this function, one should call the "),c=a(l,"CODE",{});var x=i(c);u=p(x,"Module"),x.forEach(o),_=p(l,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),l.forEach(o)},m(s,l){k(s,n,l),e(n,$),e(n,c),e(c,u),e(n,_)},d(s){s&&o(n)}}}function Jp(j){let n,$,c,u,_;return u=new R({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForTokenClassification
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/bert-base-NER")
model = ORTModelForTokenClassification.from_pretrained("optimum/bert-base-NER")

inputs = tokenizer("My name is Philipp and I live in Germany.", return_tensors="pt")

outputs = model(**inputs)
logits = outputs.logits
list(logits.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForTokenClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(logits.shape)`}}),{c(){n=r("p"),$=m("Example of token classification:"),c=h(),v(u.$$.fragment)},l(s){n=a(s,"P",{});var l=i(n);$=p(l,"Example of token classification:"),l.forEach(o),c=f(s),T(u.$$.fragment,s)},m(s,l){k(s,n,l),e(n,$),k(s,c,l),b(u,s,l),_=!0},p:C,i(s){_||(M(u.$$.fragment,s),_=!0)},o(s){O(u.$$.fragment,s),_=!1},d(s){s&&o(n),s&&o(c),q(u,s)}}}function Kp(j){let n,$,c,u,_,s,l,x;return l=new R({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForTokenClassification

tokenizer = AutoTokenizer.from_pretrained("optimum/bert-base-NER")
model = ORTModelForTokenClassification.from_pretrained("optimum/bert-base-NER")
onnx_ner = pipeline("token-classification", model=model, tokenizer=tokenizer)

text = "My name is Philipp and I live in Germany."
pred = onnx_ner(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForTokenClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_ner = pipeline(<span class="hljs-string">&quot;token-classification&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_ner(text)`}}),{c(){n=r("p"),$=m("Example using "),c=r("code"),u=m("transformers.pipelines"),_=m(":"),s=h(),v(l.$$.fragment)},l(d){n=a(d,"P",{});var w=i(n);$=p(w,"Example using "),c=a(w,"CODE",{});var E=i(c);u=p(E,"transformers.pipelines"),E.forEach(o),_=p(w,":"),w.forEach(o),s=f(d),T(l.$$.fragment,d)},m(d,w){k(d,n,w),e(n,$),e(n,c),e(c,u),e(n,_),k(d,s,w),b(l,d,w),x=!0},p:C,i(d){x||(M(l.$$.fragment,d),x=!0)},o(d){O(l.$$.fragment,d),x=!1},d(d){d&&o(n),d&&o(s),q(l,d)}}}function Yp(j){let n,$,c,u,_;return{c(){n=r("p"),$=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),c=r("code"),u=m("Module"),_=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(s){n=a(s,"P",{});var l=i(n);$=p(l,"Although the recipe for forward pass needs to be defined within this function, one should call the "),c=a(l,"CODE",{});var x=i(c);u=p(x,"Module"),x.forEach(o),_=p(l,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),l.forEach(o)},m(s,l){k(s,n,l),e(n,$),e(n,c),e(c,u),e(n,_)},d(s){s&&o(n)}}}function Zp(j){let n,$,c,u,_;return u=new R({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForCausalLM
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/gpt2")
model = ORTModelForCausalLM.from_pretrained("optimum/gpt2")

inputs = tokenizer("My name is Philipp and I live in Germany.", return_tensors="pt")

gen_tokens = model.generate(**inputs,do_sample=True,temperature=0.9, min_length=20,max_length=20)
tokenizer.batch_decode(gen_tokens)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForCausalLM
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/gpt2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForCausalLM.from_pretrained(<span class="hljs-string">&quot;optimum/gpt2&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>gen_tokens = model.generate(**inputs,do_sample=<span class="hljs-literal">True</span>,temperature=<span class="hljs-number">0.9</span>, min_length=<span class="hljs-number">20</span>,max_length=<span class="hljs-number">20</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.batch_decode(gen_tokens)`}}),{c(){n=r("p"),$=m("Example of text generation:"),c=h(),v(u.$$.fragment)},l(s){n=a(s,"P",{});var l=i(n);$=p(l,"Example of text generation:"),l.forEach(o),c=f(s),T(u.$$.fragment,s)},m(s,l){k(s,n,l),e(n,$),k(s,c,l),b(u,s,l),_=!0},p:C,i(s){_||(M(u.$$.fragment,s),_=!0)},o(s){O(u.$$.fragment,s),_=!1},d(s){s&&o(n),s&&o(c),q(u,s)}}}function ed(j){let n,$,c,u,_,s,l,x;return l=new R({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForCausalLM

tokenizer = AutoTokenizer.from_pretrained("optimum/gpt2")
model = ORTModelForCausalLM.from_pretrained("optimum/gpt2")
onnx_gen = pipeline("text-generation", model=model, tokenizer=tokenizer)

text = "My name is Philipp and I live in Germany."
gen = onnx_gen(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForCausalLM

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/gpt2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForCausalLM.from_pretrained(<span class="hljs-string">&quot;optimum/gpt2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_gen = pipeline(<span class="hljs-string">&quot;text-generation&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>gen = onnx_gen(text)`}}),{c(){n=r("p"),$=m("Example using "),c=r("code"),u=m("transformers.pipelines"),_=m(":"),s=h(),v(l.$$.fragment)},l(d){n=a(d,"P",{});var w=i(n);$=p(w,"Example using "),c=a(w,"CODE",{});var E=i(c);u=p(E,"transformers.pipelines"),E.forEach(o),_=p(w,":"),w.forEach(o),s=f(d),T(l.$$.fragment,d)},m(d,w){k(d,n,w),e(n,$),e(n,c),e(c,u),e(n,_),k(d,s,w),b(l,d,w),x=!0},p:C,i(d){x||(M(l.$$.fragment,d),x=!0)},o(d){O(l.$$.fragment,d),x=!1},d(d){d&&o(n),d&&o(s),q(l,d)}}}function td(j){let n,$,c,u,_;return{c(){n=r("p"),$=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),c=r("code"),u=m("Module"),_=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(s){n=a(s,"P",{});var l=i(n);$=p(l,"Although the recipe for forward pass needs to be defined within this function, one should call the "),c=a(l,"CODE",{});var x=i(c);u=p(x,"Module"),x.forEach(o),_=p(l,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),l.forEach(o)},m(s,l){k(s,n,l),e(n,$),e(n,c),e(c,u),e(n,_)},d(s){s&&o(n)}}}function od(j){let n,$,c,u,_;return u=new R({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForSeq2SeqLM

tokenizer = AutoTokenizer.from_pretrained("optimum/t5-small")
model = ORTModelForSeq2SeqLM.from_pretrained("optimum/t5-small")

inputs = tokenizer("My name is Eustache and I like to", return_tensors="pt")

gen_tokens = model.generate(**inputs)
outputs = tokenizer.batch_decode(gen_tokens)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSeq2SeqLM

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/t5-small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSeq2SeqLM.from_pretrained(<span class="hljs-string">&quot;optimum/t5-small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;My name is Eustache and I like to&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>gen_tokens = model.generate(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = tokenizer.batch_decode(gen_tokens)`}}),{c(){n=r("p"),$=m("Example of text generation:"),c=h(),v(u.$$.fragment)},l(s){n=a(s,"P",{});var l=i(n);$=p(l,"Example of text generation:"),l.forEach(o),c=f(s),T(u.$$.fragment,s)},m(s,l){k(s,n,l),e(n,$),k(s,c,l),b(u,s,l),_=!0},p:C,i(s){_||(M(u.$$.fragment,s),_=!0)},o(s){O(u.$$.fragment,s),_=!1},d(s){s&&o(n),s&&o(c),q(u,s)}}}function nd(j){let n,$,c,u,_,s,l,x;return l=new R({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForSeq2SeqLM

tokenizer = AutoTokenizer.from_pretrained("optimum/t5-small")
model = ORTModelForSeq2SeqLM.from_pretrained("optimum/t5-small")
onnx_translation = pipeline("translation_en_to_de", model=model, tokenizer=tokenizer)

text = "My name is Eustache."
pred = onnx_translation(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSeq2SeqLM

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/t5-small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSeq2SeqLM.from_pretrained(<span class="hljs-string">&quot;optimum/t5-small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_translation = pipeline(<span class="hljs-string">&quot;translation_en_to_de&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;My name is Eustache.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_translation(text)`}}),{c(){n=r("p"),$=m("Example using "),c=r("code"),u=m("transformers.pipeline"),_=m(":"),s=h(),v(l.$$.fragment)},l(d){n=a(d,"P",{});var w=i(n);$=p(w,"Example using "),c=a(w,"CODE",{});var E=i(c);u=p(E,"transformers.pipeline"),E.forEach(o),_=p(w,":"),w.forEach(o),s=f(d),T(l.$$.fragment,d)},m(d,w){k(d,n,w),e(n,$),e(n,c),e(c,u),e(n,_),k(d,s,w),b(l,d,w),x=!0},p:C,i(d){x||(M(l.$$.fragment,d),x=!0)},o(d){O(l.$$.fragment,d),x=!1},d(d){d&&o(n),d&&o(s),q(l,d)}}}function sd(j){let n,$,c,u,_;return{c(){n=r("p"),$=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),c=r("code"),u=m("Module"),_=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(s){n=a(s,"P",{});var l=i(n);$=p(l,"Although the recipe for forward pass needs to be defined within this function, one should call the "),c=a(l,"CODE",{});var x=i(c);u=p(x,"Module"),x.forEach(o),_=p(l,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),l.forEach(o)},m(s,l){k(s,n,l),e(n,$),e(n,c),e(c,u),e(n,_)},d(s){s&&o(n)}}}function rd(j){let n,$,c,u,_;return u=new R({props:{code:`import requests
from PIL import Image
from optimum.onnxruntime import ORTModelForImageClassification
from transformers import AutoFeatureExtractor

url = "http://images.cocodataset.org/val2017/000000039769.jpg"
image = Image.open(requests.get(url, stream=True).raw)

preprocessor = AutoFeatureExtractor.from_pretrained("optimum/vit-base-patch16-224")
model = ORTModelForImageClassification.from_pretrained("optimum/vit-base-patch16-224")

inputs = preprocessor(images=image, return_tensors="pt")

outputs = model(**inputs)
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> requests
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForImageClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoFeatureExtractor

<span class="hljs-meta">&gt;&gt;&gt; </span>url = <span class="hljs-string">&quot;http://images.cocodataset.org/val2017/000000039769.jpg&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>image = Image.<span class="hljs-built_in">open</span>(requests.get(url, stream=<span class="hljs-literal">True</span>).raw)

<span class="hljs-meta">&gt;&gt;&gt; </span>preprocessor = AutoFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;optimum/vit-base-patch16-224&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForImageClassification.from_pretrained(<span class="hljs-string">&quot;optimum/vit-base-patch16-224&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = preprocessor(images=image, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),{c(){n=r("p"),$=m("Example of image classification:"),c=h(),v(u.$$.fragment)},l(s){n=a(s,"P",{});var l=i(n);$=p(l,"Example of image classification:"),l.forEach(o),c=f(s),T(u.$$.fragment,s)},m(s,l){k(s,n,l),e(n,$),k(s,c,l),b(u,s,l),_=!0},p:C,i(s){_||(M(u.$$.fragment,s),_=!0)},o(s){O(u.$$.fragment,s),_=!1},d(s){s&&o(n),s&&o(c),q(u,s)}}}function ad(j){let n,$,c,u,_,s,l,x;return l=new R({props:{code:`import requests
from PIL import Image
from transformers import AutoFeatureExtractor, pipeline
from optimum.onnxruntime import ORTModelForImageClassification

preprocessor = AutoFeatureExtractor.from_pretrained("optimum/vit-base-patch16-224")
model = ORTModelForImageClassification.from_pretrained("optimum/vit-base-patch16-224")
onnx_image_classifier = pipeline("image-classification", model=model, feature_extractor=preprocessor)

url = "http://images.cocodataset.org/val2017/000000039769.jpg"
pred = onnx_image_classifier(url)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> requests
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoFeatureExtractor, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForImageClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>preprocessor = AutoFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;optimum/vit-base-patch16-224&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForImageClassification.from_pretrained(<span class="hljs-string">&quot;optimum/vit-base-patch16-224&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_image_classifier = pipeline(<span class="hljs-string">&quot;image-classification&quot;</span>, model=model, feature_extractor=preprocessor)

<span class="hljs-meta">&gt;&gt;&gt; </span>url = <span class="hljs-string">&quot;http://images.cocodataset.org/val2017/000000039769.jpg&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_image_classifier(url)`}}),{c(){n=r("p"),$=m("Example using "),c=r("code"),u=m("transformers.pipeline"),_=m(":"),s=h(),v(l.$$.fragment)},l(d){n=a(d,"P",{});var w=i(n);$=p(w,"Example using "),c=a(w,"CODE",{});var E=i(c);u=p(E,"transformers.pipeline"),E.forEach(o),_=p(w,":"),w.forEach(o),s=f(d),T(l.$$.fragment,d)},m(d,w){k(d,n,w),e(n,$),e(n,c),e(c,u),e(n,_),k(d,s,w),b(l,d,w),x=!0},p:C,i(d){x||(M(l.$$.fragment,d),x=!0)},o(d){O(l.$$.fragment,d),x=!1},d(d){d&&o(n),d&&o(s),q(l,d)}}}function id(j){let n,$,c,u,_;return{c(){n=r("p"),$=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),c=r("code"),u=m("Module"),_=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(s){n=a(s,"P",{});var l=i(n);$=p(l,"Although the recipe for forward pass needs to be defined within this function, one should call the "),c=a(l,"CODE",{});var x=i(c);u=p(x,"Module"),x.forEach(o),_=p(l,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),l.forEach(o)},m(s,l){k(s,n,l),e(n,$),e(n,c),e(c,u),e(n,_)},d(s){s&&o(n)}}}function ld(j){let n,$,c,u,_,s,l,x;return l=new R({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForCustomTasks

tokenizer = AutoTokenizer.from_pretrained("optimum/sbert-all-MiniLM-L6-with-pooler")
model = ORTModelForCustomTasks.from_pretrained("optimum/sbert-all-MiniLM-L6-with-pooler")

inputs = tokenizer("I love burritos!", return_tensors="pt")

outputs = model(**inputs)
last_hidden_state = outputs.last_hidden_state
pooler_output = outputs.pooler_output`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForCustomTasks

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/sbert-all-MiniLM-L6-with-pooler&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForCustomTasks.from_pretrained(<span class="hljs-string">&quot;optimum/sbert-all-MiniLM-L6-with-pooler&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;I love burritos!&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_state = outputs.last_hidden_state
<span class="hljs-meta">&gt;&gt;&gt; </span>pooler_output = outputs.pooler_output`}}),{c(){n=r("p"),$=m("Example of custom tasks(e.g. a sentence transformers taking "),c=r("code"),u=m("pooler_output"),_=m(" as output):"),s=h(),v(l.$$.fragment)},l(d){n=a(d,"P",{});var w=i(n);$=p(w,"Example of custom tasks(e.g. a sentence transformers taking "),c=a(w,"CODE",{});var E=i(c);u=p(E,"pooler_output"),E.forEach(o),_=p(w," as output):"),w.forEach(o),s=f(d),T(l.$$.fragment,d)},m(d,w){k(d,n,w),e(n,$),e(n,c),e(c,u),e(n,_),k(d,s,w),b(l,d,w),x=!0},p:C,i(d){x||(M(l.$$.fragment,d),x=!0)},o(d){O(l.$$.fragment,d),x=!1},d(d){d&&o(n),d&&o(s),q(l,d)}}}function md(j){let n,$,c,u,_,s,l,x;return l=new R({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForCustomTasks

tokenizer = AutoTokenizer.from_pretrained("optimum/sbert-all-MiniLM-L6-with-pooler")
model = ORTModelForCustomTasks.from_pretrained("optimum/sbert-all-MiniLM-L6-with-pooler")
onnx_extractor = pipeline("feature-extraction", model=model, tokenizer=tokenizer)

text = "I love burritos!"
pred = onnx_extractor(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForCustomTasks

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/sbert-all-MiniLM-L6-with-pooler&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForCustomTasks.from_pretrained(<span class="hljs-string">&quot;optimum/sbert-all-MiniLM-L6-with-pooler&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_extractor = pipeline(<span class="hljs-string">&quot;feature-extraction&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;I love burritos!&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_extractor(text)`}}),{c(){n=r("p"),$=m("Example using "),c=r("code"),u=m("transformers.pipelines"),_=m("(only if the task is supported):"),s=h(),v(l.$$.fragment)},l(d){n=a(d,"P",{});var w=i(n);$=p(w,"Example using "),c=a(w,"CODE",{});var E=i(c);u=p(E,"transformers.pipelines"),E.forEach(o),_=p(w,"(only if the task is supported):"),w.forEach(o),s=f(d),T(l.$$.fragment,d)},m(d,w){k(d,n,w),e(n,$),e(n,c),e(c,u),e(n,_),k(d,s,w),b(l,d,w),x=!0},p:C,i(d){x||(M(l.$$.fragment,d),x=!0)},o(d){O(l.$$.fragment,d),x=!1},d(d){d&&o(n),d&&o(s),q(l,d)}}}function pd(j){let n,$,c,u,_,s,l,x,d,w,E,vr,Oo,Tr,br,bs,xe,He,No,jt,Mr,Io,Or,Ms,Q,qr,Lo,yr,jr,Do,Er,Rr,Ho,Fr,zr,Xo,Cr,Ar,Os,Et,qs,se,Sr,Qo,Pr,Nr,Wo,Ir,Lr,ys,Rt,js,ve,Xe,Bo,Ft,Dr,Vo,Hr,Es,ee,Xr,qo,Qr,Wr,zt,Br,Vr,Uo,Ur,Gr,Rs,Ct,Fs,Te,Qe,Go,At,Jr,Jo,Kr,zs,re,Yr,Ko,Zr,ea,Yo,ta,oa,Cs,St,As,be,We,Zo,Pt,na,en,sa,Ss,S,Nt,ra,It,aa,tn,ia,la,ma,Be,Lt,pa,on,da,ca,Ve,Dt,ua,Ht,ha,nn,fa,ga,_a,Ue,Xt,$a,sn,ka,Ps,Me,Ge,rn,Qt,wa,an,xa,Ns,P,Wt,va,ln,Ta,ba,Bt,Ma,mn,Oa,qa,ya,pn,ja,Ea,W,Vt,Ra,Oe,Fa,dn,za,Ca,cn,Aa,Sa,Pa,Je,Na,Ke,Ia,Ye,Is,qe,Ze,un,Ut,La,hn,Da,Ls,N,Gt,Ha,fn,Xa,Qa,Jt,Wa,gn,Ba,Va,Ua,_n,Ga,Ja,B,Kt,Ka,ye,Ya,$n,Za,ei,kn,ti,oi,ni,et,si,tt,ri,ot,Ds,je,nt,wn,Yt,ai,xn,ii,Hs,I,Zt,li,vn,mi,pi,eo,di,Tn,ci,ui,hi,bn,fi,gi,A,to,_i,Ee,$i,Mn,ki,wi,On,xi,vi,Ti,st,bi,rt,Mi,at,Oi,it,Xs,Re,lt,qn,oo,qi,yn,yi,Qs,L,no,ji,jn,Ei,Ri,so,Fi,En,zi,Ci,Ai,Rn,Si,Pi,V,ro,Ni,Fe,Ii,Fn,Li,Di,zn,Hi,Xi,Qi,mt,Wi,pt,Bi,dt,Ws,ze,ct,Cn,ao,Vi,An,Ui,Bs,D,io,Gi,Sn,Ji,Ki,lo,Yi,Pn,Zi,el,tl,Nn,ol,nl,U,mo,sl,Ce,rl,In,al,il,Ln,ll,ml,pl,ut,dl,ht,cl,ft,Vs,Ae,gt,Dn,po,ul,Hn,hl,Us,oe,co,fl,Xn,gl,_l,G,uo,$l,Se,kl,Qn,wl,xl,Wn,vl,Tl,bl,_t,Ml,$t,Ol,kt,Gs,Pe,wt,Bn,ho,ql,Vn,yl,Js,H,fo,jl,Un,El,Rl,go,Fl,Gn,zl,Cl,Al,Jn,Sl,Pl,J,_o,Nl,Ne,Il,Kn,Ll,Dl,Yn,Hl,Xl,Ql,xt,Wl,vt,Bl,Tt,Ks,Ie,bt,Zn,$o,Vl,es,Ul,Ys,X,ko,Gl,ts,Jl,Kl,wo,Yl,os,Zl,em,tm,ns,om,nm,K,xo,sm,Le,rm,ss,am,im,rs,lm,mm,pm,Mt,dm,Ot,cm,qt,Zs;return s=new Z({}),jt=new Z({}),Et=new R({props:{code:`from transformers import AutoTokenizer, pipeline
-from transformers import AutoModelForQuestionAnswering
+from optimum.onnxruntime import ORTModelForQuestionAnswering

-model = AutoModelForQuestionAnswering.from_pretrained("deepset/roberta-base-squad2") # pytorch checkpoint
+model = ORTModelForQuestionAnswering.from_pretrained("optimum/roberta-base-squad2") # onnx checkpoint
tokenizer = AutoTokenizer.from_pretrained("deepset/roberta-base-squad2")

onnx_qa = pipeline("question-answering",model=model,tokenizer=tokenizer)

question = "What's my name?"
context = "My name is Philipp and I live in Nuremberg."
pred = onnx_qa(question, context)`,highlighted:`from transformers import AutoTokenizer, pipeline
<span class="hljs-deletion">-from transformers import AutoModelForQuestionAnswering</span>
<span class="hljs-addition">+from optimum.onnxruntime import ORTModelForQuestionAnswering</span>

<span class="hljs-deletion">-model = AutoModelForQuestionAnswering.from_pretrained(&quot;deepset/roberta-base-squad2&quot;) # pytorch checkpoint</span>
<span class="hljs-addition">+model = ORTModelForQuestionAnswering.from_pretrained(&quot;optimum/roberta-base-squad2&quot;) # onnx checkpoint</span>
tokenizer = AutoTokenizer.from_pretrained(&quot;deepset/roberta-base-squad2&quot;)

onnx_qa = pipeline(&quot;question-answering&quot;,model=model,tokenizer=tokenizer)

question = &quot;What&#x27;s my name?&quot;
context = &quot;My name is Philipp and I live in Nuremberg.&quot;
pred = onnx_qa(question, context)`}}),Rt=new R({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForSequenceClassification

model = ORTModelForSequenceClassification.from_pretrained("distilbert-base-uncased-finetuned-sst-2-english", from_transformers=True)
tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased-finetuned-sst-2-english")

onnx_classifier = pipeline("text-classification", model=model, tokenizer=tokenizer)

result = onnx_classifier("This is a great model")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSequenceClassification

<span class="hljs-comment"># Load the model from the hub and export it to the ONNX format</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>, from_transformers=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)

<span class="hljs-comment"># Create a pipeline</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_classifier = pipeline(<span class="hljs-string">&quot;text-classification&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>result = onnx_classifier(<span class="hljs-string">&quot;This is a great model&quot;</span>)
[{<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;POSITIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.9998838901519775</span>}]`}}),Ft=new Z({}),Ct=new R({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForSequenceClassification

model = ORTModelForSequenceClassification.from_pretrained("distilbert-base-uncased-finetuned-sst-2-english", from_transformers=True)
tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased-finetuned-sst-2-english")

model.save_pretrained("a_local_path_for_convert_onnx_model")
tokenizer.save_pretrained("a_local_path_for_convert_onnx_model")

model.push_to_hub("a_local_path_for_convert_onnx_model", repository_id="my-onnx-repo", use_auth_token=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSequenceClassification

<span class="hljs-comment"># Load the model from the hub and export it to the ONNX format</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>, from_transformers=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)

<span class="hljs-comment"># Save the converted model</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model.save_pretrained(<span class="hljs-string">&quot;a_local_path_for_convert_onnx_model&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.save_pretrained(<span class="hljs-string">&quot;a_local_path_for_convert_onnx_model&quot;</span>)

<span class="hljs-comment"># Push the onnx model to HF Hub</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model.push_to_hub(<span class="hljs-string">&quot;a_local_path_for_convert_onnx_model&quot;</span>, repository_id=<span class="hljs-string">&quot;my-onnx-repo&quot;</span>, use_auth_token=<span class="hljs-literal">True</span>)`}}),At=new Z({}),St=new R({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForSeq2SeqLM

model = ORTModelForSeq2SeqLM.from_pretrained("t5-small", from_transformers=True)
tokenizer = AutoTokenizer.from_pretrained("t5-small")

onnx_translation = pipeline("translation_en_to_fr", model=model, tokenizer=tokenizer)

result = onnx_translation("My name is Eustache")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSeq2SeqLM

<span class="hljs-comment"># Load the model from the hub and export it to the ONNX format</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSeq2SeqLM.from_pretrained(<span class="hljs-string">&quot;t5-small&quot;</span>, from_transformers=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;t5-small&quot;</span>)

<span class="hljs-comment"># Create a pipeline</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_translation = pipeline(<span class="hljs-string">&quot;translation_en_to_fr&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>result = onnx_translation(<span class="hljs-string">&quot;My name is Eustache&quot;</span>)
[{<span class="hljs-string">&#x27;translation_text&#x27;</span>: <span class="hljs-string">&#x27;Mon nom est Eustache&#x27;</span>}]`}}),Pt=new Z({}),Nt=new F({props:{name:"class optimum.onnxruntime.ORTModel",anchor:"optimum.onnxruntime.ORTModel",parameters:[{name:"model",val:": InferenceSession = None"},{name:"config",val:" = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_ort.py#L106"}}),Lt=new F({props:{name:"from_pretrained",anchor:"optimum.onnxruntime.ORTModel.from_pretrained",parameters:[{name:"model_id",val:": typing.Union[str, pathlib.Path]"},{name:"from_transformers",val:": bool = False"},{name:"force_download",val:": bool = True"},{name:"use_auth_token",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Optional[str] = None"},{name:"provider",val:": typing.Union[str, typing.List[str]] = 'CPUExecutionProvider'"},{name:"session_options",val:": SessionOptions = None"},{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModel.from_pretrained.model_id",description:`<strong>model_id</strong> (<code>Union[str, Path]</code>) &#x2014;
Can be either:</p>
<ul>
<li>A string, the <em>model id</em> of a pretrained model hosted inside a model repo on huggingface.co.
Valid model ids can be located at the root-level, like <code>bert-base-uncased</code>, or namespaced under a
user or organization name, like <code>dbmdz/bert-base-german-cased</code>.</li>
<li>A path to a <em>directory</em> containing a model saved using <code>save_pretrained</code>,
e.g., <code>./my_model_directory/</code>.</li>
</ul>`,name:"model_id"},{anchor:"optimum.onnxruntime.ORTModel.from_pretrained.from_transformers",description:`<strong>from_transformers</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Defines whether the provided <code>model_id</code> contains a vanilla Transformers checkpoint.`,name:"from_transformers"},{anchor:"optimum.onnxruntime.ORTModel.from_pretrained.force_download",description:`<strong>force_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to force the (re-)download of the model weights and configuration files, overriding the
cached versions if they exist.`,name:"force_download"},{anchor:"optimum.onnxruntime.ORTModel.from_pretrained.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
The token to use as HTTP bearer authorization for remote files. If <code>True</code>, will use the token generated
when running <code>transformers-cli login</code> (stored in <code>~/.huggingface</code>).`,name:"use_auth_token"},{anchor:"optimum.onnxruntime.ORTModel.from_pretrained.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Path to a directory in which a downloaded pretrained model configuration should be cached if the
standard cache should not be used.`,name:"cache_dir"},{anchor:"optimum.onnxruntime.ORTModel.from_pretrained.local_files_only(bool,",description:`<strong>local_files_only(<code>bool</code>,</strong> <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to only look at local files (i.e., do not try to download the model).`,name:"local_files_only(bool,"},{anchor:"optimum.onnxruntime.ORTModel.from_pretrained.provider",description:`<strong>provider</strong> (<code>str</code> or <code>List[str]</code>, <em>optional</em>) &#x2014;
ONNX Runtime providers to use for loading the model. This can either be a single provider given as a string (for example
<code>CUDAExecutionProvider</code>) or a list of execution providers to use in priority order.
See <a href="https://onnxruntime.ai/docs/execution-providers/" rel="nofollow">https://onnxruntime.ai/docs/execution-providers/</a> for more details. Defaults to <code>CPUExecutionProvider</code>.`,name:"provider"},{anchor:"optimum.onnxruntime.ORTModel.from_pretrained.session_options",description:`<strong>session_options</strong> (<code>onnxruntime.SessionOptions</code>, <em>optional</em>), &#x2014;
ONNX Runtime session options to use for loading the model. Defaults to <code>None</code>.`,name:"session_options"}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_ort.py#L208",returnDescription:`
<p>The loaded ORTModel model.</p>
`,returnType:`
<p><code>ORTModel</code></p>
`}}),Dt=new F({props:{name:"load_model",anchor:"optimum.onnxruntime.ORTModel.load_model",parameters:[{name:"path",val:": typing.Union[str, pathlib.Path]"},{name:"provider",val:": typing.Union[str, typing.List[str], NoneType] = 'CPUExecutionProvider'"},{name:"session_options",val:": typing.Optional[onnxruntime.capi.onnxruntime_pybind11_state.SessionOptions] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModel.load_model.path",description:`<strong>path</strong> (<code>str</code> or <code>Path</code>) &#x2014;
Directory from which to load the model.`,name:"path"},{anchor:"optimum.onnxruntime.ORTModel.load_model.provider",description:`<strong>provider</strong> (<code>str</code> or <code>List[str]</code>, <em>optional</em>) &#x2014;
ONNX Runtime providers to use for loading the model. This can either be a single provider given as a string (for example
<code>CUDAExecutionProvider</code>) or a list of execution providers to use in priority order.
See <a href="https://onnxruntime.ai/docs/execution-providers/" rel="nofollow">https://onnxruntime.ai/docs/execution-providers/</a> for more details. Defaults to <code>CPUExecutionProvider</code>.`,name:"provider"},{anchor:"optimum.onnxruntime.ORTModel.load_model.session_options",description:`<strong>session_options</strong> (<code>onnxruntime.SessionOptions</code>, <em>optional</em>), &#x2014;
ONNX Runtime session options to use for loading the model. Defaults to <code>None</code>.`,name:"session_options"}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_ort.py#L158"}}),Xt=new F({props:{name:"to",anchor:"optimum.onnxruntime.ORTModel.to",parameters:[{name:"device",val:": device"}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_ort.py#L141"}}),Qt=new Z({}),Wt=new F({props:{name:"class optimum.onnxruntime.ORTModelForFeatureExtraction",anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/optimum/pr_271/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/pr_271/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_ort.py#L414"}}),Vt=new F({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_ort.py#L428"}}),Je=new yt({props:{$$slots:{default:[Ip]},$$scope:{ctx:j}}}),Ke=new z({props:{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward.example",$$slots:{default:[Lp]},$$scope:{ctx:j}}}),Ye=new z({props:{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward.example-2",$$slots:{default:[Dp]},$$scope:{ctx:j}}}),Ut=new Z({}),Gt=new F({props:{name:"class optimum.onnxruntime.ORTModelForQuestionAnswering",anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/optimum/pr_271/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/pr_271/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_ort.py#L499"}}),Kt=new F({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_ort.py#L513"}}),et=new yt({props:{$$slots:{default:[Hp]},$$scope:{ctx:j}}}),tt=new z({props:{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward.example",$$slots:{default:[Xp]},$$scope:{ctx:j}}}),ot=new z({props:{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward.example-2",$$slots:{default:[Qp]},$$scope:{ctx:j}}}),Yt=new Z({}),Zt=new F({props:{name:"class optimum.onnxruntime.ORTModelForSequenceClassification",anchor:"optimum.onnxruntime.ORTModelForSequenceClassification",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/optimum/pr_271/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/pr_271/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_ort.py#L599"}}),to=new F({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_ort.py#L614"}}),st=new yt({props:{$$slots:{default:[Wp]},$$scope:{ctx:j}}}),rt=new z({props:{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.example",$$slots:{default:[Bp]},$$scope:{ctx:j}}}),at=new z({props:{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.example-2",$$slots:{default:[Vp]},$$scope:{ctx:j}}}),it=new z({props:{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.example-3",$$slots:{default:[Up]},$$scope:{ctx:j}}}),oo=new Z({}),no=new F({props:{name:"class optimum.onnxruntime.ORTModelForTokenClassification",anchor:"optimum.onnxruntime.ORTModelForTokenClassification",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/optimum/pr_271/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/pr_271/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_ort.py#L685"}}),ro=new F({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_ort.py#L699"}}),mt=new yt({props:{$$slots:{default:[Gp]},$$scope:{ctx:j}}}),pt=new z({props:{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward.example",$$slots:{default:[Jp]},$$scope:{ctx:j}}}),dt=new z({props:{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward.example-2",$$slots:{default:[Kp]},$$scope:{ctx:j}}}),ao=new Z({}),io=new F({props:{name:"class optimum.onnxruntime.ORTModelForCausalLM",anchor:"optimum.onnxruntime.ORTModelForCausalLM",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForCausalLM.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/optimum/pr_271/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForCausalLM.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/pr_271/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_ort.py#L848"}}),mo=new F({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForCausalLM.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForCausalLM.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForCausalLM.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForCausalLM.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_ort.py#L872"}}),ut=new yt({props:{$$slots:{default:[Yp]},$$scope:{ctx:j}}}),ht=new z({props:{anchor:"optimum.onnxruntime.ORTModelForCausalLM.forward.example",$$slots:{default:[Zp]},$$scope:{ctx:j}}}),ft=new z({props:{anchor:"optimum.onnxruntime.ORTModelForCausalLM.forward.example-2",$$slots:{default:[ed]},$$scope:{ctx:j}}}),po=new Z({}),co=new F({props:{name:"class optimum.onnxruntime.ORTModelForSeq2SeqLM",anchor:"optimum.onnxruntime.ORTModelForSeq2SeqLM",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_seq2seq.py#L584"}}),uo=new F({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForSeq2SeqLM.forward",parameters:[{name:"input_ids",val:": LongTensor = None"},{name:"attention_mask",val:": typing.Optional[torch.FloatTensor] = None"},{name:"decoder_input_ids",val:": typing.Optional[torch.LongTensor] = None"},{name:"encoder_outputs",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.Tensor]]] = None"},{name:"past_key_values",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.Tensor]]] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForSeq2SeqLM.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code>) &#x2014;
Indices of input sequence tokens in the vocabulary of shape <code>(batch_size, encoder_sequence_length)</code>.`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForSeq2SeqLM.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.LongTensor</code>) &#x2014;
Mask to avoid performing attention on padding token indices, of shape
<code>(batch_size, encoder_sequence_length)</code>. Mask values selected in <code>[0, 1]</code>.`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForSeq2SeqLM.forward.decoder_input_ids",description:`<strong>decoder_input_ids</strong> (<code>torch.LongTensor</code>) &#x2014;
Indices of decoder input sequence tokens in the vocabulary of shape <code>(batch_size, decoder_sequence_length)</code>.`,name:"decoder_input_ids"},{anchor:"optimum.onnxruntime.ORTModelForSeq2SeqLM.forward.encoder_outputs",description:`<strong>encoder_outputs</strong> (<code>torch.FloatTensor</code>) &#x2014;
The encoder <code>last_hidden_state</code> of shape <code>(batch_size, encoder_sequence_length, hidden_size)</code>.`,name:"encoder_outputs"},{anchor:"optimum.onnxruntime.ORTModelForSeq2SeqLM.forward.past_key_values",description:`<strong>past_key_values</strong> (<code>tuple(tuple(torch.FloatTensor), *optional*)</code> &#x2014;
Contains the precomputed key and value hidden states of the attention blocks used to speed up decoding.
The tuple is of length <code>config.n_layers</code> with each tuple having 2 tensors of shape
<code>(batch_size, num_heads, decoder_sequence_length, embed_size_per_head)</code> and 2 additional tensors of shape
<code>(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)</code>.`,name:"past_key_values"}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_seq2seq.py#L593"}}),_t=new yt({props:{$$slots:{default:[td]},$$scope:{ctx:j}}}),$t=new z({props:{anchor:"optimum.onnxruntime.ORTModelForSeq2SeqLM.forward.example",$$slots:{default:[od]},$$scope:{ctx:j}}}),kt=new z({props:{anchor:"optimum.onnxruntime.ORTModelForSeq2SeqLM.forward.example-2",$$slots:{default:[nd]},$$scope:{ctx:j}}}),ho=new Z({}),fo=new F({props:{name:"class optimum.onnxruntime.ORTModelForImageClassification",anchor:"optimum.onnxruntime.ORTModelForImageClassification",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForImageClassification.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/optimum/pr_271/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForImageClassification.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/pr_271/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_ort.py#L966"}}),_o=new F({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForImageClassification.forward",parameters:[{name:"pixel_values",val:": Tensor"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForImageClassification.forward.pixel_values",description:`<strong>pixel_values</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values corresponding to the images in the current batch.
Pixel values can be obtained from encoded images using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autofeatureextractor" rel="nofollow"><code>AutoFeatureExtractor</code></a>.`,name:"pixel_values"}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_ort.py#L980"}}),xt=new yt({props:{$$slots:{default:[sd]},$$scope:{ctx:j}}}),vt=new z({props:{anchor:"optimum.onnxruntime.ORTModelForImageClassification.forward.example",$$slots:{default:[rd]},$$scope:{ctx:j}}}),Tt=new z({props:{anchor:"optimum.onnxruntime.ORTModelForImageClassification.forward.example-2",$$slots:{default:[ad]},$$scope:{ctx:j}}}),$o=new Z({}),ko=new F({props:{name:"class optimum.onnxruntime.ORTModelForCustomTasks",anchor:"optimum.onnxruntime.ORTModelForCustomTasks",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForCustomTasks.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/optimum/pr_271/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForCustomTasks.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/pr_271/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_ort.py#L1044"}}),xo=new F({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForCustomTasks.forward",parameters:[{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/vr_271/src/optimum/onnxruntime/modeling_ort.py#L1054"}}),Mt=new yt({props:{$$slots:{default:[id]},$$scope:{ctx:j}}}),Ot=new z({props:{anchor:"optimum.onnxruntime.ORTModelForCustomTasks.forward.example",$$slots:{default:[ld]},$$scope:{ctx:j}}}),qt=new z({props:{anchor:"optimum.onnxruntime.ORTModelForCustomTasks.forward.example-2",$$slots:{default:[md]},$$scope:{ctx:j}}}),{c(){n=r("meta"),$=h(),c=r("h1"),u=r("a"),_=r("span"),v(s.$$.fragment),l=h(),x=r("span"),d=m("Optimum Inference with ONNX Runtime"),w=h(),E=r("p"),vr=m(`Optimum is a utility package for building and running inference with accelerated runtime like ONNX Runtime.
Optimum can be used to load optimized models from the `),Oo=r("a"),Tr=m("Hugging Face Hub"),br=m(` and create pipelines
to run accelerated inference without rewriting your APIs.`),bs=h(),xe=r("h2"),He=r("a"),No=r("span"),v(jt.$$.fragment),Mr=h(),Io=r("span"),Or=m("Switching from Transformers to Optimum Inference"),Ms=h(),Q=r("p"),qr=m("The Optimum Inference models are API compatible with Hugging Face Transformers models. This means you can just replace your "),Lo=r("code"),yr=m("AutoModelForXxx"),jr=m(" class with the corresponding "),Do=r("code"),Er=m("ORTModelForXxx"),Rr=m(" class in "),Ho=r("code"),Fr=m("optimum"),zr=m(". For example, this is how you can use a question answering model in "),Xo=r("code"),Cr=m("optimum"),Ar=m(":"),Os=h(),v(Et.$$.fragment),qs=h(),se=r("p"),Sr=m("Optimum Inference also includes methods to convert vanilla Transformers models to optimized ones. Simply pass "),Qo=r("code"),Pr=m("from_transformers=True"),Nr=m(" to the "),Wo=r("code"),Ir=m("from_pretrained()"),Lr=m(" method, and your model will be loaded and converted to ONNX on-the-fly:"),ys=h(),v(Rt.$$.fragment),js=h(),ve=r("h3"),Xe=r("a"),Bo=r("span"),v(Ft.$$.fragment),Dr=h(),Vo=r("span"),Hr=m("Working with the Hugging Face Model Hub"),Es=h(),ee=r("p"),Xr=m("The Optimum model classes like "),qo=r("a"),Qr=m("ORTModelForSequenceClassification"),Wr=m(" are integrated with the "),zt=r("a"),Br=m("Hugging Face Model Hub"),Vr=m(`, which means you can not only
load model from the Hub, but also push your models to the Hub with `),Uo=r("code"),Ur=m("push_to_hub()"),Gr=m(` method. Below is an example which downloads a vanilla Transformers model
from the Hub and converts it to an optimum onnxruntime model and pushes it back into a new repository.`),Rs=h(),v(Ct.$$.fragment),Fs=h(),Te=r("h2"),Qe=r("a"),Go=r("span"),v(At.$$.fragment),Jr=h(),Jo=r("span"),Kr=m("Export and inference of sequence-to-sequence models"),zs=h(),re=r("p"),Yr=m(`Sequence-to-sequence (Seq2Seq) models, that generate a new sequence from an input, can also be used when running inference with ONNX Runtime. When Seq2Seq models are exported to the ONNX format, they are decomposed into two parts : the encoder and the \u201Cdecoder\u201D (which actually consists of the decoder with the language modeling head), that are later combined during inference.
To leverage the pre-computed key/values hidden-states to speed up sequential decoding, simply pass `),Ko=r("code"),Zr=m("use_cache=True"),ea=m(" to the "),Yo=r("code"),ta=m("from_pretrained()"),oa=m(` method. An additional model component will be exported: the \u201Cdecoder\u201D with pre-computed key/values as one of its inputs.
This specific export comes from the fact that during the first pass, the decoder has no pre-computed key/values hidden-states, while during the rest of the generation past key/values will be used to speed up sequential decoding.
Here is an example on how you can export a T5 model to the ONNX format and run inference for a translation task:`),Cs=h(),v(St.$$.fragment),As=h(),be=r("h2"),We=r("a"),Zo=r("span"),v(Pt.$$.fragment),na=h(),en=r("span"),sa=m("ORTModel"),Ss=h(),S=r("div"),v(Nt.$$.fragment),ra=h(),It=r("p"),aa=m(`Base ORTModel class for implementing models using ONNX Runtime. The ORTModel implements generic methods for interacting
with the Hugging Face Hub as well as exporting vanilla transformers models to ONNX using `),tn=r("code"),ia=m("transformers.onnx"),la=m(` toolchain.
The ORTModel implements additionally generic methods for optimizing and quantizing Onnx models.`),ma=h(),Be=r("div"),v(Lt.$$.fragment),pa=h(),on=r("p"),da=m("Instantiate a pretrained model from a pre-trained model configuration."),ca=h(),Ve=r("div"),v(Dt.$$.fragment),ua=h(),Ht=r("p"),ha=m("Loads an ONNX Inference session with a given provider. Default provider is "),nn=r("code"),fa=m("CPUExecutionProvider"),ga=m(" to match the default behaviour in PyTorch/TensorFlow/JAX."),_a=h(),Ue=r("div"),v(Xt.$$.fragment),$a=h(),sn=r("p"),ka=m("Changes the ONNX Runtime provider according to the device."),Ps=h(),Me=r("h2"),Ge=r("a"),rn=r("span"),v(Qt.$$.fragment),wa=h(),an=r("span"),xa=m("ORTModelForFeatureExtraction"),Ns=h(),P=r("div"),v(Wt.$$.fragment),va=h(),ln=r("p"),Ta=m("Onnx Model with a MaskedLMOutput for feature-extraction tasks."),ba=h(),Bt=r("p"),Ma=m("This model inherits from [~"),mn=r("code"),Oa=m("onnxruntime.modeling_ort.ORTModel"),qa=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),ya=h(),pn=r("p"),ja=m("Feature Extraction model for ONNX."),Ea=h(),W=r("div"),v(Vt.$$.fragment),Ra=h(),Oe=r("p"),Fa=m("The "),dn=r("code"),za=m("ORTModelForFeatureExtraction"),Ca=m(" forward method, overrides the "),cn=r("code"),Aa=m("__call__"),Sa=m(" special method."),Pa=h(),v(Je.$$.fragment),Na=h(),v(Ke.$$.fragment),Ia=h(),v(Ye.$$.fragment),Is=h(),qe=r("h2"),Ze=r("a"),un=r("span"),v(Ut.$$.fragment),La=h(),hn=r("span"),Da=m("ORTModelForQuestionAnswering"),Ls=h(),N=r("div"),v(Gt.$$.fragment),Ha=h(),fn=r("p"),Xa=m("Onnx Model with a QuestionAnsweringModelOutput for extractive question-answering tasks like SQuAD."),Qa=h(),Jt=r("p"),Wa=m("This model inherits from [~"),gn=r("code"),Ba=m("onnxruntime.modeling_ort.ORTModel"),Va=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),Ua=h(),_n=r("p"),Ga=m("Question Answering model for ONNX."),Ja=h(),B=r("div"),v(Kt.$$.fragment),Ka=h(),ye=r("p"),Ya=m("The "),$n=r("code"),Za=m("ORTModelForQuestionAnswering"),ei=m(" forward method, overrides the "),kn=r("code"),ti=m("__call__"),oi=m(" special method."),ni=h(),v(et.$$.fragment),si=h(),v(tt.$$.fragment),ri=h(),v(ot.$$.fragment),Ds=h(),je=r("h2"),nt=r("a"),wn=r("span"),v(Yt.$$.fragment),ai=h(),xn=r("span"),ii=m("ORTModelForSequenceClassification"),Hs=h(),I=r("div"),v(Zt.$$.fragment),li=h(),vn=r("p"),mi=m(`Onnx Model with a sequence classification/regression head on top (a linear layer on top of the
pooled output) e.g. for GLUE tasks.`),pi=h(),eo=r("p"),di=m("This model inherits from [~"),Tn=r("code"),ci=m("onnxruntime.modeling_ort.ORTModel"),ui=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),hi=h(),bn=r("p"),fi=m("Sequence Classification model for ONNX."),gi=h(),A=r("div"),v(to.$$.fragment),_i=h(),Ee=r("p"),$i=m("The "),Mn=r("code"),ki=m("ORTModelForSequenceClassification"),wi=m(" forward method, overrides the "),On=r("code"),xi=m("__call__"),vi=m(" special method."),Ti=h(),v(st.$$.fragment),bi=h(),v(rt.$$.fragment),Mi=h(),v(at.$$.fragment),Oi=h(),v(it.$$.fragment),Xs=h(),Re=r("h2"),lt=r("a"),qn=r("span"),v(oo.$$.fragment),qi=h(),yn=r("span"),yi=m("ORTModelForTokenClassification"),Qs=h(),L=r("div"),v(no.$$.fragment),ji=h(),jn=r("p"),Ei=m(`Onnx Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g.
for Named-Entity-Recognition (NER) tasks.`),Ri=h(),so=r("p"),Fi=m("This model inherits from [~"),En=r("code"),zi=m("onnxruntime.modeling_ort.ORTModel"),Ci=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),Ai=h(),Rn=r("p"),Si=m("Token Classification model for ONNX."),Pi=h(),V=r("div"),v(ro.$$.fragment),Ni=h(),Fe=r("p"),Ii=m("The "),Fn=r("code"),Li=m("ORTModelForTokenClassification"),Di=m(" forward method, overrides the "),zn=r("code"),Hi=m("__call__"),Xi=m(" special method."),Qi=h(),v(mt.$$.fragment),Wi=h(),v(pt.$$.fragment),Bi=h(),v(dt.$$.fragment),Ws=h(),ze=r("h2"),ct=r("a"),Cn=r("span"),v(ao.$$.fragment),Vi=h(),An=r("span"),Ui=m("ORTModelForCausalLM"),Bs=h(),D=r("div"),v(io.$$.fragment),Gi=h(),Sn=r("p"),Ji=m(`Onnx Model with a causal language modeling head on top (linear layer with weights tied to the input
embeddings).`),Ki=h(),lo=r("p"),Yi=m("This model inherits from [~"),Pn=r("code"),Zi=m("onnxruntime.modeling_ort.ORTModel"),el=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),tl=h(),Nn=r("p"),ol=m("Causal LM model for ONNX."),nl=h(),U=r("div"),v(mo.$$.fragment),sl=h(),Ce=r("p"),rl=m("The "),In=r("code"),al=m("ORTModelForCausalLM"),il=m(" forward method, overrides the "),Ln=r("code"),ll=m("__call__"),ml=m(" special method."),pl=h(),v(ut.$$.fragment),dl=h(),v(ht.$$.fragment),cl=h(),v(ft.$$.fragment),Vs=h(),Ae=r("h2"),gt=r("a"),Dn=r("span"),v(po.$$.fragment),ul=h(),Hn=r("span"),hl=m("ORTModelForSeq2SeqLM"),Us=h(),oe=r("div"),v(co.$$.fragment),fl=h(),Xn=r("p"),gl=m("Sequence-to-sequence model with a language modeling head for ONNX Runtime inference."),_l=h(),G=r("div"),v(uo.$$.fragment),$l=h(),Se=r("p"),kl=m("The "),Qn=r("code"),wl=m("ORTModelForSeq2SeqLM"),xl=m(" forward method, overrides the "),Wn=r("code"),vl=m("__call__"),Tl=m(" special method."),bl=h(),v(_t.$$.fragment),Ml=h(),v($t.$$.fragment),Ol=h(),v(kt.$$.fragment),Gs=h(),Pe=r("h2"),wt=r("a"),Bn=r("span"),v(ho.$$.fragment),ql=h(),Vn=r("span"),yl=m("ORTModelForImageClassification"),Js=h(),H=r("div"),v(fo.$$.fragment),jl=h(),Un=r("p"),El=m("Onnx Model for image-classification tasks."),Rl=h(),go=r("p"),Fl=m("This model inherits from [~"),Gn=r("code"),zl=m("onnxruntime.modeling_ort.ORTModel"),Cl=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),Al=h(),Jn=r("p"),Sl=m("Image Classification model for ONNX."),Pl=h(),J=r("div"),v(_o.$$.fragment),Nl=h(),Ne=r("p"),Il=m("The "),Kn=r("code"),Ll=m("ORTModelForImageClassification"),Dl=m(" forward method, overrides the "),Yn=r("code"),Hl=m("__call__"),Xl=m(" special method."),Ql=h(),v(xt.$$.fragment),Wl=h(),v(vt.$$.fragment),Bl=h(),v(Tt.$$.fragment),Ks=h(),Ie=r("h2"),bt=r("a"),Zn=r("span"),v($o.$$.fragment),Vl=h(),es=r("span"),Ul=m("ORTModelForCustomTasks"),Ys=h(),X=r("div"),v(ko.$$.fragment),Gl=h(),ts=r("p"),Jl=m("Onnx Model for any custom tasks. It can be used to leverage the inference acceleration with any custom exported ONNX model."),Kl=h(),wo=r("p"),Yl=m("This model inherits from [~"),os=r("code"),Zl=m("onnxruntime.modeling_ort.ORTModel"),em=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),tm=h(),ns=r("p"),om=m("Onnx Model for any custom tasks."),nm=h(),K=r("div"),v(xo.$$.fragment),sm=h(),Le=r("p"),rm=m("The "),ss=r("code"),am=m("ORTModelForCustomTasks"),im=m(" forward method, overrides the "),rs=r("code"),lm=m("__call__"),mm=m(" special method."),pm=h(),v(Mt.$$.fragment),dm=h(),v(Ot.$$.fragment),cm=h(),v(qt.$$.fragment),this.h()},l(t){const g=Pp('[data-svelte="svelte-1phssyn"]',document.head);n=a(g,"META",{name:!0,content:!0}),g.forEach(o),$=f(t),c=a(t,"H1",{class:!0});var vo=i(c);u=a(vo,"A",{id:!0,class:!0,href:!0});var as=i(u);_=a(as,"SPAN",{});var is=i(_);T(s.$$.fragment,is),is.forEach(o),as.forEach(o),l=f(vo),x=a(vo,"SPAN",{});var ls=i(x);d=p(ls,"Optimum Inference with ONNX Runtime"),ls.forEach(o),vo.forEach(o),w=f(t),E=a(t,"P",{});var To=i(E);vr=p(To,`Optimum is a utility package for building and running inference with accelerated runtime like ONNX Runtime.
Optimum can be used to load optimized models from the `),Oo=a(To,"A",{href:!0});var ms=i(Oo);Tr=p(ms,"Hugging Face Hub"),ms.forEach(o),br=p(To,` and create pipelines
to run accelerated inference without rewriting your APIs.`),To.forEach(o),bs=f(t),xe=a(t,"H2",{class:!0});var bo=i(xe);He=a(bo,"A",{id:!0,class:!0,href:!0});var ps=i(He);No=a(ps,"SPAN",{});var ds=i(No);T(jt.$$.fragment,ds),ds.forEach(o),ps.forEach(o),Mr=f(bo),Io=a(bo,"SPAN",{});var cs=i(Io);Or=p(cs,"Switching from Transformers to Optimum Inference"),cs.forEach(o),bo.forEach(o),Ms=f(t),Q=a(t,"P",{});var Y=i(Q);qr=p(Y,"The Optimum Inference models are API compatible with Hugging Face Transformers models. This means you can just replace your "),Lo=a(Y,"CODE",{});var us=i(Lo);yr=p(us,"AutoModelForXxx"),us.forEach(o),jr=p(Y," class with the corresponding "),Do=a(Y,"CODE",{});var hs=i(Do);Er=p(hs,"ORTModelForXxx"),hs.forEach(o),Rr=p(Y," class in "),Ho=a(Y,"CODE",{});var fs=i(Ho);Fr=p(fs,"optimum"),fs.forEach(o),zr=p(Y,". For example, this is how you can use a question answering model in "),Xo=a(Y,"CODE",{});var gs=i(Xo);Cr=p(gs,"optimum"),gs.forEach(o),Ar=p(Y,":"),Y.forEach(o),Os=f(t),T(Et.$$.fragment,t),qs=f(t),se=a(t,"P",{});var De=i(se);Sr=p(De,"Optimum Inference also includes methods to convert vanilla Transformers models to optimized ones. Simply pass "),Qo=a(De,"CODE",{});var _s=i(Qo);Pr=p(_s,"from_transformers=True"),_s.forEach(o),Nr=p(De," to the "),Wo=a(De,"CODE",{});var $s=i(Wo);Ir=p($s,"from_pretrained()"),$s.forEach(o),Lr=p(De," method, and your model will be loaded and converted to ONNX on-the-fly:"),De.forEach(o),ys=f(t),T(Rt.$$.fragment,t),js=f(t),ve=a(t,"H3",{class:!0});var Mo=i(ve);Xe=a(Mo,"A",{id:!0,class:!0,href:!0});var ks=i(Xe);Bo=a(ks,"SPAN",{});var ws=i(Bo);T(Ft.$$.fragment,ws),ws.forEach(o),ks.forEach(o),Dr=f(Mo),Vo=a(Mo,"SPAN",{});var xs=i(Vo);Hr=p(xs,"Working with the Hugging Face Model Hub"),xs.forEach(o),Mo.forEach(o),Es=f(t),ee=a(t,"P",{});var ne=i(ee);Xr=p(ne,"The Optimum model classes like "),qo=a(ne,"A",{href:!0});var vs=i(qo);Qr=p(vs,"ORTModelForSequenceClassification"),vs.forEach(o),Wr=p(ne," are integrated with the "),zt=a(ne,"A",{href:!0,rel:!0});var Ts=i(zt);Br=p(Ts,"Hugging Face Model Hub"),Ts.forEach(o),Vr=p(ne,`, which means you can not only
load model from the Hub, but also push your models to the Hub with `),Uo=a(ne,"CODE",{});var um=i(Uo);Ur=p(um,"push_to_hub()"),um.forEach(o),Gr=p(ne,` method. Below is an example which downloads a vanilla Transformers model
from the Hub and converts it to an optimum onnxruntime model and pushes it back into a new repository.`),ne.forEach(o),Rs=f(t),T(Ct.$$.fragment,t),Fs=f(t),Te=a(t,"H2",{class:!0});var er=i(Te);Qe=a(er,"A",{id:!0,class:!0,href:!0});var hm=i(Qe);Go=a(hm,"SPAN",{});var fm=i(Go);T(At.$$.fragment,fm),fm.forEach(o),hm.forEach(o),Jr=f(er),Jo=a(er,"SPAN",{});var gm=i(Jo);Kr=p(gm,"Export and inference of sequence-to-sequence models"),gm.forEach(o),er.forEach(o),zs=f(t),re=a(t,"P",{});var yo=i(re);Yr=p(yo,`Sequence-to-sequence (Seq2Seq) models, that generate a new sequence from an input, can also be used when running inference with ONNX Runtime. When Seq2Seq models are exported to the ONNX format, they are decomposed into two parts : the encoder and the \u201Cdecoder\u201D (which actually consists of the decoder with the language modeling head), that are later combined during inference.
To leverage the pre-computed key/values hidden-states to speed up sequential decoding, simply pass `),Ko=a(yo,"CODE",{});var _m=i(Ko);Zr=p(_m,"use_cache=True"),_m.forEach(o),ea=p(yo," to the "),Yo=a(yo,"CODE",{});var $m=i(Yo);ta=p($m,"from_pretrained()"),$m.forEach(o),oa=p(yo,` method. An additional model component will be exported: the \u201Cdecoder\u201D with pre-computed key/values as one of its inputs.
This specific export comes from the fact that during the first pass, the decoder has no pre-computed key/values hidden-states, while during the rest of the generation past key/values will be used to speed up sequential decoding.
Here is an example on how you can export a T5 model to the ONNX format and run inference for a translation task:`),yo.forEach(o),Cs=f(t),T(St.$$.fragment,t),As=f(t),be=a(t,"H2",{class:!0});var tr=i(be);We=a(tr,"A",{id:!0,class:!0,href:!0});var km=i(We);Zo=a(km,"SPAN",{});var wm=i(Zo);T(Pt.$$.fragment,wm),wm.forEach(o),km.forEach(o),na=f(tr),en=a(tr,"SPAN",{});var xm=i(en);sa=p(xm,"ORTModel"),xm.forEach(o),tr.forEach(o),Ss=f(t),S=a(t,"DIV",{class:!0});var ae=i(S);T(Nt.$$.fragment,ae),ra=f(ae),It=a(ae,"P",{});var or=i(It);aa=p(or,`Base ORTModel class for implementing models using ONNX Runtime. The ORTModel implements generic methods for interacting
with the Hugging Face Hub as well as exporting vanilla transformers models to ONNX using `),tn=a(or,"CODE",{});var vm=i(tn);ia=p(vm,"transformers.onnx"),vm.forEach(o),la=p(or,` toolchain.
The ORTModel implements additionally generic methods for optimizing and quantizing Onnx models.`),or.forEach(o),ma=f(ae),Be=a(ae,"DIV",{class:!0});var nr=i(Be);T(Lt.$$.fragment,nr),pa=f(nr),on=a(nr,"P",{});var Tm=i(on);da=p(Tm,"Instantiate a pretrained model from a pre-trained model configuration."),Tm.forEach(o),nr.forEach(o),ca=f(ae),Ve=a(ae,"DIV",{class:!0});var sr=i(Ve);T(Dt.$$.fragment,sr),ua=f(sr),Ht=a(sr,"P",{});var rr=i(Ht);ha=p(rr,"Loads an ONNX Inference session with a given provider. Default provider is "),nn=a(rr,"CODE",{});var bm=i(nn);fa=p(bm,"CPUExecutionProvider"),bm.forEach(o),ga=p(rr," to match the default behaviour in PyTorch/TensorFlow/JAX."),rr.forEach(o),sr.forEach(o),_a=f(ae),Ue=a(ae,"DIV",{class:!0});var ar=i(Ue);T(Xt.$$.fragment,ar),$a=f(ar),sn=a(ar,"P",{});var Mm=i(sn);ka=p(Mm,"Changes the ONNX Runtime provider according to the device."),Mm.forEach(o),ar.forEach(o),ae.forEach(o),Ps=f(t),Me=a(t,"H2",{class:!0});var ir=i(Me);Ge=a(ir,"A",{id:!0,class:!0,href:!0});var Om=i(Ge);rn=a(Om,"SPAN",{});var qm=i(rn);T(Qt.$$.fragment,qm),qm.forEach(o),Om.forEach(o),wa=f(ir),an=a(ir,"SPAN",{});var ym=i(an);xa=p(ym,"ORTModelForFeatureExtraction"),ym.forEach(o),ir.forEach(o),Ns=f(t),P=a(t,"DIV",{class:!0});var ie=i(P);T(Wt.$$.fragment,ie),va=f(ie),ln=a(ie,"P",{});var jm=i(ln);Ta=p(jm,"Onnx Model with a MaskedLMOutput for feature-extraction tasks."),jm.forEach(o),ba=f(ie),Bt=a(ie,"P",{});var lr=i(Bt);Ma=p(lr,"This model inherits from [~"),mn=a(lr,"CODE",{});var Em=i(mn);Oa=p(Em,"onnxruntime.modeling_ort.ORTModel"),Em.forEach(o),qa=p(lr,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),lr.forEach(o),ya=f(ie),pn=a(ie,"P",{});var Rm=i(pn);ja=p(Rm,"Feature Extraction model for ONNX."),Rm.forEach(o),Ea=f(ie),W=a(ie,"DIV",{class:!0});var le=i(W);T(Vt.$$.fragment,le),Ra=f(le),Oe=a(le,"P",{});var jo=i(Oe);Fa=p(jo,"The "),dn=a(jo,"CODE",{});var Fm=i(dn);za=p(Fm,"ORTModelForFeatureExtraction"),Fm.forEach(o),Ca=p(jo," forward method, overrides the "),cn=a(jo,"CODE",{});var zm=i(cn);Aa=p(zm,"__call__"),zm.forEach(o),Sa=p(jo," special method."),jo.forEach(o),Pa=f(le),T(Je.$$.fragment,le),Na=f(le),T(Ke.$$.fragment,le),Ia=f(le),T(Ye.$$.fragment,le),le.forEach(o),ie.forEach(o),Is=f(t),qe=a(t,"H2",{class:!0});var mr=i(qe);Ze=a(mr,"A",{id:!0,class:!0,href:!0});var Cm=i(Ze);un=a(Cm,"SPAN",{});var Am=i(un);T(Ut.$$.fragment,Am),Am.forEach(o),Cm.forEach(o),La=f(mr),hn=a(mr,"SPAN",{});var Sm=i(hn);Da=p(Sm,"ORTModelForQuestionAnswering"),Sm.forEach(o),mr.forEach(o),Ls=f(t),N=a(t,"DIV",{class:!0});var me=i(N);T(Gt.$$.fragment,me),Ha=f(me),fn=a(me,"P",{});var Pm=i(fn);Xa=p(Pm,"Onnx Model with a QuestionAnsweringModelOutput for extractive question-answering tasks like SQuAD."),Pm.forEach(o),Qa=f(me),Jt=a(me,"P",{});var pr=i(Jt);Wa=p(pr,"This model inherits from [~"),gn=a(pr,"CODE",{});var Nm=i(gn);Ba=p(Nm,"onnxruntime.modeling_ort.ORTModel"),Nm.forEach(o),Va=p(pr,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),pr.forEach(o),Ua=f(me),_n=a(me,"P",{});var Im=i(_n);Ga=p(Im,"Question Answering model for ONNX."),Im.forEach(o),Ja=f(me),B=a(me,"DIV",{class:!0});var pe=i(B);T(Kt.$$.fragment,pe),Ka=f(pe),ye=a(pe,"P",{});var Eo=i(ye);Ya=p(Eo,"The "),$n=a(Eo,"CODE",{});var Lm=i($n);Za=p(Lm,"ORTModelForQuestionAnswering"),Lm.forEach(o),ei=p(Eo," forward method, overrides the "),kn=a(Eo,"CODE",{});var Dm=i(kn);ti=p(Dm,"__call__"),Dm.forEach(o),oi=p(Eo," special method."),Eo.forEach(o),ni=f(pe),T(et.$$.fragment,pe),si=f(pe),T(tt.$$.fragment,pe),ri=f(pe),T(ot.$$.fragment,pe),pe.forEach(o),me.forEach(o),Ds=f(t),je=a(t,"H2",{class:!0});var dr=i(je);nt=a(dr,"A",{id:!0,class:!0,href:!0});var Hm=i(nt);wn=a(Hm,"SPAN",{});var Xm=i(wn);T(Yt.$$.fragment,Xm),Xm.forEach(o),Hm.forEach(o),ai=f(dr),xn=a(dr,"SPAN",{});var Qm=i(xn);ii=p(Qm,"ORTModelForSequenceClassification"),Qm.forEach(o),dr.forEach(o),Hs=f(t),I=a(t,"DIV",{class:!0});var de=i(I);T(Zt.$$.fragment,de),li=f(de),vn=a(de,"P",{});var Wm=i(vn);mi=p(Wm,`Onnx Model with a sequence classification/regression head on top (a linear layer on top of the
pooled output) e.g. for GLUE tasks.`),Wm.forEach(o),pi=f(de),eo=a(de,"P",{});var cr=i(eo);di=p(cr,"This model inherits from [~"),Tn=a(cr,"CODE",{});var Bm=i(Tn);ci=p(Bm,"onnxruntime.modeling_ort.ORTModel"),Bm.forEach(o),ui=p(cr,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),cr.forEach(o),hi=f(de),bn=a(de,"P",{});var Vm=i(bn);fi=p(Vm,"Sequence Classification model for ONNX."),Vm.forEach(o),gi=f(de),A=a(de,"DIV",{class:!0});var te=i(A);T(to.$$.fragment,te),_i=f(te),Ee=a(te,"P",{});var Ro=i(Ee);$i=p(Ro,"The "),Mn=a(Ro,"CODE",{});var Um=i(Mn);ki=p(Um,"ORTModelForSequenceClassification"),Um.forEach(o),wi=p(Ro," forward method, overrides the "),On=a(Ro,"CODE",{});var Gm=i(On);xi=p(Gm,"__call__"),Gm.forEach(o),vi=p(Ro," special method."),Ro.forEach(o),Ti=f(te),T(st.$$.fragment,te),bi=f(te),T(rt.$$.fragment,te),Mi=f(te),T(at.$$.fragment,te),Oi=f(te),T(it.$$.fragment,te),te.forEach(o),de.forEach(o),Xs=f(t),Re=a(t,"H2",{class:!0});var ur=i(Re);lt=a(ur,"A",{id:!0,class:!0,href:!0});var Jm=i(lt);qn=a(Jm,"SPAN",{});var Km=i(qn);T(oo.$$.fragment,Km),Km.forEach(o),Jm.forEach(o),qi=f(ur),yn=a(ur,"SPAN",{});var Ym=i(yn);yi=p(Ym,"ORTModelForTokenClassification"),Ym.forEach(o),ur.forEach(o),Qs=f(t),L=a(t,"DIV",{class:!0});var ce=i(L);T(no.$$.fragment,ce),ji=f(ce),jn=a(ce,"P",{});var Zm=i(jn);Ei=p(Zm,`Onnx Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g.
for Named-Entity-Recognition (NER) tasks.`),Zm.forEach(o),Ri=f(ce),so=a(ce,"P",{});var hr=i(so);Fi=p(hr,"This model inherits from [~"),En=a(hr,"CODE",{});var ep=i(En);zi=p(ep,"onnxruntime.modeling_ort.ORTModel"),ep.forEach(o),Ci=p(hr,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),hr.forEach(o),Ai=f(ce),Rn=a(ce,"P",{});var tp=i(Rn);Si=p(tp,"Token Classification model for ONNX."),tp.forEach(o),Pi=f(ce),V=a(ce,"DIV",{class:!0});var ue=i(V);T(ro.$$.fragment,ue),Ni=f(ue),Fe=a(ue,"P",{});var Fo=i(Fe);Ii=p(Fo,"The "),Fn=a(Fo,"CODE",{});var op=i(Fn);Li=p(op,"ORTModelForTokenClassification"),op.forEach(o),Di=p(Fo," forward method, overrides the "),zn=a(Fo,"CODE",{});var np=i(zn);Hi=p(np,"__call__"),np.forEach(o),Xi=p(Fo," special method."),Fo.forEach(o),Qi=f(ue),T(mt.$$.fragment,ue),Wi=f(ue),T(pt.$$.fragment,ue),Bi=f(ue),T(dt.$$.fragment,ue),ue.forEach(o),ce.forEach(o),Ws=f(t),ze=a(t,"H2",{class:!0});var fr=i(ze);ct=a(fr,"A",{id:!0,class:!0,href:!0});var sp=i(ct);Cn=a(sp,"SPAN",{});var rp=i(Cn);T(ao.$$.fragment,rp),rp.forEach(o),sp.forEach(o),Vi=f(fr),An=a(fr,"SPAN",{});var ap=i(An);Ui=p(ap,"ORTModelForCausalLM"),ap.forEach(o),fr.forEach(o),Bs=f(t),D=a(t,"DIV",{class:!0});var he=i(D);T(io.$$.fragment,he),Gi=f(he),Sn=a(he,"P",{});var ip=i(Sn);Ji=p(ip,`Onnx Model with a causal language modeling head on top (linear layer with weights tied to the input
embeddings).`),ip.forEach(o),Ki=f(he),lo=a(he,"P",{});var gr=i(lo);Yi=p(gr,"This model inherits from [~"),Pn=a(gr,"CODE",{});var lp=i(Pn);Zi=p(lp,"onnxruntime.modeling_ort.ORTModel"),lp.forEach(o),el=p(gr,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),gr.forEach(o),tl=f(he),Nn=a(he,"P",{});var mp=i(Nn);ol=p(mp,"Causal LM model for ONNX."),mp.forEach(o),nl=f(he),U=a(he,"DIV",{class:!0});var fe=i(U);T(mo.$$.fragment,fe),sl=f(fe),Ce=a(fe,"P",{});var zo=i(Ce);rl=p(zo,"The "),In=a(zo,"CODE",{});var pp=i(In);al=p(pp,"ORTModelForCausalLM"),pp.forEach(o),il=p(zo," forward method, overrides the "),Ln=a(zo,"CODE",{});var dp=i(Ln);ll=p(dp,"__call__"),dp.forEach(o),ml=p(zo," special method."),zo.forEach(o),pl=f(fe),T(ut.$$.fragment,fe),dl=f(fe),T(ht.$$.fragment,fe),cl=f(fe),T(ft.$$.fragment,fe),fe.forEach(o),he.forEach(o),Vs=f(t),Ae=a(t,"H2",{class:!0});var _r=i(Ae);gt=a(_r,"A",{id:!0,class:!0,href:!0});var cp=i(gt);Dn=a(cp,"SPAN",{});var up=i(Dn);T(po.$$.fragment,up),up.forEach(o),cp.forEach(o),ul=f(_r),Hn=a(_r,"SPAN",{});var hp=i(Hn);hl=p(hp,"ORTModelForSeq2SeqLM"),hp.forEach(o),_r.forEach(o),Us=f(t),oe=a(t,"DIV",{class:!0});var Co=i(oe);T(co.$$.fragment,Co),fl=f(Co),Xn=a(Co,"P",{});var fp=i(Xn);gl=p(fp,"Sequence-to-sequence model with a language modeling head for ONNX Runtime inference."),fp.forEach(o),_l=f(Co),G=a(Co,"DIV",{class:!0});var ge=i(G);T(uo.$$.fragment,ge),$l=f(ge),Se=a(ge,"P",{});var Ao=i(Se);kl=p(Ao,"The "),Qn=a(Ao,"CODE",{});var gp=i(Qn);wl=p(gp,"ORTModelForSeq2SeqLM"),gp.forEach(o),xl=p(Ao," forward method, overrides the "),Wn=a(Ao,"CODE",{});var _p=i(Wn);vl=p(_p,"__call__"),_p.forEach(o),Tl=p(Ao," special method."),Ao.forEach(o),bl=f(ge),T(_t.$$.fragment,ge),Ml=f(ge),T($t.$$.fragment,ge),Ol=f(ge),T(kt.$$.fragment,ge),ge.forEach(o),Co.forEach(o),Gs=f(t),Pe=a(t,"H2",{class:!0});var $r=i(Pe);wt=a($r,"A",{id:!0,class:!0,href:!0});var $p=i(wt);Bn=a($p,"SPAN",{});var kp=i(Bn);T(ho.$$.fragment,kp),kp.forEach(o),$p.forEach(o),ql=f($r),Vn=a($r,"SPAN",{});var wp=i(Vn);yl=p(wp,"ORTModelForImageClassification"),wp.forEach(o),$r.forEach(o),Js=f(t),H=a(t,"DIV",{class:!0});var _e=i(H);T(fo.$$.fragment,_e),jl=f(_e),Un=a(_e,"P",{});var xp=i(Un);El=p(xp,"Onnx Model for image-classification tasks."),xp.forEach(o),Rl=f(_e),go=a(_e,"P",{});var kr=i(go);Fl=p(kr,"This model inherits from [~"),Gn=a(kr,"CODE",{});var vp=i(Gn);zl=p(vp,"onnxruntime.modeling_ort.ORTModel"),vp.forEach(o),Cl=p(kr,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),kr.forEach(o),Al=f(_e),Jn=a(_e,"P",{});var Tp=i(Jn);Sl=p(Tp,"Image Classification model for ONNX."),Tp.forEach(o),Pl=f(_e),J=a(_e,"DIV",{class:!0});var $e=i(J);T(_o.$$.fragment,$e),Nl=f($e),Ne=a($e,"P",{});var So=i(Ne);Il=p(So,"The "),Kn=a(So,"CODE",{});var bp=i(Kn);Ll=p(bp,"ORTModelForImageClassification"),bp.forEach(o),Dl=p(So," forward method, overrides the "),Yn=a(So,"CODE",{});var Mp=i(Yn);Hl=p(Mp,"__call__"),Mp.forEach(o),Xl=p(So," special method."),So.forEach(o),Ql=f($e),T(xt.$$.fragment,$e),Wl=f($e),T(vt.$$.fragment,$e),Bl=f($e),T(Tt.$$.fragment,$e),$e.forEach(o),_e.forEach(o),Ks=f(t),Ie=a(t,"H2",{class:!0});var wr=i(Ie);bt=a(wr,"A",{id:!0,class:!0,href:!0});var Op=i(bt);Zn=a(Op,"SPAN",{});var qp=i(Zn);T($o.$$.fragment,qp),qp.forEach(o),Op.forEach(o),Vl=f(wr),es=a(wr,"SPAN",{});var yp=i(es);Ul=p(yp,"ORTModelForCustomTasks"),yp.forEach(o),wr.forEach(o),Ys=f(t),X=a(t,"DIV",{class:!0});var ke=i(X);T(ko.$$.fragment,ke),Gl=f(ke),ts=a(ke,"P",{});var jp=i(ts);Jl=p(jp,"Onnx Model for any custom tasks. It can be used to leverage the inference acceleration with any custom exported ONNX model."),jp.forEach(o),Kl=f(ke),wo=a(ke,"P",{});var xr=i(wo);Yl=p(xr,"This model inherits from [~"),os=a(xr,"CODE",{});var Ep=i(os);Zl=p(Ep,"onnxruntime.modeling_ort.ORTModel"),Ep.forEach(o),em=p(xr,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),xr.forEach(o),tm=f(ke),ns=a(ke,"P",{});var Rp=i(ns);om=p(Rp,"Onnx Model for any custom tasks."),Rp.forEach(o),nm=f(ke),K=a(ke,"DIV",{class:!0});var we=i(K);T(xo.$$.fragment,we),sm=f(we),Le=a(we,"P",{});var Po=i(Le);rm=p(Po,"The "),ss=a(Po,"CODE",{});var Fp=i(ss);am=p(Fp,"ORTModelForCustomTasks"),Fp.forEach(o),im=p(Po," forward method, overrides the "),rs=a(Po,"CODE",{});var zp=i(rs);lm=p(zp,"__call__"),zp.forEach(o),mm=p(Po," special method."),Po.forEach(o),pm=f(we),T(Mt.$$.fragment,we),dm=f(we),T(Ot.$$.fragment,we),cm=f(we),T(qt.$$.fragment,we),we.forEach(o),ke.forEach(o),this.h()},h(){y(n,"name","hf:doc:metadata"),y(n,"content",JSON.stringify(dd)),y(u,"id","optimum-inference-with-onnx-runtime"),y(u,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(u,"href","#optimum-inference-with-onnx-runtime"),y(c,"class","relative group"),y(Oo,"href","hf.co/models"),y(He,"id","switching-from-transformers-to-optimum-inference"),y(He,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(He,"href","#switching-from-transformers-to-optimum-inference"),y(xe,"class","relative group"),y(Xe,"id","working-with-the-hugging-face-model-hub"),y(Xe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(Xe,"href","#working-with-the-hugging-face-model-hub"),y(ve,"class","relative group"),y(qo,"href","/docs/optimum/pr_271/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModelForSequenceClassification"),y(zt,"href","https://hf.co/models"),y(zt,"rel","nofollow"),y(Qe,"id","export-and-inference-of-sequencetosequence-models"),y(Qe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(Qe,"href","#export-and-inference-of-sequencetosequence-models"),y(Te,"class","relative group"),y(We,"id","optimum.onnxruntime.ORTModel"),y(We,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(We,"href","#optimum.onnxruntime.ORTModel"),y(be,"class","relative group"),y(Be,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(Ve,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(Ue,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(S,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(Ge,"id","optimum.onnxruntime.ORTModelForFeatureExtraction"),y(Ge,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(Ge,"href","#optimum.onnxruntime.ORTModelForFeatureExtraction"),y(Me,"class","relative group"),y(W,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(P,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(Ze,"id","optimum.onnxruntime.ORTModelForQuestionAnswering"),y(Ze,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(Ze,"href","#optimum.onnxruntime.ORTModelForQuestionAnswering"),y(qe,"class","relative group"),y(B,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(nt,"id","optimum.onnxruntime.ORTModelForSequenceClassification"),y(nt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(nt,"href","#optimum.onnxruntime.ORTModelForSequenceClassification"),y(je,"class","relative group"),y(A,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(I,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(lt,"id","optimum.onnxruntime.ORTModelForTokenClassification"),y(lt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(lt,"href","#optimum.onnxruntime.ORTModelForTokenClassification"),y(Re,"class","relative group"),y(V,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(L,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(ct,"id","optimum.onnxruntime.ORTModelForCausalLM"),y(ct,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(ct,"href","#optimum.onnxruntime.ORTModelForCausalLM"),y(ze,"class","relative group"),y(U,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(D,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(gt,"id","optimum.onnxruntime.ORTModelForSeq2SeqLM"),y(gt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(gt,"href","#optimum.onnxruntime.ORTModelForSeq2SeqLM"),y(Ae,"class","relative group"),y(G,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(oe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(wt,"id","optimum.onnxruntime.ORTModelForImageClassification"),y(wt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(wt,"href","#optimum.onnxruntime.ORTModelForImageClassification"),y(Pe,"class","relative group"),y(J,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(H,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(bt,"id","optimum.onnxruntime.ORTModelForCustomTasks"),y(bt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(bt,"href","#optimum.onnxruntime.ORTModelForCustomTasks"),y(Ie,"class","relative group"),y(K,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(X,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,g){e(document.head,n),k(t,$,g),k(t,c,g),e(c,u),e(u,_),b(s,_,null),e(c,l),e(c,x),e(x,d),k(t,w,g),k(t,E,g),e(E,vr),e(E,Oo),e(Oo,Tr),e(E,br),k(t,bs,g),k(t,xe,g),e(xe,He),e(He,No),b(jt,No,null),e(xe,Mr),e(xe,Io),e(Io,Or),k(t,Ms,g),k(t,Q,g),e(Q,qr),e(Q,Lo),e(Lo,yr),e(Q,jr),e(Q,Do),e(Do,Er),e(Q,Rr),e(Q,Ho),e(Ho,Fr),e(Q,zr),e(Q,Xo),e(Xo,Cr),e(Q,Ar),k(t,Os,g),b(Et,t,g),k(t,qs,g),k(t,se,g),e(se,Sr),e(se,Qo),e(Qo,Pr),e(se,Nr),e(se,Wo),e(Wo,Ir),e(se,Lr),k(t,ys,g),b(Rt,t,g),k(t,js,g),k(t,ve,g),e(ve,Xe),e(Xe,Bo),b(Ft,Bo,null),e(ve,Dr),e(ve,Vo),e(Vo,Hr),k(t,Es,g),k(t,ee,g),e(ee,Xr),e(ee,qo),e(qo,Qr),e(ee,Wr),e(ee,zt),e(zt,Br),e(ee,Vr),e(ee,Uo),e(Uo,Ur),e(ee,Gr),k(t,Rs,g),b(Ct,t,g),k(t,Fs,g),k(t,Te,g),e(Te,Qe),e(Qe,Go),b(At,Go,null),e(Te,Jr),e(Te,Jo),e(Jo,Kr),k(t,zs,g),k(t,re,g),e(re,Yr),e(re,Ko),e(Ko,Zr),e(re,ea),e(re,Yo),e(Yo,ta),e(re,oa),k(t,Cs,g),b(St,t,g),k(t,As,g),k(t,be,g),e(be,We),e(We,Zo),b(Pt,Zo,null),e(be,na),e(be,en),e(en,sa),k(t,Ss,g),k(t,S,g),b(Nt,S,null),e(S,ra),e(S,It),e(It,aa),e(It,tn),e(tn,ia),e(It,la),e(S,ma),e(S,Be),b(Lt,Be,null),e(Be,pa),e(Be,on),e(on,da),e(S,ca),e(S,Ve),b(Dt,Ve,null),e(Ve,ua),e(Ve,Ht),e(Ht,ha),e(Ht,nn),e(nn,fa),e(Ht,ga),e(S,_a),e(S,Ue),b(Xt,Ue,null),e(Ue,$a),e(Ue,sn),e(sn,ka),k(t,Ps,g),k(t,Me,g),e(Me,Ge),e(Ge,rn),b(Qt,rn,null),e(Me,wa),e(Me,an),e(an,xa),k(t,Ns,g),k(t,P,g),b(Wt,P,null),e(P,va),e(P,ln),e(ln,Ta),e(P,ba),e(P,Bt),e(Bt,Ma),e(Bt,mn),e(mn,Oa),e(Bt,qa),e(P,ya),e(P,pn),e(pn,ja),e(P,Ea),e(P,W),b(Vt,W,null),e(W,Ra),e(W,Oe),e(Oe,Fa),e(Oe,dn),e(dn,za),e(Oe,Ca),e(Oe,cn),e(cn,Aa),e(Oe,Sa),e(W,Pa),b(Je,W,null),e(W,Na),b(Ke,W,null),e(W,Ia),b(Ye,W,null),k(t,Is,g),k(t,qe,g),e(qe,Ze),e(Ze,un),b(Ut,un,null),e(qe,La),e(qe,hn),e(hn,Da),k(t,Ls,g),k(t,N,g),b(Gt,N,null),e(N,Ha),e(N,fn),e(fn,Xa),e(N,Qa),e(N,Jt),e(Jt,Wa),e(Jt,gn),e(gn,Ba),e(Jt,Va),e(N,Ua),e(N,_n),e(_n,Ga),e(N,Ja),e(N,B),b(Kt,B,null),e(B,Ka),e(B,ye),e(ye,Ya),e(ye,$n),e($n,Za),e(ye,ei),e(ye,kn),e(kn,ti),e(ye,oi),e(B,ni),b(et,B,null),e(B,si),b(tt,B,null),e(B,ri),b(ot,B,null),k(t,Ds,g),k(t,je,g),e(je,nt),e(nt,wn),b(Yt,wn,null),e(je,ai),e(je,xn),e(xn,ii),k(t,Hs,g),k(t,I,g),b(Zt,I,null),e(I,li),e(I,vn),e(vn,mi),e(I,pi),e(I,eo),e(eo,di),e(eo,Tn),e(Tn,ci),e(eo,ui),e(I,hi),e(I,bn),e(bn,fi),e(I,gi),e(I,A),b(to,A,null),e(A,_i),e(A,Ee),e(Ee,$i),e(Ee,Mn),e(Mn,ki),e(Ee,wi),e(Ee,On),e(On,xi),e(Ee,vi),e(A,Ti),b(st,A,null),e(A,bi),b(rt,A,null),e(A,Mi),b(at,A,null),e(A,Oi),b(it,A,null),k(t,Xs,g),k(t,Re,g),e(Re,lt),e(lt,qn),b(oo,qn,null),e(Re,qi),e(Re,yn),e(yn,yi),k(t,Qs,g),k(t,L,g),b(no,L,null),e(L,ji),e(L,jn),e(jn,Ei),e(L,Ri),e(L,so),e(so,Fi),e(so,En),e(En,zi),e(so,Ci),e(L,Ai),e(L,Rn),e(Rn,Si),e(L,Pi),e(L,V),b(ro,V,null),e(V,Ni),e(V,Fe),e(Fe,Ii),e(Fe,Fn),e(Fn,Li),e(Fe,Di),e(Fe,zn),e(zn,Hi),e(Fe,Xi),e(V,Qi),b(mt,V,null),e(V,Wi),b(pt,V,null),e(V,Bi),b(dt,V,null),k(t,Ws,g),k(t,ze,g),e(ze,ct),e(ct,Cn),b(ao,Cn,null),e(ze,Vi),e(ze,An),e(An,Ui),k(t,Bs,g),k(t,D,g),b(io,D,null),e(D,Gi),e(D,Sn),e(Sn,Ji),e(D,Ki),e(D,lo),e(lo,Yi),e(lo,Pn),e(Pn,Zi),e(lo,el),e(D,tl),e(D,Nn),e(Nn,ol),e(D,nl),e(D,U),b(mo,U,null),e(U,sl),e(U,Ce),e(Ce,rl),e(Ce,In),e(In,al),e(Ce,il),e(Ce,Ln),e(Ln,ll),e(Ce,ml),e(U,pl),b(ut,U,null),e(U,dl),b(ht,U,null),e(U,cl),b(ft,U,null),k(t,Vs,g),k(t,Ae,g),e(Ae,gt),e(gt,Dn),b(po,Dn,null),e(Ae,ul),e(Ae,Hn),e(Hn,hl),k(t,Us,g),k(t,oe,g),b(co,oe,null),e(oe,fl),e(oe,Xn),e(Xn,gl),e(oe,_l),e(oe,G),b(uo,G,null),e(G,$l),e(G,Se),e(Se,kl),e(Se,Qn),e(Qn,wl),e(Se,xl),e(Se,Wn),e(Wn,vl),e(Se,Tl),e(G,bl),b(_t,G,null),e(G,Ml),b($t,G,null),e(G,Ol),b(kt,G,null),k(t,Gs,g),k(t,Pe,g),e(Pe,wt),e(wt,Bn),b(ho,Bn,null),e(Pe,ql),e(Pe,Vn),e(Vn,yl),k(t,Js,g),k(t,H,g),b(fo,H,null),e(H,jl),e(H,Un),e(Un,El),e(H,Rl),e(H,go),e(go,Fl),e(go,Gn),e(Gn,zl),e(go,Cl),e(H,Al),e(H,Jn),e(Jn,Sl),e(H,Pl),e(H,J),b(_o,J,null),e(J,Nl),e(J,Ne),e(Ne,Il),e(Ne,Kn),e(Kn,Ll),e(Ne,Dl),e(Ne,Yn),e(Yn,Hl),e(Ne,Xl),e(J,Ql),b(xt,J,null),e(J,Wl),b(vt,J,null),e(J,Bl),b(Tt,J,null),k(t,Ks,g),k(t,Ie,g),e(Ie,bt),e(bt,Zn),b($o,Zn,null),e(Ie,Vl),e(Ie,es),e(es,Ul),k(t,Ys,g),k(t,X,g),b(ko,X,null),e(X,Gl),e(X,ts),e(ts,Jl),e(X,Kl),e(X,wo),e(wo,Yl),e(wo,os),e(os,Zl),e(wo,em),e(X,tm),e(X,ns),e(ns,om),e(X,nm),e(X,K),b(xo,K,null),e(K,sm),e(K,Le),e(Le,rm),e(Le,ss),e(ss,am),e(Le,im),e(Le,rs),e(rs,lm),e(Le,mm),e(K,pm),b(Mt,K,null),e(K,dm),b(Ot,K,null),e(K,cm),b(qt,K,null),Zs=!0},p(t,[g]){const vo={};g&2&&(vo.$$scope={dirty:g,ctx:t}),Je.$set(vo);const as={};g&2&&(as.$$scope={dirty:g,ctx:t}),Ke.$set(as);const is={};g&2&&(is.$$scope={dirty:g,ctx:t}),Ye.$set(is);const ls={};g&2&&(ls.$$scope={dirty:g,ctx:t}),et.$set(ls);const To={};g&2&&(To.$$scope={dirty:g,ctx:t}),tt.$set(To);const ms={};g&2&&(ms.$$scope={dirty:g,ctx:t}),ot.$set(ms);const bo={};g&2&&(bo.$$scope={dirty:g,ctx:t}),st.$set(bo);const ps={};g&2&&(ps.$$scope={dirty:g,ctx:t}),rt.$set(ps);const ds={};g&2&&(ds.$$scope={dirty:g,ctx:t}),at.$set(ds);const cs={};g&2&&(cs.$$scope={dirty:g,ctx:t}),it.$set(cs);const Y={};g&2&&(Y.$$scope={dirty:g,ctx:t}),mt.$set(Y);const us={};g&2&&(us.$$scope={dirty:g,ctx:t}),pt.$set(us);const hs={};g&2&&(hs.$$scope={dirty:g,ctx:t}),dt.$set(hs);const fs={};g&2&&(fs.$$scope={dirty:g,ctx:t}),ut.$set(fs);const gs={};g&2&&(gs.$$scope={dirty:g,ctx:t}),ht.$set(gs);const De={};g&2&&(De.$$scope={dirty:g,ctx:t}),ft.$set(De);const _s={};g&2&&(_s.$$scope={dirty:g,ctx:t}),_t.$set(_s);const $s={};g&2&&($s.$$scope={dirty:g,ctx:t}),$t.$set($s);const Mo={};g&2&&(Mo.$$scope={dirty:g,ctx:t}),kt.$set(Mo);const ks={};g&2&&(ks.$$scope={dirty:g,ctx:t}),xt.$set(ks);const ws={};g&2&&(ws.$$scope={dirty:g,ctx:t}),vt.$set(ws);const xs={};g&2&&(xs.$$scope={dirty:g,ctx:t}),Tt.$set(xs);const ne={};g&2&&(ne.$$scope={dirty:g,ctx:t}),Mt.$set(ne);const vs={};g&2&&(vs.$$scope={dirty:g,ctx:t}),Ot.$set(vs);const Ts={};g&2&&(Ts.$$scope={dirty:g,ctx:t}),qt.$set(Ts)},i(t){Zs||(M(s.$$.fragment,t),M(jt.$$.fragment,t),M(Et.$$.fragment,t),M(Rt.$$.fragment,t),M(Ft.$$.fragment,t),M(Ct.$$.fragment,t),M(At.$$.fragment,t),M(St.$$.fragment,t),M(Pt.$$.fragment,t),M(Nt.$$.fragment,t),M(Lt.$$.fragment,t),M(Dt.$$.fragment,t),M(Xt.$$.fragment,t),M(Qt.$$.fragment,t),M(Wt.$$.fragment,t),M(Vt.$$.fragment,t),M(Je.$$.fragment,t),M(Ke.$$.fragment,t),M(Ye.$$.fragment,t),M(Ut.$$.fragment,t),M(Gt.$$.fragment,t),M(Kt.$$.fragment,t),M(et.$$.fragment,t),M(tt.$$.fragment,t),M(ot.$$.fragment,t),M(Yt.$$.fragment,t),M(Zt.$$.fragment,t),M(to.$$.fragment,t),M(st.$$.fragment,t),M(rt.$$.fragment,t),M(at.$$.fragment,t),M(it.$$.fragment,t),M(oo.$$.fragment,t),M(no.$$.fragment,t),M(ro.$$.fragment,t),M(mt.$$.fragment,t),M(pt.$$.fragment,t),M(dt.$$.fragment,t),M(ao.$$.fragment,t),M(io.$$.fragment,t),M(mo.$$.fragment,t),M(ut.$$.fragment,t),M(ht.$$.fragment,t),M(ft.$$.fragment,t),M(po.$$.fragment,t),M(co.$$.fragment,t),M(uo.$$.fragment,t),M(_t.$$.fragment,t),M($t.$$.fragment,t),M(kt.$$.fragment,t),M(ho.$$.fragment,t),M(fo.$$.fragment,t),M(_o.$$.fragment,t),M(xt.$$.fragment,t),M(vt.$$.fragment,t),M(Tt.$$.fragment,t),M($o.$$.fragment,t),M(ko.$$.fragment,t),M(xo.$$.fragment,t),M(Mt.$$.fragment,t),M(Ot.$$.fragment,t),M(qt.$$.fragment,t),Zs=!0)},o(t){O(s.$$.fragment,t),O(jt.$$.fragment,t),O(Et.$$.fragment,t),O(Rt.$$.fragment,t),O(Ft.$$.fragment,t),O(Ct.$$.fragment,t),O(At.$$.fragment,t),O(St.$$.fragment,t),O(Pt.$$.fragment,t),O(Nt.$$.fragment,t),O(Lt.$$.fragment,t),O(Dt.$$.fragment,t),O(Xt.$$.fragment,t),O(Qt.$$.fragment,t),O(Wt.$$.fragment,t),O(Vt.$$.fragment,t),O(Je.$$.fragment,t),O(Ke.$$.fragment,t),O(Ye.$$.fragment,t),O(Ut.$$.fragment,t),O(Gt.$$.fragment,t),O(Kt.$$.fragment,t),O(et.$$.fragment,t),O(tt.$$.fragment,t),O(ot.$$.fragment,t),O(Yt.$$.fragment,t),O(Zt.$$.fragment,t),O(to.$$.fragment,t),O(st.$$.fragment,t),O(rt.$$.fragment,t),O(at.$$.fragment,t),O(it.$$.fragment,t),O(oo.$$.fragment,t),O(no.$$.fragment,t),O(ro.$$.fragment,t),O(mt.$$.fragment,t),O(pt.$$.fragment,t),O(dt.$$.fragment,t),O(ao.$$.fragment,t),O(io.$$.fragment,t),O(mo.$$.fragment,t),O(ut.$$.fragment,t),O(ht.$$.fragment,t),O(ft.$$.fragment,t),O(po.$$.fragment,t),O(co.$$.fragment,t),O(uo.$$.fragment,t),O(_t.$$.fragment,t),O($t.$$.fragment,t),O(kt.$$.fragment,t),O(ho.$$.fragment,t),O(fo.$$.fragment,t),O(_o.$$.fragment,t),O(xt.$$.fragment,t),O(vt.$$.fragment,t),O(Tt.$$.fragment,t),O($o.$$.fragment,t),O(ko.$$.fragment,t),O(xo.$$.fragment,t),O(Mt.$$.fragment,t),O(Ot.$$.fragment,t),O(qt.$$.fragment,t),Zs=!1},d(t){o(n),t&&o($),t&&o(c),q(s),t&&o(w),t&&o(E),t&&o(bs),t&&o(xe),q(jt),t&&o(Ms),t&&o(Q),t&&o(Os),q(Et,t),t&&o(qs),t&&o(se),t&&o(ys),q(Rt,t),t&&o(js),t&&o(ve),q(Ft),t&&o(Es),t&&o(ee),t&&o(Rs),q(Ct,t),t&&o(Fs),t&&o(Te),q(At),t&&o(zs),t&&o(re),t&&o(Cs),q(St,t),t&&o(As),t&&o(be),q(Pt),t&&o(Ss),t&&o(S),q(Nt),q(Lt),q(Dt),q(Xt),t&&o(Ps),t&&o(Me),q(Qt),t&&o(Ns),t&&o(P),q(Wt),q(Vt),q(Je),q(Ke),q(Ye),t&&o(Is),t&&o(qe),q(Ut),t&&o(Ls),t&&o(N),q(Gt),q(Kt),q(et),q(tt),q(ot),t&&o(Ds),t&&o(je),q(Yt),t&&o(Hs),t&&o(I),q(Zt),q(to),q(st),q(rt),q(at),q(it),t&&o(Xs),t&&o(Re),q(oo),t&&o(Qs),t&&o(L),q(no),q(ro),q(mt),q(pt),q(dt),t&&o(Ws),t&&o(ze),q(ao),t&&o(Bs),t&&o(D),q(io),q(mo),q(ut),q(ht),q(ft),t&&o(Vs),t&&o(Ae),q(po),t&&o(Us),t&&o(oe),q(co),q(uo),q(_t),q($t),q(kt),t&&o(Gs),t&&o(Pe),q(ho),t&&o(Js),t&&o(H),q(fo),q(_o),q(xt),q(vt),q(Tt),t&&o(Ks),t&&o(Ie),q($o),t&&o(Ys),t&&o(X),q(ko),q(xo),q(Mt),q(Ot),q(qt)}}}const dd={local:"optimum-inference-with-onnx-runtime",sections:[{local:"switching-from-transformers-to-optimum-inference",sections:[{local:"working-with-the-hugging-face-model-hub",title:"Working with the Hugging Face Model Hub"}],title:"Switching from Transformers to Optimum Inference"},{local:"export-and-inference-of-sequencetosequence-models",title:"Export and inference of sequence-to-sequence models"},{local:"optimum.onnxruntime.ORTModel",title:"ORTModel"},{local:"optimum.onnxruntime.ORTModelForFeatureExtraction",title:"ORTModelForFeatureExtraction"},{local:"optimum.onnxruntime.ORTModelForQuestionAnswering",title:"ORTModelForQuestionAnswering"},{local:"optimum.onnxruntime.ORTModelForSequenceClassification",title:"ORTModelForSequenceClassification"},{local:"optimum.onnxruntime.ORTModelForTokenClassification",title:"ORTModelForTokenClassification"},{local:"optimum.onnxruntime.ORTModelForCausalLM",title:"ORTModelForCausalLM"},{local:"optimum.onnxruntime.ORTModelForSeq2SeqLM",title:"ORTModelForSeq2SeqLM"},{local:"optimum.onnxruntime.ORTModelForImageClassification",title:"ORTModelForImageClassification"},{local:"optimum.onnxruntime.ORTModelForCustomTasks",title:"ORTModelForCustomTasks"}],title:"Optimum Inference with ONNX Runtime"};function cd(j){return Np(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class kd extends Cp{constructor(n){super();Ap(this,n,cd,pd,Sp,{})}}export{kd as default,dd as metadata};
